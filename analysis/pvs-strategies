(defparameter *derivable-rews* '("derivable_id_lam"
				 "derivable_const_lam"
				 "derivable_add_lam"
				 "derivable_scal1_lam"
				 "derivable_scal2_lam"
				 "derivable_mult_lam"
				 "derivable_pow_lam"
				 "derivable_neg_lam"
				 "derivable_sub_lam"
				 "derivable_sq_lam"
				 "derivable_scald1_lam"
				 "derivable_scald2_lam"
				 "derivable_div_lam"))

(defparameter *deriv-rews* '("deriv_id_lam"
			     "deriv_const_lam"
			     "deriv_add_lam"
			     "deriv_scal1_lam"
			     "deriv_scal2_lam"
			     "deriv_mult_lam"
			     "deriv_pow_lam"
			     "deriv_neg_lam"
			     "deriv_sub_lam"
			     "deriv_sq_lam"
			     "deriv_scald1_lam"
			     "deriv_scald2_lam"
			     "deriv_div_lam"))

(defparameter *derivable-ops* '("o"
				"real_fun_ops.+"
				"real_fun_ops.-"
				"real_fun_ops.*"
				"real_fun_ops./"
				"real_fun_ops.inv"))

(defhelper derivable__ (&optional (fnum 1))
  (let ((rws   *derivable-rews*)
	(ops   *derivable-ops*)
	(qfnum (list 'quote fnum))
	(expr  (extra-get-formula fnum))
	(deriv (is-function-expr expr '("derivable?")))
	(name  (when deriv (argument expr)))
	(expnd (and (is-const-decl-expr name) (id name))))
    (when deriv
      (when expnd (expand expnd fnum))
      (mapstep@ #'(lambda(x)`(expand ,x ,qfnum)) ops)
      (try (rewrites rws fnum)
	   (derivable__$)
	   (try (rewrite "comp_derivable_fun" fnum)
		(derivable__$)
		(skip)))))
  "Internal strategy. DO NOT USE, use derivable instead"
  "")

(defstep derivable (&optional (fnum 1))
  (if (not (check-name "analysis@strategies.AnalysisStrategies__"))
      (printf "This strategy requires theory analysis@strategies to be imported in the current context")
    (let ((fn   (extra-get-fnum fnum))
	  (expr (and fn (> fn 0) (extra-get-formula fnum))))
      (if (not (is-function-expr expr '("derivable?")))
	  (printf "Formula of the form derivable?(...) must appear in the consequent")
	(derivable__$ fnum))))
  "Discharges a formula of the form derivable?(f) in the consequent, where f is a function of type [real->real]"
  "Discharging derivable(f) in ~a")

(defstrat differentiable (&optional (fnum 1))
  (derivable fnum)
  "Same as derivable")

(defhelper deriv__ (fnum &optional fun)
  (let ((rws   *deriv-rews*)
	(ops   *derivable-ops*)
	(qfnum (list 'quote fnum))
	(expr  (or fun (extra-get-expr `(~ ,fnum "deriv(%1)"))))
	(expnd (and (is-const-decl-expr expr) (id expr))))
    (when expr
      (when expnd (expand expnd fnum))
      (mapstep@ #'(lambda(x)`(expand ,x ,qfnum)) ops)
      (try-branch
       (rewrites rws fnum)
       ((then (beta fnum) (real-props fnum) (deriv__$ fnum))
	(derivable))
       (try-branch
	(rewrite "chain_rule" fnum)
	((then (expand "*" fnum) (deriv__$ fnum))
	 (derivable))
	(skip)))))
  "Internal strategy. DO NOT USE, use deriv instead"
  "")

(defstep deriv (f &optional (fnums *))
  (if (not (check-name "analysis@strategies.AnalysisStrategies__"))
      (printf "This strategy requires theory analysis@strategies to be imported in the current context")
    (let ((fun   (extra-get-expr f))
	  (drvbl (format nil "derivable?(~a)" fun))
	  (drv   (format nil "deriv(~a)" fun)))
      (with-fresh-labels
       ((fnum!) (fnums! fnums))
       (spread
	(with-tccs (case drvbl))
	((with-fresh-names@
	  ((d_))
	  (name-label d_ drv :label fnum! :dir rl)
	  (deriv__$ fnum! fun)
	  (let ((fns (extra-get-fnums fnums!)))
	    (when fns
	      (replace fnum! fns)
	      (beta fns)
	      (rewrites ("expt_x0" "expt_x1") fns))))
	 (derivable))))))
  "Computes the derivative of f and introduces the hypotheses derivable?(f) and deriv(f) = f', where f is a function of type [real->real]. The derivative is replaced in the formulas in FNUMS."
  "Computing deriv(~a)")
