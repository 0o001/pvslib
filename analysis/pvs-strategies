(defparameter *derivable-rews* '("derivable_id_lam"
				 "derivable_const_lam"
				 "derivable_add_lam"
				 "derivable_mult_lam"
				 "derivable_pow_lam"
				 "derivable_scal1_lam"
				 "derivable_scal2_lam"
				 "derivable_neg_lam"
				 "derivable_sub_lam"
				 "derivable_sq_lam"
				 "derivable_div_lam"
				 "derivable_scald1_lam"
				 "derivable_scald2_lam"))

(defparameter *derivable-ops* '("o"
				"real_fun_ops.+"
				"real_fun_ops.-"
				"real_fun_ops.*"
				"real_fun_ops./"
				"real_fun_ops.inv"))

(defhelper derivable__ (&optional (fnum 1))
  (let ((rws   *derivable-rews*)
	(expr  (extra-get-formula fnum))
	(deriv (is-function-expr expr '("derivable?")))
	(name  (when deriv (argument expr)))
	(expnd (and (is-const-decl-expr name) (id name))))
    (when deriv
      (when expnd
	(expand expnd fnum))
      (try (rewrites rws fnum)
	   (derivable__$)
	   (try (rewrite "comp_derivable_fun" fnum)
		(derivable__$)
		(skip)))))
  "Interval strategy"
  "")

(defstep derivable (&optional (fnum 1))
  (if (not (check-name "analysis@strategies.AnalysisStrategies__"))
      (printf "This strategy requires theory analysis@strategies to be imported in the current context")
    (let ((ops  *derivable-ops*)
	  (fn   (extra-get-fnum fnum))
	  (expr (and fn (> fn 0) (extra-get-formula fnum))))
      (if (not (is-function-expr expr '("derivable?")))
	  (printf "Formula of the form derivable?(...) must appear in the consequent")
	(then@
	 (mapstep@ #'(lambda(x)`(expand ,x ,fn)) ops)
	 (derivable__$ fnum)))))
  "Discharges a formula of the form derivable?(f) in the consequent, where f is a function of type [real->real]"
  "Discharging derivable(f) in ~a")

(defstrat differentiable (&optional (fnum 1))
  (derivable fnum)
  "Same as derivable")
