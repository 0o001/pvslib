(interval_examples
 (sqrt23 0
  (sqrt23-1 nil 3600857800 ("" (numerical (! 1 1) :verbose? t) nil)
   ((IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     IntervalExpr_adt "interval_arith/")
    (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]"
     IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (SQRT_n const-decl "RealExpr" interval_expr_extra
     "interval_arith/")
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (PI_n const-decl "RealExpr" interval_expr_trig "interval_arith/")
    (numerical_soundness formula-decl nil numerical_bandb
     "interval_arith/")
    (sound? const-decl "bool" numerical_bandb "interval_arith/")
    (listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list2array def-decl "T" array2list "structures/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (sqrt_is_safe formula-decl nil interval_expr_extra
     "interval_arith/")
    (pi_safe const-decl "[Unit -> real]" interval_expr_trig
     "interval_arith/")
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nml_49 skolem-const-decl "(sub?)" interval_examples nil)
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx "trig/")
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def "trig/")
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (sqrt_pos application-judgement "posreal" sqrt "reals/")
    (|##| const-decl "bool" interval "interval_arith/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (eval def-decl "real" interval_expr "interval_arith/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnreal type-eq-decl nil real_types nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt "reals/")
    (< const-decl "bool" reals nil)
    (cos const-decl "real" sincos_def "trig/")
    (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}"
     pi_def "trig/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (ProperBox type-eq-decl nil box "interval_arith/")
    (IntervalMinMax type-eq-decl nil numerical_bandb "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (numerical const-decl "Output" numerical_bandb "interval_arith/")
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (altdir_maxvar const-decl "DirVar" numerical_bandb
     "interval_arith/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (sin6sqrt2 0
  (sin6sqrt2-1 nil 3600857800 ("" (numerical (! 1 1)) nil)
   ((IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]"
     IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (SIN_n const-decl "RealExpr" interval_expr_trig "interval_arith/")
    (DIV adt-constructor-decl "[[RealExpr, RealExpr] -> (div?)]"
     IntervalExpr_adt "interval_arith/")
    (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]"
     IntervalExpr_adt "interval_arith/")
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (PI_n const-decl "RealExpr" interval_expr_trig "interval_arith/")
    (SQRT_n const-decl "RealExpr" interval_expr_extra
     "interval_arith/")
    (numerical_soundness formula-decl nil numerical_bandb
     "interval_arith/")
    (sound? const-decl "bool" numerical_bandb "interval_arith/")
    (listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list2array def-decl "T" array2list "structures/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (sqrt_is_safe formula-decl nil interval_expr_extra
     "interval_arith/")
    (pi_safe const-decl "[Unit -> real]" interval_expr_trig
     "interval_arith/")
    (nml_50 skolem-const-decl "(add?)" interval_examples nil)
    (sqrt_pos application-judgement "posreal" sqrt "reals/")
    (sin_range application-judgement "real_abs_le1" sincos "trig/")
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx "trig/")
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def "trig/")
    (|##| const-decl "bool" interval "interval_arith/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (eval def-decl "real" interval_expr "interval_arith/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sin const-decl "real" sincos_def "trig/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (cos const-decl "real" sincos_def "trig/")
    (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}"
     pi_def "trig/")
    (nnreal type-eq-decl nil real_types nil)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt "reals/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil box "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (ProperBox type-eq-decl nil box "interval_arith/")
    (IntervalMinMax type-eq-decl nil numerical_bandb "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (numerical const-decl "Output" numerical_bandb "interval_arith/")
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (altdir_maxvar const-decl "DirVar" numerical_bandb
     "interval_arith/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (sqrtx3_TCC1 0
  (sqrtx3_TCC1-1 nil 3600857800 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/"))
   nil))
 (sqrtx3 0
  (sqrtx3-1 nil 3600857800 ("" (interval) nil)
   ((listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (FALSE const-decl "bool" booleans nil)
    (vars_in_box formula-decl nil box "interval_arith/")
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box_rec def-decl
     "{b: bool | b = (FORALL (k: subrange(i, n - 1)): vs(k) ## nth(box, k - i))}"
     box "interval_arith/")
    (iar_51 skolem-const-decl "(bimplies?)" interval_examples nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (sqrt_is_safe formula-decl nil interval_expr_extra
     "interval_arith/")
    (pi_safe const-decl "[Unit -> real]" interval_expr_trig
     "interval_arith/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (eval def-decl "real" interval_expr "interval_arith/")
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (sqrt_pos application-judgement "posreal" sqrt "reals/")
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def "trig/")
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx "trig/")
    (x_52 skolem-const-decl "real" interval_examples nil)
    (list2array def-decl "T" array2list "structures/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (PI_n const-decl "RealExpr" interval_expr_trig "interval_arith/")
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (SQRT_n const-decl "RealExpr" interval_expr_extra
     "interval_arith/")
    (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]"
     IntervalExpr_adt "interval_arith/")
    (< const-decl "bool" reals nil)
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (realorder? const-decl "bool" real_orders "reals/")
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (BINCLUDES adt-constructor-decl
     "[[RealExpr, Interval] -> (bincludes?)]" IntervalExpr_adt
     "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BIMPLIES adt-constructor-decl
     "[[BoolExpr, BoolExpr] -> (bimplies?)]" IntervalExpr_adt
     "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (nnreal_plus_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (>= const-decl "bool" reals nil))
   shostak))
 (tr_TCC1 0
  (tr_TCC1-1 nil 3600857800
   ("" (skosimp*)
    (("" (replace -1)
      (("" (hide -1) (("" (mult-cases -1) nil nil)) nil)) nil))
    nil)
   ((posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}"
     pi_def "trig/")
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (cos const-decl "real" sincos_def "trig/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (zero_times3 formula-decl nil real_props nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx "trig/")
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def
     "trig/"))
   nil))
 (tr_TCC2 0
  (tr_TCC2-1 nil 3708378650 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cos const-decl "real" sincos_def "trig/")
    (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}"
     pi_def "trig/")
    (cos_range application-judgement "real_abs_le1" sincos "trig/")
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (Tan? const-decl "bool" trig_basic "trig/")
    (/= const-decl "boolean" notequal nil)
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def "trig/")
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx "trig/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil))
   nil))
 (tr_250_35_TCC1 0
  (tr_250_35_TCC1-1 nil 3600857800
   ("" (skeep :preds? t)
    (("" (replaces -5)
      (("" (expand "Tan?") (("" (interval -5) nil nil)) nil)) nil))
    nil)
   ((Tan? const-decl "bool" trig_basic "trig/")
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (BNOT adt-constructor-decl "[BoolExpr -> (bnot?)]" IntervalExpr_adt
     "interval_arith/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (FALSE const-decl "bool" booleans nil)
    (vars_in_box_rec def-decl
     "{b: bool | b = (FORALL (k: subrange(i, n - 1)): vs(k) ## nth(box, k - i))}"
     box "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box formula-decl nil box "interval_arith/")
    (iar_53 skolem-const-decl "(band?)" interval_examples nil)
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx "trig/")
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def "trig/")
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (cos_range application-judgement "real_abs_le1" sincos "trig/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (eval def-decl "real" interval_expr "interval_arith/")
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (PI!1 skolem-const-decl
     "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" interval_examples
     nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (cos const-decl "real" sincos_def "trig/")
    (< const-decl "bool" reals nil) (> const-decl "bool" reals nil)
    (list2array def-decl "T" array2list "structures/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]"
     IntervalExpr_adt "interval_arith/")
    (DIV adt-constructor-decl "[[RealExpr, RealExpr] -> (div?)]"
     IntervalExpr_adt "interval_arith/")
    (COS_n const-decl "RealExpr" interval_expr_trig "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (realorder? const-decl "bool" real_orders "reals/")
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (BAND adt-constructor-decl "[[BoolExpr, BoolExpr] -> (band?)]"
     IntervalExpr_adt "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/"))
   nil))
 (tr_250_35 0
  (tr_250_35-1 nil 3600857800 ("" (interval) nil)
   ((listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (FALSE const-decl "bool" booleans nil)
    (Env type-eq-decl nil box "interval_arith/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (list2array def-decl "T" array2list "structures/")
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (realexpr? const-decl "bool" interval_expr "interval_arith/")
    (eval def-decl "real" interval_expr "interval_arith/")
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (tan_safe const-decl "real" interval_expr_trig "interval_arith/")
    (pi_safe const-decl "[Unit -> real]" interval_expr_trig
     "interval_arith/")
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (V_0_55 skolem-const-decl "RealExpr" interval_examples nil)
    (V_1_56 skolem-const-decl "(letin?)" interval_examples nil)
    (iar_54 skolem-const-decl "(bletin?)" interval_examples nil)
    (g const-decl "posreal" interval_examples nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (BLETIN adt-constructor-decl
     "[[IntervalExpr, BoolExpr] -> (bletin?)]" IntervalExpr_adt
     "interval_arith/")
    (BAND adt-constructor-decl "[[BoolExpr, BoolExpr] -> (band?)]"
     IntervalExpr_adt "interval_arith/")
    (realorder? const-decl "bool" real_orders "reals/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (<= const-decl "bool" reals nil)
    (LETIN adt-constructor-decl "[[RealExpr, RealExpr] -> (letin?)]"
     IntervalExpr_adt "interval_arith/")
    (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]"
     IntervalExpr_adt "interval_arith/")
    (DIV adt-constructor-decl "[[RealExpr, RealExpr] -> (div?)]"
     IntervalExpr_adt "interval_arith/")
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (TAN_n const-decl "RealExpr" interval_expr_trig "interval_arith/")
    (PI_n const-decl "RealExpr" interval_expr_trig "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx "trig/")
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def "trig/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (cos_range application-judgement "real_abs_le1" sincos "trig/")
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cos const-decl "real" sincos_def "trig/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}"
     pi_def "trig/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Tan? const-decl "bool" trig_basic "trig/"))
   shostak))
 (tr_200_250_abs_35 0
  (tr_200_250_abs_35-1 nil 3600857800
   ("" (then (skeep) (interval)) nil)
   ((posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx "trig/")
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def "trig/")
    (listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (FALSE const-decl "bool" booleans nil)
    (Env type-eq-decl nil box "interval_arith/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (list2array def-decl "T" array2list "structures/")
    (v skolem-const-decl "posreal" interval_examples nil)
    (phi skolem-const-decl "{deg: real | Tan?(pi * deg / 180)}"
     interval_examples nil)
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (eval def-decl "real" interval_expr "interval_arith/")
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (tan_safe const-decl "real" interval_expr_trig "interval_arith/")
    (pi_safe const-decl "[Unit -> real]" interval_expr_trig
     "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (V_0_58 skolem-const-decl "RealExpr" interval_examples nil)
    (iar_57 skolem-const-decl "(brel?)" interval_examples nil)
    (vars_in_box formula-decl nil box "interval_arith/")
    (vars_in_box_rec def-decl
     "{b: bool | b = (FORALL (k: subrange(i, n - 1)): vs(k) ## nth(box, k - i))}"
     box "interval_arith/")
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (abs_le formula-decl nil abs_lems "reals/")
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (tan const-decl "real" trig_basic "trig/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (g const-decl "posreal" interval_examples nil)
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (realorder? const-decl "bool" real_orders "reals/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (<= const-decl "bool" reals nil)
    (ABS adt-constructor-decl "[RealExpr -> (abs?)]" IntervalExpr_adt
     "interval_arith/")
    (LETIN adt-constructor-decl "[[RealExpr, RealExpr] -> (letin?)]"
     IntervalExpr_adt "interval_arith/")
    (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]"
     IntervalExpr_adt "interval_arith/")
    (DIV adt-constructor-decl "[[RealExpr, RealExpr] -> (div?)]"
     IntervalExpr_adt "interval_arith/")
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (TAN_n const-decl "RealExpr" interval_expr_trig "interval_arith/")
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (PI_n const-decl "RealExpr" interval_expr_trig "interval_arith/")
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cos_range application-judgement "real_abs_le1" sincos "trig/")
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cos const-decl "real" sincos_def "trig/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}"
     pi_def "trig/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (Tan? const-decl "bool" trig_basic "trig/"))
   shostak))
 (G_TCC1 0
  (G_TCC1-1 nil 3600857800 ("" (subtype-tcc) nil nil) nil nil))
 (A_and_S_TCC1 0
  (A_and_S_TCC1-1 nil 3600857800 ("" (subtype-tcc) nil nil)
   ((lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (X const-decl "posreal" interval_examples nil))
   nil))
 (A_and_S_TCC2 0
  (A_and_S_TCC2-1 nil 3600857800 ("" (subtype-tcc) nil nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (X const-decl "posreal" interval_examples nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/"))
   nil))
 (A_and_S 0
  (A_and_S-1 nil 3600857800 ("" (interval) nil)
   ((listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (FALSE const-decl "bool" booleans nil)
    (Env type-eq-decl nil box "interval_arith/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (list2array def-decl "T" array2list "structures/")
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (eval def-decl "real" interval_expr "interval_arith/")
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ln_safe const-decl "real" interval_expr_lnexp "interval_arith/")
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (iar_59 skolem-const-decl "(brel?)" interval_examples nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (LN_n const-decl "RealExpr" interval_expr_lnexp "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     IntervalExpr_adt "interval_arith/")
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (RealOrder type-eq-decl nil real_orders "reals/")
    (realorder? const-decl "bool" real_orders "reals/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (X const-decl "posreal" interval_examples nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil))
   shostak))
 (common_point_TCC1 0
  (common_point_TCC1-1 nil 3600857800 ("" (subtype-tcc) nil nil)
   (([\|\|] const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (/= const-decl "boolean" notequal nil))
   nil))
 (common_point_TCC2 0
  (common_point_TCC2-1 nil 3600857800 ("" (subtype-tcc) nil nil)
   (([\|\|] const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (/= const-decl "boolean" notequal nil))
   nil))
 (common_point_TCC3 0
  (common_point_TCC3-1 nil 3600857800 ("" (subtype-tcc) nil nil)
   ((sqrt_pos application-judgement "posreal" sqrt "reals/")
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (cos_range application-judgement "real_abs_le1" sincos "trig/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (|##| const-decl "bool" interval "interval_arith/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (^ const-decl "real" exponentiation nil))
   nil))
 (common_point_TCC4 0
  (common_point_TCC4-1 nil 3600857800 ("" (subtype-tcc) nil nil)
   ((sqrt_pos application-judgement "posreal" sqrt "reals/")
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (sin_range application-judgement "real_abs_le1" sincos "trig/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (|##| const-decl "bool" interval "interval_arith/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (^ const-decl "real" exponentiation nil))
   nil))
 (common_point 0
  (common_point-1 nil 3600857800 ("" (interval :verbose? t) nil)
   ((nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (FALSE const-decl "bool" booleans nil)
    (BNOT adt-constructor-decl "[BoolExpr -> (bnot?)]" IntervalExpr_adt
     "interval_arith/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (iar_60 skolem-const-decl "(band?)" interval_examples nil)
    (list2array def-decl "T" array2list "structures/")
    (sqrt_is_safe formula-decl nil interval_expr_extra
     "interval_arith/")
    (posrat_plus_nnrat_is_posrat application-judgement "posrat"
     rationals nil)
    (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}"
     real_defs nil)
    (eval def-decl "real" interval_expr "interval_arith/")
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (SIN_n const-decl "RealExpr" interval_expr_trig "interval_arith/")
    (COS_n const-decl "RealExpr" interval_expr_trig "interval_arith/")
    (SQRT_n const-decl "RealExpr" interval_expr_extra
     "interval_arith/")
    (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]"
     IntervalExpr_adt "interval_arith/")
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     IntervalExpr_adt "interval_arith/")
    (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]"
     IntervalExpr_adt "interval_arith/")
    (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]"
     IntervalExpr_adt "interval_arith/")
    (BINCLUDES adt-constructor-decl
     "[[RealExpr, Interval] -> (bincludes?)]" IntervalExpr_adt
     "interval_arith/")
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (ABS adt-constructor-decl "[RealExpr -> (abs?)]" IntervalExpr_adt
     "interval_arith/")
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (realorder? const-decl "bool" real_orders "reals/")
    (BAND adt-constructor-decl "[[BoolExpr, BoolExpr] -> (band?)]"
     IntervalExpr_adt "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (sin_range application-judgement "real_abs_le1" sincos "trig/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (cos_range application-judgement "real_abs_le1" sincos "trig/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (sqrt_pos application-judgement "posreal" sqrt "reals/")
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (^ const-decl "real" exponentiation nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnreal type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt "reals/")
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (cos const-decl "real" sincos_def "trig/")
    (sin const-decl "real" sincos_def "trig/"))
   shostak))
 (r_TCC1 0
  (r_TCC1-1 nil 3600857800 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (r_TCC2 0
  (r_TCC2-1 nil 3600857800 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (atan_implementation 0
  (atan_implementation-1 nil 3600857800
   ("" (interval :precision 4) nil)
   ((listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (FALSE const-decl "bool" booleans nil)
    (vars_in_box formula-decl nil box "interval_arith/")
    (length_singleton formula-decl nil more_list_props "structures/")
    (|##| const-decl "bool" interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (atan const-decl "{x: real_abs_lt_pi2 | y = tan_restrict(x)}" atan
          "trig/")
    (tan_restrict const-decl "real" trig_basic "trig/")
    (real_abs_lt_pi2 nonempty-type-eq-decl nil trig_types "trig/")
    (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}"
     pi_def "trig/")
    (cos const-decl "real" sincos_def "trig/")
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs_le formula-decl nil abs_lems "reals/")
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (vars_in_box_rec def-decl
     "{b: bool | b = (FORALL (k: subrange(i, n - 1)): vs(k) ## nth(box, k - i))}"
     box "interval_arith/")
    (iar_61 skolem-const-decl "(bimplies?)" interval_examples nil)
    (eval def-decl "real" interval_expr "interval_arith/")
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (x_62 skolem-const-decl "real" interval_examples nil)
    (list2array def-decl "T" array2list "structures/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (^ const-decl "real" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]"
     IntervalExpr_adt "interval_arith/")
    (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]"
     IntervalExpr_adt "interval_arith/")
    (ATAN_n const-decl "RealExpr" interval_expr_trig "interval_arith/")
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     IntervalExpr_adt "interval_arith/")
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (ABS adt-constructor-decl "[RealExpr -> (abs?)]" IntervalExpr_adt
     "interval_arith/")
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (realorder? const-decl "bool" real_orders "reals/")
    (BIMPLIES adt-constructor-decl
     "[[BoolExpr, BoolExpr] -> (bimplies?)]" IntervalExpr_adt
     "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}"
     atan_approx "trig/")
    (pi_bound name-judgement
     "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def "trig/")
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil))
   shostak))
 (ex1_ba_TCC1 0
  (ex1_ba_TCC1-1 nil 3600857800 ("" (subtype-tcc) nil nil)
   (([\|\|] const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (/= const-decl "boolean" notequal nil))
   nil))
 (ex1_ba_TCC2 0
  (ex1_ba_TCC2-1 nil 3600857800 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/"))
   nil))
 (ex1_ba 0
  (ex1_ba-1 nil 3600857801 ("" (interval) nil)
   ((listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (FALSE const-decl "bool" booleans nil)
    (vars_in_box formula-decl nil box "interval_arith/")
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box_rec def-decl
     "{b: bool | b = (FORALL (k: subrange(i, n - 1)): vs(k) ## nth(box, k - i))}"
     box "interval_arith/")
    (iar_63 skolem-const-decl "(bimplies?)" interval_examples nil)
    (ln_safe const-decl "real" interval_expr_lnexp "interval_arith/")
    (eval def-decl "real" interval_expr "interval_arith/")
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (x_64 skolem-const-decl "real" interval_examples nil)
    (list2array def-decl "T" array2list "structures/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (epsilon const-decl "real" interval_examples nil)
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]"
     IntervalExpr_adt "interval_arith/")
    (LN_n const-decl "RealExpr" interval_expr_lnexp "interval_arith/")
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]"
     IntervalExpr_adt "interval_arith/")
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     IntervalExpr_adt "interval_arith/")
    (<= const-decl "bool" reals nil)
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (realorder? const-decl "bool" real_orders "reals/")
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (BINCLUDES adt-constructor-decl
     "[[RealExpr, Interval] -> (bincludes?)]" IntervalExpr_adt
     "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BIMPLIES adt-constructor-decl
     "[[BoolExpr, BoolExpr] -> (bimplies?)]" IntervalExpr_adt
     "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil))
   shostak))
 (ex2_ba_TCC1 0
  (ex2_ba_TCC1-1 nil 3600857800 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/"))
   nil))
 (ex2_ba 0
  (ex2_ba-1 nil 3600857801 ("" (interval) nil)
   ((listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (FALSE const-decl "bool" booleans nil)
    (vars_in_box formula-decl nil box "interval_arith/")
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box_rec def-decl
     "{b: bool | b = (FORALL (k: subrange(i, n - 1)): vs(k) ## nth(box, k - i))}"
     box "interval_arith/")
    (iar_65 skolem-const-decl "(bimplies?)" interval_examples nil)
    (ln_safe const-decl "real" interval_expr_lnexp "interval_arith/")
    (eval def-decl "real" interval_expr "interval_arith/")
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (x_66 skolem-const-decl "real" interval_examples nil)
    (list2array def-decl "T" array2list "structures/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (epsilon const-decl "real" interval_examples nil)
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (NEG adt-constructor-decl "[RealExpr -> (neg?)]" IntervalExpr_adt
     "interval_arith/")
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (LN_n const-decl "RealExpr" interval_expr_lnexp "interval_arith/")
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     IntervalExpr_adt "interval_arith/")
    (<= const-decl "bool" reals nil)
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (realorder? const-decl "bool" real_orders "reals/")
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (BINCLUDES adt-constructor-decl
     "[[RealExpr, Interval] -> (bincludes?)]" IntervalExpr_adt
     "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BIMPLIES adt-constructor-decl
     "[[BoolExpr, BoolExpr] -> (bimplies?)]" IntervalExpr_adt
     "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (minus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil))
   shostak))
 (ex3_ba_TCC1 0
  (ex3_ba_TCC1-1 nil 3600857800 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/"))
   nil))
 (ex3_ba 0
  (ex3_ba-1 nil 3600857801 ("" (interval) nil)
   ((listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (FALSE const-decl "bool" booleans nil)
    (vars_in_box formula-decl nil box "interval_arith/")
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box_rec def-decl
     "{b: bool | b = (FORALL (k: subrange(i, n - 1)): vs(k) ## nth(box, k - i))}"
     box "interval_arith/")
    (iar_67 skolem-const-decl "(bimplies?)" interval_examples nil)
    (ln_safe const-decl "real" interval_expr_lnexp "interval_arith/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (eval def-decl "real" interval_expr "interval_arith/")
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (minus_real_is_real application-judgement "real" reals nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (x_68 skolem-const-decl "real" interval_examples nil)
    (list2array def-decl "T" array2list "structures/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (epsilon const-decl "real" interval_examples nil)
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (LN_n const-decl "RealExpr" interval_expr_lnexp "interval_arith/")
    (SQ adt-constructor-decl "[RealExpr -> (sq?)]" IntervalExpr_adt
     "interval_arith/")
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]"
     IntervalExpr_adt "interval_arith/")
    (NEG adt-constructor-decl "[RealExpr -> (neg?)]" IntervalExpr_adt
     "interval_arith/")
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     IntervalExpr_adt "interval_arith/")
    (<= const-decl "bool" reals nil)
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (realorder? const-decl "bool" real_orders "reals/")
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (BINCLUDES adt-constructor-decl
     "[[RealExpr, Interval] -> (bincludes?)]" IntervalExpr_adt
     "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BIMPLIES adt-constructor-decl
     "[[BoolExpr, BoolExpr] -> (bimplies?)]" IntervalExpr_adt
     "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil))
   shostak))
 (ex4_ba 0
  (ex4_ba-1 nil 3600857801 ("" (interval) nil)
   ((listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (FALSE const-decl "bool" booleans nil)
    (vars_in_box formula-decl nil box "interval_arith/")
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box_rec def-decl
     "{b: bool | b = (FORALL (k: subrange(i, n - 1)): vs(k) ## nth(box, k - i))}"
     box "interval_arith/")
    (iar_69 skolem-const-decl "(bimplies?)" interval_examples nil)
    (ln_safe const-decl "real" interval_expr_lnexp "interval_arith/")
    (eval def-decl "real" interval_expr "interval_arith/")
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (x_70 skolem-const-decl "real" interval_examples nil)
    (list2array def-decl "T" array2list "structures/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (epsilon const-decl "real" interval_examples nil)
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (SQ adt-constructor-decl "[RealExpr -> (sq?)]" IntervalExpr_adt
     "interval_arith/")
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]"
     IntervalExpr_adt "interval_arith/")
    (LN_n const-decl "RealExpr" interval_expr_lnexp "interval_arith/")
    (ABS adt-constructor-decl "[RealExpr -> (abs?)]" IntervalExpr_adt
     "interval_arith/")
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     IntervalExpr_adt "interval_arith/")
    (<= const-decl "bool" reals nil)
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (realorder? const-decl "bool" real_orders "reals/")
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (BINCLUDES adt-constructor-decl
     "[[RealExpr, Interval] -> (bincludes?)]" IntervalExpr_adt
     "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BIMPLIES adt-constructor-decl
     "[[BoolExpr, BoolExpr] -> (bimplies?)]" IntervalExpr_adt
     "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil))
   shostak))
 (ex5_ba_TCC1 0
  (ex5_ba_TCC1-1 nil 3600857800 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil))
   nil))
 (ex5_ba 0
  (ex5_ba-1 nil 3600857801 ("" (interval) nil)
   ((listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (FALSE const-decl "bool" booleans nil)
    (vars_in_box formula-decl nil box "interval_arith/")
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box_rec def-decl
     "{b: bool | b = (FORALL (k: subrange(i, n - 1)): vs(k) ## nth(box, k - i))}"
     box "interval_arith/")
    (iar_71 skolem-const-decl "(bimplies?)" interval_examples nil)
    (ln_safe const-decl "real" interval_expr_lnexp "interval_arith/")
    (eval def-decl "real" interval_expr "interval_arith/")
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (x_72 skolem-const-decl "real" interval_examples nil)
    (list2array def-decl "T" array2list "structures/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (epsilon const-decl "real" interval_examples nil)
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (SQ adt-constructor-decl "[RealExpr -> (sq?)]" IntervalExpr_adt
     "interval_arith/")
    (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]"
     IntervalExpr_adt "interval_arith/")
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]"
     IntervalExpr_adt "interval_arith/")
    (LN_n const-decl "RealExpr" interval_expr_lnexp "interval_arith/")
    (ABS adt-constructor-decl "[RealExpr -> (abs?)]" IntervalExpr_adt
     "interval_arith/")
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     IntervalExpr_adt "interval_arith/")
    (<= const-decl "bool" reals nil)
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (realorder? const-decl "bool" real_orders "reals/")
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (BINCLUDES adt-constructor-decl
     "[[RealExpr, Interval] -> (bincludes?)]" IntervalExpr_adt
     "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BIMPLIES adt-constructor-decl
     "[[BoolExpr, BoolExpr] -> (bimplies?)]" IntervalExpr_adt
     "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil))
   shostak))
 (ex6_ba 0
  (ex6_ba-1 nil 3600857801 ("" (interval) nil)
   ((TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (FALSE const-decl "bool" booleans nil)
    (vars_in_box formula-decl nil box "interval_arith/")
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box_rec def-decl
     "{b: bool | b = (FORALL (k: subrange(i, n - 1)): vs(k) ## nth(box, k - i))}"
     box "interval_arith/")
    (iar_73 skolem-const-decl "(bimplies?)" interval_examples nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (exp_safe const-decl "posreal" interval_expr_lnexp
     "interval_arith/")
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (eval def-decl "real" interval_expr "interval_arith/")
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (x_74 skolem-const-decl "real" interval_examples nil)
    (list2array def-decl "T" array2list "structures/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (epsilon const-decl "real" interval_examples nil)
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (SQ adt-constructor-decl "[RealExpr -> (sq?)]" IntervalExpr_adt
     "interval_arith/")
    (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]"
     IntervalExpr_adt "interval_arith/")
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (EXP_n const-decl "RealExpr" interval_expr_lnexp "interval_arith/")
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     IntervalExpr_adt "interval_arith/")
    (<= const-decl "bool" reals nil)
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (realorder? const-decl "bool" real_orders "reals/")
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (BINCLUDES adt-constructor-decl
     "[[RealExpr, Interval] -> (bincludes?)]" IntervalExpr_adt
     "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BIMPLIES adt-constructor-decl
     "[[BoolExpr, BoolExpr] -> (bimplies?)]" IntervalExpr_adt
     "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/"))
   shostak))
 (ex7_ba 0
  (ex7_ba-1 nil 3600857801 ("" (interval) nil)
   ((listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (FALSE const-decl "bool" booleans nil)
    (vars_in_box formula-decl nil box "interval_arith/")
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box_rec def-decl
     "{b: bool | b = (FORALL (k: subrange(i, n - 1)): vs(k) ## nth(box, k - i))}"
     box "interval_arith/")
    (iar_75 skolem-const-decl "(bimplies?)" interval_examples nil)
    (exp_safe const-decl "posreal" interval_expr_lnexp
     "interval_arith/")
    (eval def-decl "real" interval_expr "interval_arith/")
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (x_76 skolem-const-decl "real" interval_examples nil)
    (list2array def-decl "T" array2list "structures/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (epsilon const-decl "real" interval_examples nil)
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]"
     IntervalExpr_adt "interval_arith/")
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]"
     IntervalExpr_adt "interval_arith/")
    (EXP_n const-decl "RealExpr" interval_expr_lnexp "interval_arith/")
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     IntervalExpr_adt "interval_arith/")
    (<= const-decl "bool" reals nil)
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (realorder? const-decl "bool" real_orders "reals/")
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (BINCLUDES adt-constructor-decl
     "[[RealExpr, Interval] -> (bincludes?)]" IntervalExpr_adt
     "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BIMPLIES adt-constructor-decl
     "[[BoolExpr, BoolExpr] -> (bimplies?)]" IntervalExpr_adt
     "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (>= const-decl "bool" reals nil))
   shostak))
 (Tunnel_3_IL 0
  (Tunnel_3_IL-1 nil 3600857801 ("" (interval) nil)
   ((posint_exp application-judgement "posint" exponentiation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (FALSE const-decl "bool" booleans nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (vars_in_box_rec def-decl
     "{b: bool | b = (FORALL (k: subrange(i, n - 1)): vs(k) ## nth(box, k - i))}"
     box "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box formula-decl nil box "interval_arith/")
    (iar_77 skolem-const-decl "(bimplies?)" interval_examples nil)
    (exp_safe const-decl "posreal" interval_expr_lnexp
     "interval_arith/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (eval def-decl "real" interval_expr "interval_arith/")
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (x_78 skolem-const-decl "{x: real | x ## [|0, 2.39 * 10 ^ (-9)|]}"
     interval_examples nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (list2array def-decl "T" array2list "structures/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (^ const-decl "real" exponentiation nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (EXP_n const-decl "RealExpr" interval_expr_lnexp "interval_arith/")
    (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]"
     IntervalExpr_adt "interval_arith/")
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     IntervalExpr_adt "interval_arith/")
    (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]"
     IntervalExpr_adt "interval_arith/")
    (<= const-decl "bool" reals nil)
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (realorder? const-decl "bool" real_orders "reals/")
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (BINCLUDES adt-constructor-decl
     "[[RealExpr, Interval] -> (bincludes?)]" IntervalExpr_adt
     "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BIMPLIES adt-constructor-decl
     "[[BoolExpr, BoolExpr] -> (bimplies?)]" IntervalExpr_adt
     "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/"))
   shostak))
 (Tunnel_3_IL_LU 0
  (Tunnel_3_IL_LU-1 nil 3600857801 ("" (interval) nil)
   ((posint_exp application-judgement "posint" exponentiation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (FALSE const-decl "bool" booleans nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (vars_in_box_rec def-decl
     "{b: bool | b = (FORALL (k: subrange(i, n - 1)): vs(k) ## nth(box, k - i))}"
     box "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box formula-decl nil box "interval_arith/")
    (iar_79 skolem-const-decl "(bimplies?)" interval_examples nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (exp_safe const-decl "posreal" interval_expr_lnexp
     "interval_arith/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (eval def-decl "real" interval_expr "interval_arith/")
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (x_80 skolem-const-decl "{x: real | x ## [|0, 8.17 * 10 ^ (-8)|]}"
     interval_examples nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (list2array def-decl "T" array2list "structures/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (EXP_n const-decl "RealExpr" interval_expr_lnexp "interval_arith/")
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]"
     IntervalExpr_adt "interval_arith/")
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     IntervalExpr_adt "interval_arith/")
    (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]"
     IntervalExpr_adt "interval_arith/")
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (BINCLUDES adt-constructor-decl
     "[[RealExpr, Interval] -> (bincludes?)]" IntervalExpr_adt
     "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BIMPLIES adt-constructor-decl
     "[[BoolExpr, BoolExpr] -> (bimplies?)]" IntervalExpr_adt
     "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/"))
   shostak))
 (max_sin_cos 0
  (max_sin_cos-1 nil 3708870709 ("" (interval) nil)
   ((TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (FALSE const-decl "bool" booleans nil)
    (vars_in_box formula-decl nil box "interval_arith/")
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box_rec def-decl
     "{b: bool | b = (FORALL (k: subrange(i, n - 1)): vs(k) ## nth(box, k - i))}"
     box "interval_arith/")
    (iar_81 skolem-const-decl "(bimplies?)" interval_examples nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (sqrt_is_safe formula-decl nil interval_expr_extra
     "interval_arith/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (cos_range application-judgement "real_abs_le1" sincos "trig/")
    (sin_range application-judgement "real_abs_le1" sincos "trig/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (eval def-decl "real" interval_expr "interval_arith/")
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (sqrt_pos application-judgement "posreal" sqrt "reals/")
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (x_82 skolem-const-decl "real" interval_examples nil)
    (list2array def-decl "T" array2list "structures/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (SQRT_n const-decl "RealExpr" interval_expr_extra
     "interval_arith/")
    (DIV adt-constructor-decl "[[RealExpr, RealExpr] -> (div?)]"
     IntervalExpr_adt "interval_arith/")
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     IntervalExpr_adt "interval_arith/")
    (COS_n const-decl "RealExpr" interval_expr_trig "interval_arith/")
    (SIN_n const-decl "RealExpr" interval_expr_trig "interval_arith/")
    (MAX const-decl "RealExpr" interval_expr_extra "interval_arith/")
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (realorder? const-decl "bool" real_orders "reals/")
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (BINCLUDES adt-constructor-decl
     "[[RealExpr, Interval] -> (bincludes?)]" IntervalExpr_adt
     "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BIMPLIES adt-constructor-decl
     "[[BoolExpr, BoolExpr] -> (bimplies?)]" IntervalExpr_adt
     "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/"))
   shostak))
 (min_sin_cos 0
  (min_sin_cos-1 nil 3708870709 ("" (interval) nil)
   ((TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (listn_0 name-judgement "listn[real](0)" simple_bandb
     "interval_arith/")
    (Maybe type-decl nil Maybe "structures/")
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (IntervalOutput type-eq-decl nil gbandb_boolexpr "interval_arith/")
    (Box type-eq-decl nil box "interval_arith/")
    (ProperBox? const-decl "bool" box "interval_arith/")
    (ProperBox type-eq-decl nil box "interval_arith/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (stack type-eq-decl nil stack "structures/")
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (Output type-eq-decl nil branch_and_bound "structures/")
    (interval const-decl "Output" interval_bandb "interval_arith/")
    (alt_max const-decl "DirVar" gbandb_boolexpr "interval_arith/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (FALSE const-decl "bool" booleans nil)
    (vars_in_box formula-decl nil box "interval_arith/")
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box_rec def-decl
     "{b: bool | b = (FORALL (k: subrange(i, n - 1)): vs(k) ## nth(box, k - i))}"
     box "interval_arith/")
    (iar_83 skolem-const-decl "(bimplies?)" interval_examples nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (sqrt_is_safe formula-decl nil interval_expr_extra
     "interval_arith/")
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (cos_range application-judgement "real_abs_le1" sincos "trig/")
    (sin_range application-judgement "real_abs_le1" sincos "trig/")
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (eval def-decl "real" interval_expr "interval_arith/")
    (beval def-decl "bool" interval_bexpr "interval_arith/")
    (sqrt_pos application-judgement "posreal" sqrt "reals/")
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (x_84 skolem-const-decl "real" interval_examples nil)
    (list2array def-decl "T" array2list "structures/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (sound? const-decl "bool" interval_bandb "interval_arith/")
    (interval_soundness formula-decl nil interval_bandb
     "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (r2E const-decl "RealExpr" interval_expr "interval_arith/")
    (SQRT_n const-decl "RealExpr" interval_expr_extra
     "interval_arith/")
    (DIV adt-constructor-decl "[[RealExpr, RealExpr] -> (div?)]"
     IntervalExpr_adt "interval_arith/")
    (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]"
     IntervalExpr_adt "interval_arith/")
    (COS_n const-decl "RealExpr" interval_expr_trig "interval_arith/")
    (SIN_n const-decl "RealExpr" interval_expr_trig "interval_arith/")
    (MIN const-decl "RealExpr" interval_expr_extra "interval_arith/")
    (<= const-decl "bool" reals nil)
    (BREL adt-constructor-decl
     "[[RealOrder, RealExpr, RealExpr] -> (brel?)]" IntervalExpr_adt
     "interval_arith/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (realorder? const-decl "bool" real_orders "reals/")
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (BINCLUDES adt-constructor-decl
     "[[RealExpr, Interval] -> (bincludes?)]" IntervalExpr_adt
     "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (BIMPLIES adt-constructor-decl
     "[[BoolExpr, BoolExpr] -> (bimplies?)]" IntervalExpr_adt
     "interval_arith/")
    (BoolExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bite? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (brel? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bor? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (band? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/"))
   shostak)))

