(sturm_examples
 (example_1_TCC1 0
  (example_1_TCC1-1 nil 3703615613 ("" (subtype-tcc) nil) nil nil))
 (example_1_TCC2 0
  (example_1_TCC2-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_1_TCC3 0
  (example_1_TCC3-1 nil 3703615613 ("" (subtype-tcc) nil) nil nil))
 (example_1 0
  (example_1-1 nil 3703615632 ("" (sturm) nil)
   ((minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (expt_x1 formula-decl nil exponentiation nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (polylist_pow formula-decl nil polylist "Sturm/")
    (polylist_sum formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_prod formula-decl nil polylist "Sturm/")
    (contains? const-decl "bool" RealInt "reals/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__179 skolem-const-decl "Polylist" sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pprod const-decl "Polylist" polylist "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (polylist const-decl "real" polylist "Sturm/")
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (ppow def-decl "Polylist" polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (>= const-decl "bool" reals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   shostak))
 (example_2 0
  (example_2-1 nil 3703615632 ("" (sturm) nil)
   ((minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (polylist_prod formula-decl nil polylist "Sturm/")
    (polylist_pow formula-decl nil polylist "Sturm/")
    (polylist_sum formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (contains? const-decl "bool" RealInt "reals/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__182 skolem-const-decl "Polylist" sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pprod const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (ppow def-decl "Polylist" polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (length def-decl "nat" list_props nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (>= const-decl "bool" reals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   shostak))
 (example_3_TCC1 0
  (example_3_TCC1-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_3_TCC2 0
  (example_3_TCC2-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_3_TCC3 0
  (example_3_TCC3-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_3_TCC4 0
  (example_3_TCC4-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_3_TCC5 0
  (example_3_TCC5-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_3_TCC6 0
  (example_3_TCC6-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_3_TCC7 0
  (example_3_TCC7-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_3_TCC8 0
  (example_3_TCC8-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_3_TCC9 0
  (example_3_TCC9-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_3_TCC10 0
  (example_3_TCC10-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_3_TCC11 0
  (example_3_TCC11-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_3_TCC12 0
  (example_3_TCC12-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_3_TCC13 0
  (example_3_TCC13-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_3_TCC14 0
  (example_3_TCC14-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil))
   nil))
 (example_3 0
  (example_3-1 nil 3703615632 ("" (sturm) nil)
   ((minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (polylist_pow formula-decl nil polylist "Sturm/")
    (polylist_sum formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__185 skolem-const-decl "Polylist" sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (ppow def-decl "Polylist" polylist "Sturm/")
    (polylist const-decl "real" polylist "Sturm/")
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (length def-decl "nat" list_props nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (example_4_TCC1 0
  (example_4_TCC1-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_4 0
  (example_4-1 nil 3703615632 ("" (sturm) nil)
   ((minus_real_is_real application-judgement "real" reals nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (polylist_neg formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__188 skolem-const-decl "Polylist" sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pneg const-decl "Polylist" polylist "Sturm/")
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (example_5 0
  (example_5-1 nil 3703615632 ("" (sturm) nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__191 skolem-const-decl "Polylist" sturm_examples nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (example_6_TCC1 0
  (example_6_TCC1-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_6 0
  (example_6-1 nil 3703615632 ("" (sturm) nil)
   ((minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (expt_x1 formula-decl nil exponentiation nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_sum formula-decl nil polylist "Sturm/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__194 skolem-const-decl "{pql: Polylist |
         FORALL (x):
           polylist(pql)(x) =
            polylist(pconst(1))(x) +
             polylist(pminus(pmonom(1, 2), pmonom(2, 1)))(x)}"
     sturm_examples nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (polylist const-decl "real" polylist "Sturm/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   shostak))
 (example_7 0
  (example_7-1 nil 3703615632 ("" (sturm) nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (<= const-decl "bool" reals nil)
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (expt_x1 formula-decl nil exponentiation nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_prod formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__197 skolem-const-decl "Polylist" sturm_examples nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (pprod const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (example_8 0
  (example_8-1 nil 3703615632 ("" (sturm) nil)
   ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__200 skolem-const-decl "{pl: Polylist |
         length(pl) = 6 AND (FORALL (x: real): polylist(pl)(x) = 1 * x ^ 5)}"
     sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (example_9_TCC1 0
  (example_9_TCC1-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_9_TCC2 0
  (example_9_TCC2-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_9 0
  (example_9-1 nil 3703615632 ("" (sturm) nil)
   ((minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_sum formula-decl nil polylist "Sturm/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__203 skolem-const-decl "{pql: Polylist |
         FORALL (x):
           polylist(pql)(x) =
            polylist(pconst(1))(x) +
             polylist(pminus(pmonom(1, 120), pmonom(2, 60)))(x)}"
     sturm_examples nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (polylist const-decl "real" polylist "Sturm/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   shostak))
 (example_sos_TCC1 0
  (example_sos_TCC1-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_sos_TCC2 0
  (example_sos_TCC2-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_sos 0
  (example_sos-1 nil 3703615632 ("" (sturm) nil)
   ((posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nat_exp application-judgement "nat" exponentiation nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (polylist_prod formula-decl nil polylist "Sturm/")
    (polylist_pow formula-decl nil polylist "Sturm/")
    (polylist_sum formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_div formula-decl nil polylist "Sturm/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__206 skolem-const-decl "Polylist" sturm_examples nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (nzrat nonempty-type-eq-decl nil rationals nil)
    (pdiv const-decl "Polylist" polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (polylist const-decl "real" polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (ppow def-decl "Polylist" polylist "Sturm/")
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (pprod const-decl "Polylist" polylist "Sturm/")
    (>= const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil))
   shostak))
 (example_10 0
  (example_10-1 nil 3703615632 ("" (sturm) nil)
   ((minus_odd_is_odd application-judgement "odd_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contains? const-decl "bool" RealInt "reals/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__209 skolem-const-decl "Polylist" sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (example_11 0
  (example_11-1 nil 3703615632 ("" (sturm) nil)
   ((minus_odd_is_odd application-judgement "odd_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contains? const-decl "bool" RealInt "reals/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__212 skolem-const-decl "Polylist" sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (example_12 0
  (example_12-1 nil 3703615633 ("" (sturm) nil)
   ((minus_real_is_real application-judgement "real" reals nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (polylist_neg formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__215 skolem-const-decl "Polylist" sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pneg const-decl "Polylist" polylist "Sturm/")
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (example_13 0
  (example_13-1 nil 3703615633 ("" (sturm) nil)
   ((id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (<= const-decl "bool" reals nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (expt_x1 formula-decl nil exponentiation nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_sum formula-decl nil polylist "Sturm/")
    (polylist_prod formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (abs_le formula-decl nil abs_lems "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__218 skolem-const-decl "Polylist" sturm_examples nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pprod const-decl "Polylist" polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (example_14_TCC1 0
  (example_14_TCC1-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_14_TCC2 0
  (example_14_TCC2-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_14_TCC3 0
  (example_14_TCC3-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_14_TCC4 0
  (example_14_TCC4-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_14 0
  (example_14-1 nil 3703615633 ("" (sturm) nil)
   ((minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (polylist_prod formula-decl nil polylist "Sturm/")
    (polylist_pow formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__221 skolem-const-decl "Polylist" sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pprod const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (ppow def-decl "Polylist" polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   shostak))
 (example_15 0
  (example_15-1 nil 3703615633 ("" (sturm) nil)
   ((minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (polylist_sum formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__224 skolem-const-decl "{pql: Polylist |
         FORALL (x):
           polylist(pql)(x) =
            polylist(pconst(1))(x) +
             polylist(pminus(pmonom(1, 120), pmonom(2, 60)))(x)}"
     sturm_examples nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (polylist const-decl "real" polylist "Sturm/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   shostak))
 (example_16 0
  (example_16-1 nil 3703615633 ("" (sturm) nil)
   ((minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_sum formula-decl nil polylist "Sturm/")
    (contains? const-decl "bool" RealInt "reals/")
    (FALSE const-decl "bool" booleans nil)
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__227 skolem-const-decl "{pql: Polylist |
         FORALL (x):
           polylist(pql)(x) =
            polylist(pconst(1))(x) +
             polylist(pminus(pmonom(1, 120), pmonom(2, 60)))(x)}"
     sturm_examples nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (polylist const-decl "real" polylist "Sturm/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   shostak))
 (example_17 0
  (example_17-1 nil 3703615633 ("" (sturm) nil)
   ((nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_sum formula-decl nil polylist "Sturm/")
    (contains? const-decl "bool" RealInt "reals/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__230 skolem-const-decl "{pql: Polylist |
         FORALL (x):
           polylist(pql)(x) =
            polylist(pconst(1/9))(x) +
             polylist(pminus(pmonom(1, 120), pmonom(2/3, 60)))(x)}"
     sturm_examples nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (polylist const-decl "real" polylist "Sturm/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (pconst const-decl "Polylist" polylist "Sturm/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (open adt-constructor-decl "[real -> (open?)]" RealInt "reals/")
    (open? adt-recognizer-decl "[RealInf -> boolean]" RealInt "reals/")
    (oo adt-constructor-decl "(inf?)" RealInt "reals/")
    (- const-decl "nInf" RealInt "reals/")
    (nInf type-eq-decl nil RealInt "reals/")
    (ninf? adt-recognizer-decl "[RealInf -> boolean]" RealInt "reals/")
    (Inf type-eq-decl nil RealInt "reals/")
    (inf? adt-recognizer-decl "[RealInf -> boolean]" RealInt "reals/")
    ([\|\|] const-decl "RealInt" RealInt "reals/")
    (RealInf type-decl nil RealInt "reals/")
    (|##| const-decl "bool" RealInt "reals/")
    (RealInt type-eq-decl nil RealInt "reals/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   shostak))
 (example_18 0
  (example_18-1 nil 3703615633 ("" (sturm) nil)
   ((nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (polylist_sum formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (contains? const-decl "bool" RealInt "reals/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__233 skolem-const-decl "{pql: Polylist |
         FORALL (x):
           polylist(pql)(x) =
            polylist(pconst(1/9))(x) +
             polylist(pminus(pmonom(1, 120), pmonom(2/3, 60)))(x)}"
     sturm_examples nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (polylist const-decl "real" polylist "Sturm/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (pconst const-decl "Polylist" polylist "Sturm/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (open adt-constructor-decl "[real -> (open?)]" RealInt "reals/")
    (open? adt-recognizer-decl "[RealInf -> boolean]" RealInt "reals/")
    (oo adt-constructor-decl "(inf?)" RealInt "reals/")
    (- const-decl "nInf" RealInt "reals/")
    (nInf type-eq-decl nil RealInt "reals/")
    (ninf? adt-recognizer-decl "[RealInf -> boolean]" RealInt "reals/")
    (Inf type-eq-decl nil RealInt "reals/")
    (inf? adt-recognizer-decl "[RealInf -> boolean]" RealInt "reals/")
    ([\|\|] const-decl "RealInt" RealInt "reals/")
    (RealInf type-decl nil RealInt "reals/")
    (|##| const-decl "bool" RealInt "reals/")
    (RealInt type-eq-decl nil RealInt "reals/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   shostak))
 (example_19 0
  (example_19-1 nil 3703615633 ("" (sturm) nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (<= const-decl "bool" reals nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (expt_x1 formula-decl nil exponentiation nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (polylist_sum formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (contains? const-decl "bool" RealInt "reals/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__236 skolem-const-decl "Polylist" sturm_examples nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (polylist const-decl "real" polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil))
   shostak))
 (example_20 0
  (example_20-1 nil 3703615633 ("" (sturm) nil)
   ((minus_odd_is_odd application-judgement "odd_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (<= const-decl "bool" reals nil)
    (FALSE const-decl "bool" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (polylist_neg formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__239 skolem-const-decl "Polylist" sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pneg const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (oo adt-constructor-decl "(inf?)" RealInt "reals/")
    (inf? adt-recognizer-decl "[RealInf -> boolean]" RealInt "reals/")
    ([\|\|] const-decl "RealInt" RealInt "reals/")
    (RealInf type-decl nil RealInt "reals/")
    (|##| const-decl "bool" RealInt "reals/")
    (RealInt type-eq-decl nil RealInt "reals/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (example_21 0
  (example_21-1 nil 3703615633 ("" (sturm) nil)
   ((minus_real_is_real application-judgement "real" reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_neg formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__242 skolem-const-decl "Polylist" sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (pneg const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (oo adt-constructor-decl "(inf?)" RealInt "reals/")
    (inf? adt-recognizer-decl "[RealInf -> boolean]" RealInt "reals/")
    (open adt-constructor-decl "[real -> (open?)]" RealInt "reals/")
    (open? adt-recognizer-decl "[RealInf -> boolean]" RealInt "reals/")
    ([\|\|] const-decl "RealInt" RealInt "reals/")
    (RealInf type-decl nil RealInt "reals/")
    (|##| const-decl "bool" RealInt "reals/")
    (RealInt type-eq-decl nil RealInt "reals/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (example_22 0
  (example_22-1 nil 3703615633 ("" (sturm) nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (<= const-decl "bool" reals nil)
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (RealInf type-decl nil RealInt "reals/")
    ([\|\|] const-decl "RealInt" RealInt "reals/")
    (inf? adt-recognizer-decl "[RealInf -> boolean]" RealInt "reals/")
    (Inf type-eq-decl nil RealInt "reals/")
    (ninf? adt-recognizer-decl "[RealInf -> boolean]" RealInt "reals/")
    (nInf type-eq-decl nil RealInt "reals/")
    (- const-decl "nInf" RealInt "reals/")
    (oo adt-constructor-decl "(inf?)" RealInt "reals/")
    (expt_x1 formula-decl nil exponentiation nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_prod formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (contains? const-decl "bool" RealInt "reals/")
    (|##| const-decl "bool" RealInt "reals/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__245 skolem-const-decl "Polylist" sturm_examples nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (pprod const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (n_example_1 0
  (n_example_1-1 nil 3703615633 ("" (sturm -1) nil)
   ((minus_odd_is_odd application-judgement "odd_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contains? const-decl "bool" RealInt "reals/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__248 skolem-const-decl "Polylist" sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (n_example_2 0
  (n_example_2-1 nil 3703615633 ("" (sturm -1) nil)
   ((minus_odd_is_odd application-judgement "odd_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (contains? const-decl "bool" RealInt "reals/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__251 skolem-const-decl "Polylist" sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (n_example_3 0
  (n_example_3-1 nil 3703615633 ("" (sturm -1) nil)
   ((minus_real_is_real application-judgement "real" reals nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (polylist_neg formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__254 skolem-const-decl "Polylist" sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pneg const-decl "Polylist" polylist "Sturm/")
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (n_example_4 0
  (n_example_4-1 nil 3703615633 ("" (sturm -1) nil)
   ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__257 skolem-const-decl "{pl: Polylist |
         length(pl) = 6 AND (FORALL (x: real): polylist(pl)(x) = 1 * x ^ 5)}"
     sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (n_example_5 0
  (n_example_5-1 nil 3703615633 ("" (sturm -1) nil)
   ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__260 skolem-const-decl "{pl: Polylist |
         length(pl) = 4 AND (FORALL (x: real): polylist(pl)(x) = 1 * x ^ 3)}"
     sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (mono_example_1_TCC1 0
  (mono_example_1_TCC1-1 nil 3703615613 ("" (subtype-tcc) nil) nil
   nil))
 (mono_example_1 0
  (mono_example_1-1 nil 3703615633 ("" (mono-poly) nil)
   ((id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (mono_def formula-decl nil compute_sturm "Sturm/")
    (mono const-decl "bool" compute_sturm "Sturm/")
    (lp__267 skolem-const-decl "[nat -> rat]" sturm_examples nil)
    (pl__265 skolem-const-decl "(cons?[numfield])" sturm_examples nil)
    (polylist_sum formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_prod formula-decl nil polylist "Sturm/")
    (polylist_pow formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (p1__263 skolem-const-decl "Polylist" sturm_examples nil)
    (p2__264 skolem-const-decl "{pql: Polylist |
         FORALL (x):
           polylist(pql)(x) =
            polylist(pconst(1/16))(x) +
             polylist(pminus(pprod(pmonom(1, 1), pmonom(1, 1)),
                             pmonom(1/2, 1)))
                     (x)}" sturm_examples nil)
    (polylist_eval formula-decl nil polylist "Sturm/")
    (xval__266 skolem-const-decl "[# bounded_above: bool,
   bounded_below: bool,
   closed_above: bool,
   closed_below: bool,
   lb: posint,
   ub: posint #]" sturm_examples nil)
    (contains? const-decl "bool" RealInt "reals/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (relvar__270 skolem-const-decl "RealOrder" sturm_examples nil)
    (rel__269 skolem-const-decl "RealOrder" sturm_examples nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (deg__268 skolem-const-decl "int" sturm_examples nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<= const-decl "bool" reals nil)
    (realorder? const-decl "bool" real_orders "reals/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list2array def-decl "T" array2list "structures/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (FALSE const-decl "bool" booleans nil)
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (pprod const-decl "Polylist" polylist "Sturm/")
    (TRUE const-decl "bool" booleans nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (pconst const-decl "Polylist" polylist "Sturm/")
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (length def-decl "nat" list_props nil)
    (pminus const-decl "Polylist" polylist "Sturm/")
    (ppow def-decl "Polylist" polylist "Sturm/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil))
   shostak))
 (mono_example_2_TCC1 0
  (mono_example_2_TCC1-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (mono_example_2 0
  (mono_example_2-1 nil 3703615633 ("" (mono-poly) nil)
   ((id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (mono_def formula-decl nil compute_sturm "Sturm/")
    (mono const-decl "bool" compute_sturm "Sturm/")
    (contains? const-decl "bool" RealInt "reals/")
    (xval__276 skolem-const-decl "[# bounded_above: bool,
   bounded_below: bool,
   closed_above: bool,
   closed_below: bool,
   lb: odd_int,
   ub: posint #]" sturm_examples nil)
    (polylist_eval formula-decl nil polylist "Sturm/")
    (p2__274 skolem-const-decl "{pl: Polylist |
         length(pl) = 6 AND (FORALL (x: real): polylist(pl)(x) = 1 * x ^ 5)}"
     sturm_examples nil)
    (p1__273 skolem-const-decl "{pl: Polylist |
         length(pl) = 6 AND (FORALL (x: real): polylist(pl)(x) = 1 * x ^ 5)}"
     sturm_examples nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (pl__275 skolem-const-decl "(cons?)" sturm_examples nil)
    (lp__277 skolem-const-decl "[nat -> rat]" sturm_examples nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (relvar__280 skolem-const-decl "RealOrder" sturm_examples nil)
    (rel__279 skolem-const-decl "[[real, real] -> boolean]"
     sturm_examples nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (deg__278 skolem-const-decl "int" sturm_examples nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (realorder? const-decl "bool" real_orders "reals/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list2array def-decl "T" array2list "structures/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (odd? const-decl "bool" integers nil)
    (odd_int nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (FALSE const-decl "bool" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (length def-decl "nat" list_props nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (mono_example_3_TCC1 0
  (mono_example_3_TCC1-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (mono_example_3_TCC2 0
  (mono_example_3_TCC2-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (mono_example_3 0
  (mono_example_3-1 nil 3703615633 ("" (mono-poly) nil)
   ((id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (mono_def formula-decl nil compute_sturm "Sturm/")
    (mono const-decl "bool" compute_sturm "Sturm/")
    (lp__287 skolem-const-decl "[nat -> rat]" sturm_examples nil)
    (pl__285 skolem-const-decl "(cons?[numfield])" sturm_examples nil)
    (polylist_sum formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_prod formula-decl nil polylist "Sturm/")
    (polylist_div formula-decl nil polylist "Sturm/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (polylist_const formula-decl nil polylist "Sturm/")
    (p1__283 skolem-const-decl "{pql: Polylist |
         FORALL (x):
           polylist(pql)(x) =
            polylist(pdiv(pmonom(1, 1), 5))(x) +
             polylist(pminus(pmonom(1, 5), pmonom(1, 3)))(x)}"
     sturm_examples nil)
    (p2__284 skolem-const-decl "Polylist" sturm_examples nil)
    (polylist_eval formula-decl nil polylist "Sturm/")
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (xval__286 skolem-const-decl "[# bounded_above: bool,
   bounded_below: bool,
   closed_above: bool,
   closed_below: bool,
   lb: posrat,
   ub: posrat #]" sturm_examples nil)
    (contains? const-decl "bool" RealInt "reals/")
    (RealInt type-eq-decl nil RealInt "reals/")
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (relvar__290 skolem-const-decl "RealOrder" sturm_examples nil)
    (rel__289 skolem-const-decl "RealOrder" sturm_examples nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (deg__288 skolem-const-decl "int" sturm_examples nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (realorder? const-decl "bool" real_orders "reals/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list2array def-decl "T" array2list "structures/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (nonneg_rat nonempty-type-eq-decl nil rationals nil)
    (> const-decl "bool" reals nil)
    (posrat nonempty-type-eq-decl nil rationals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (pconst const-decl "Polylist" polylist "Sturm/")
    (pprod const-decl "Polylist" polylist "Sturm/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (TRUE const-decl "bool" booleans nil)
    (pdiv const-decl "Polylist" polylist "Sturm/")
    (nzrat nonempty-type-eq-decl nil rationals nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (pminus const-decl "Polylist" polylist "Sturm/")
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (mono_example_4_TCC1 0
  (mono_example_4_TCC1-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (mono_example_4 0
  (mono_example_4-1 nil 3703615633 ("" (mono-poly) nil)
   ((id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (mono_def formula-decl nil compute_sturm "Sturm/")
    (< const-decl "bool" reals nil)
    (mono const-decl "bool" compute_sturm "Sturm/")
    (contains? const-decl "bool" RealInt "reals/")
    (xval__296 skolem-const-decl "[# bounded_above: bool,
   bounded_below: bool,
   closed_above: bool,
   closed_below: bool,
   lb: odd_int,
   ub: posint #]" sturm_examples nil)
    (polylist_eval formula-decl nil polylist "Sturm/")
    (p2__294 skolem-const-decl "{pl: Polylist |
         length(pl) = 4 AND (FORALL (x: real): polylist(pl)(x) = 1 * x ^ 3)}"
     sturm_examples nil)
    (p1__293 skolem-const-decl "{pl: Polylist |
         length(pl) = 4 AND (FORALL (x: real): polylist(pl)(x) = 1 * x ^ 3)}"
     sturm_examples nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (pl__295 skolem-const-decl "(cons?)" sturm_examples nil)
    (lp__297 skolem-const-decl "[nat -> rat]" sturm_examples nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (relvar__300 skolem-const-decl "[[real, real] -> boolean]"
     sturm_examples nil)
    (rel__299 skolem-const-decl "[[real, real] -> boolean]"
     sturm_examples nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (deg__298 skolem-const-decl "int" sturm_examples nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list2array def-decl "T" array2list "structures/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (odd? const-decl "bool" integers nil)
    (odd_int nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (FALSE const-decl "bool" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (length def-decl "nat" list_props nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (mono_example_5 0
  (mono_example_5-1 nil 3703615633 ("" (mono-poly) nil)
   ((id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (mono_def formula-decl nil compute_sturm "Sturm/")
    (mono const-decl "bool" compute_sturm "Sturm/")
    (contains? const-decl "bool" RealInt "reals/")
    (lp__307 skolem-const-decl "[nat -> rat]" sturm_examples nil)
    (xval__306 skolem-const-decl "[# bounded_above: bool,
   bounded_below: bool,
   closed_above: bool,
   closed_below: bool,
   lb: odd_int,
   ub: posint #]" sturm_examples nil)
    (polylist_eval formula-decl nil polylist "Sturm/")
    (p2__304 skolem-const-decl "Polylist" sturm_examples nil)
    (p1__303 skolem-const-decl "{pl: Polylist |
         length(pl) = 3 AND (FORALL (x: real): polylist(pl)(x) = 1 * x ^ 2)}"
     sturm_examples nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (polylist_sq formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (pl__305 skolem-const-decl "(cons?)" sturm_examples nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (relvar__310 skolem-const-decl "RealOrder" sturm_examples nil)
    (rel__309 skolem-const-decl "RealOrder" sturm_examples nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (deg__308 skolem-const-decl "int" sturm_examples nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (realorder? const-decl "bool" real_orders "reals/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list2array def-decl "T" array2list "structures/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (odd? const-decl "bool" integers nil)
    (odd_int nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (FALSE const-decl "bool" booleans nil)
    (psq const-decl "Polylist" polylist "Sturm/")
    (TRUE const-decl "bool" booleans nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (length def-decl "nat" list_props nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (mono_example_6_TCC1 0
  (mono_example_6_TCC1-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (mono_example_6 0
  (mono_example_6-1 nil 3703615633 ("" (mono-poly) nil)
   ((id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (mono_def formula-decl nil compute_sturm "Sturm/")
    (< const-decl "bool" reals nil)
    (mono const-decl "bool" compute_sturm "Sturm/")
    (contains? const-decl "bool" RealInt "reals/")
    (lp__317 skolem-const-decl "[nat -> rat]" sturm_examples nil)
    (xval__316 skolem-const-decl "[# bounded_above: bool,
   bounded_below: bool,
   closed_above: bool,
   closed_below: bool,
   lb: odd_int,
   ub: naturalnumber #]" sturm_examples nil)
    (polylist_eval formula-decl nil polylist "Sturm/")
    (p2__314 skolem-const-decl "{pl: Polylist |
         length(pl) = 5 AND (FORALL (x: real): polylist(pl)(x) = 1 * x ^ 4)}"
     sturm_examples nil)
    (p1__313 skolem-const-decl "{pl: Polylist |
         length(pl) = 5 AND (FORALL (x: real): polylist(pl)(x) = 1 * x ^ 4)}"
     sturm_examples nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (x_322 skolem-const-decl "real" sturm_examples nil)
    (pl__315 skolem-const-decl "(cons?)" sturm_examples nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (relvar__320 skolem-const-decl "RealOrder" sturm_examples nil)
    (rel__319 skolem-const-decl "RealOrder" sturm_examples nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (deg__318 skolem-const-decl "int" sturm_examples nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (realorder? const-decl "bool" real_orders "reals/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list2array def-decl "T" array2list "structures/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (odd? const-decl "bool" integers nil)
    (odd_int nonempty-type-eq-decl nil integers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (FALSE const-decl "bool" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (length def-decl "nat" list_props nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (legendre_TCC1 0
  (legendre_TCC1-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (legendre_TCC2 0
  (legendre_TCC2-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (legendre_TCC3 0
  (legendre_TCC3-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (legendre 0
  (legendre-1 nil 3703615633 ("" (sturm) nil)
   ((nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (abs_lt formula-decl nil abs_lems "reals/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (polylist_sum formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (contains? const-decl "bool" RealInt "reals/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__323 skolem-const-decl "Polylist" sturm_examples nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (polylist const-decl "real" polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (legendre3_TCC1 0
  (legendre3_TCC1-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil))
   nil))
 (legendre3 0
  (legendre3-1 nil 3703615633 ("" (sturm) nil)
   ((nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (abs_lt formula-decl nil abs_lems "reals/")
    (polylist_pow formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (polylist_sum formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (contains? const-decl "bool" RealInt "reals/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__326 skolem-const-decl "Polylist" sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (ppow def-decl "Polylist" polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (polylist const-decl "real" polylist "Sturm/")
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (length def-decl "nat" list_props nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (^ const-decl "real" exponentiation nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   shostak))
 (Turan_9_TCC1 0
  (Turan_9_TCC1-1 nil 3703615613 ("" (subtype-tcc) nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil))
   nil))
 (Turan_9 0
  (Turan_9-1 nil 3703615633 ("" (sturm) nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (FALSE const-decl "bool" booleans nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (contains? const-decl "bool" RealInt "reals/")
    (expt_x1 formula-decl nil exponentiation nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_sum formula-decl nil polylist "Sturm/")
    (polylist_pow formula-decl nil polylist "Sturm/")
    (polylist_div formula-decl nil polylist "Sturm/")
    (polylist_prod formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (abs_lt formula-decl nil abs_lems "reals/")
    (sturm const-decl "bool" poly_strategy "Sturm/")
    (stu__329 skolem-const-decl "Polylist" sturm_examples nil)
    (sturm_def formula-decl nil poly_strategy "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (deg const-decl "{d: below(length(pl)) |
         (d > 0 IFF
           (EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0))
          AND
          (d > 0 IMPLIES
            (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
           AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist "Sturm/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (ppow def-decl "Polylist" polylist "Sturm/")
    (nzrat nonempty-type-eq-decl nil rationals nil)
    (pdiv const-decl "Polylist" polylist "Sturm/")
    (polylist const-decl "real" polylist "Sturm/")
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (length def-decl "nat" list_props nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pprod const-decl "Polylist" polylist "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (Legendre_10_TCC1 0
  (Legendre_10_TCC1-1 nil 3703615613 ("" (subtype-tcc) nil)
   (([\|\|] const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (/= const-decl "boolean" notequal nil))
   nil))
 (Legendre_10_TCC2 0
  (Legendre_10_TCC2-1 nil 3703615613 ("" (subtype-tcc) nil)
   (([\|\|] const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (/= const-decl "boolean" notequal nil))
   nil))
 (Legendre_10_TCC3 0
  (Legendre_10_TCC3-1 nil 3703615613 ("" (subtype-tcc) nil)
   (([\|\|] const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (/= const-decl "boolean" notequal nil))
   nil))
 (Legendre_10_TCC4 0
  (Legendre_10_TCC4-1 nil 3703615613 ("" (subtype-tcc) nil)
   (([\|\|] const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (/= const-decl "boolean" notequal nil))
   nil))
 (Legendre_10_TCC5 0
  (Legendre_10_TCC5-1 nil 3703615613 ("" (subtype-tcc) nil)
   (([\|\|] const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (/= const-decl "boolean" notequal nil))
   nil))
 (Legendre_10 0
  (Legendre_10-1 nil 3703615633 ("" (mono-poly) nil)
   ((id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (mono_def formula-decl nil compute_sturm "Sturm/")
    (mono const-decl "bool" compute_sturm "Sturm/")
    (contains? const-decl "bool" RealInt "reals/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (xval__335 skolem-const-decl "[# bounded_above: bool,
   bounded_below: bool,
   closed_above: bool,
   closed_below: bool,
   lb: nzrat,
   ub: nzrat #]" sturm_examples nil)
    (lp__336 skolem-const-decl "[nat -> rat]" sturm_examples nil)
    (pl__334 skolem-const-decl "(cons?[numfield])" sturm_examples nil)
    (polylist_div formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_sum formula-decl nil polylist "Sturm/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (p1__332 skolem-const-decl "Polylist" sturm_examples nil)
    (p2__333 skolem-const-decl "Polylist" sturm_examples nil)
    (polylist_eval formula-decl nil polylist "Sturm/")
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (RealInt type-eq-decl nil RealInt "reals/")
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (relvar__339 skolem-const-decl "RealOrder" sturm_examples nil)
    (rel__338 skolem-const-decl "RealOrder" sturm_examples nil)
    (SturmRel? const-decl "bool" compute_sturm "Sturm/")
    (deg__337 skolem-const-decl "int" sturm_examples nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (> const-decl "bool" reals nil)
    (realorder? const-decl "bool" real_orders "reals/")
    (RealOrder type-eq-decl nil real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (< const-decl "bool" reals nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list2array def-decl "T" array2list "structures/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (TRUE const-decl "bool" booleans nil)
    (pconst const-decl "Polylist" polylist "Sturm/")
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (pdiv const-decl "Polylist" polylist "Sturm/")
    (nzrat nonempty-type-eq-decl nil rationals nil)
    (/= const-decl "boolean" notequal nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil))
   shostak)))

