affine_pow: THEORY
BEGIN
  IMPORTING affine
  %----------------------------------------------------------------------------%
  % Power (on variables)
  %----------------------------------------------------------------------------%
  IMPORTING reals@binomial

  power_Epsilon_judg: JUDGEMENT
  FORALL(e: Epsilon, n: nat): e^n HAS_TYPE Epsilon


  pow_var_pd(cv: nzBaseType, newidx: nat, pds_bt: nzBaseType, n: above(1), k: subrange(2,n))
  : RECURSIVE {pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= newidx+(k-2)}
  = IF k = n THEN cons_ol((newidx+(k-2),pds_bt^k), empty_ErrorTerms)
    ELSE cons_ol( (newidx+(k-2), C(n,k) * cv^(n-k) * pds_bt^k)
    	 	, pow_var_pd(cv,newidx,pds_bt,n,k+1)) ENDIF
  MEASURE n - k

  pow_var_ac(Xa:(represents_var?), n:nat, (newidx: nat | newidx >= next_idx(pd(Xa)))): AffineCombination
  = IF n=0 THEN {| 1, empty_ErrorTerms |}
    ELSE {| cv(Xa)^n ,
       	    IF length(pd(Xa)) = 0 THEN empty_ErrorTerms
	    ELSIF cv(Xa) = 0 THEN IF n=1 THEN pd(Xa) ELSE
	    	  	     	  cons_ol((newidx+n-2, nth(pd(Xa),0)`2^n), empty_ErrorTerms) ENDIF
       	    ELSE cons_ol( (nth(pd(Xa),0)`1, n * cv(Xa)^(n-1) * nth(pd(Xa),0)`2)
	    	 	, IF n>1 THEN pow_var_pd(cv(Xa), newidx, nth(pd(Xa),0)`2, n, 2)
			  ELSE empty_ErrorTerms ENDIF ) ENDIF |} ENDIF

  Xa: VAR AffineCombination
  n, newidx, i: VAR nat
  N: VAR Noise
  x: VAR BaseType

  next_idx_pow_var_ac: LEMMA
  FORALL(Xa: (represents_var?), newidx: upfrom(next_idx(Xa`pd))):
  next_idx(pd(pow_var_ac(Xa,n,newidx))) <= newidx+(IF n>1 THEN n-1 ELSE 0 ENDIF)

  idxs_ac_pow_var_ac: LEMMA 
  FORALL(Xa: (represents_var?), newidx:upfrom(next_idx(Xa`pd))): 
  member(i, idxs_ac(pow_var_ac(Xa,n,newidx))) 
  IMPLIES  member(i, idxs_ac(Xa)) OR (n>1 AND newidx <= i AND i <= newidx+n-2)

  
  % Holds when N1 and N2 are such that eval_ac_noise(Xa,N1)^n = eval_ac_noise(pow_var_ac(Xa,n,newidx), N2)
  pow_var_compatible?(Xa,n,newidx)(N): bool
  = (length(pd(Xa)) > 0 IMPLIES FORALL(i: below(n-1)): 
  		      	        get_noise_by_idx(newidx+i, N) 
			          = get_noise_by_idx(nth(pd(Xa),0)`1, N)^(i+2))

  IMPORTING reals@polynomials   % Lemma used to prove containment_pow_var_ac
  %
  % Containment lemma
  %
  containment_pow_var_ac: LEMMA
  eval_ac_noise(Xa, N) = x AND
  represents_var?(Xa) AND
  newidx >= next_idx(pd(Xa)) AND
  pow_var_compatible?(Xa,n,newidx)(N)
  IMPLIES eval_ac_noise(pow_var_ac(Xa, n, newidx),N) = x^n


  pow_var_compatible_noise: LEMMA
  FORALL((Xa|represents_var?(Xa)AND length(pd(Xa))>0),(n|n>1),newidx:upfrom(next_idx(Xa`pd))):
  pow_var_compatible?(Xa,n,newidx)(upd_noise_range(N,newidx,n-2,LAMBDA(i:nat):get_noise_by_idx(nth(pd(Xa),0)`1, N)^(i+2)))

END affine_pow
