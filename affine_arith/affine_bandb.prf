(affine_bandb
 (altvar_TCC1 0
  (altvar_TCC1-1 nil 3627226550 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AffineExpr type-decl nil AffineExpr_adt nil)
    (const? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (varidx? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (add? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (neg? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (sub? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (mult? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (RealExpr type-eq-decl nil AffineExpr_adt nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (/= const-decl "boolean" notequal nil))
   nil))
 (altvar_TCC2 0
  (altvar_TCC2-1 nil 3627226550
   ("" (skeep :preds? t)
    (("" (lemma "mod_pos")
      (("" (inst?)
        (("1" (assert) nil nil)
         ("2" (hide 2) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((mod_pos formula-decl nil mod nil)
    (mod const-decl "{k | abs(k) < abs(j)}" mod nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (stack type-eq-decl nil stack "structures/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (AnsType type-eq-decl nil affine_bandb nil)
    (RealExpr type-eq-decl nil AffineExpr_adt nil)
    (mult? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (sub? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (neg? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (add? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (varidx? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (const? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AffineExpr type-decl nil AffineExpr_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (Box type-eq-decl nil affine_box nil)
    (box skolem-const-decl "Box" affine_bandb nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (simple_affine_soundness 0
  (simple_affine_soundness-1 nil 3627301744
   ("" (skeep)
    (("" (lemma "b_and_b_id_sound")
      (("" (expand "simple_affine")
        (("" (inst?)
          (("" (assert)
            (("" (hide 2)
              (("" (split)
                (("1" (expand "accomodates?")
                  (("1" (skeep)
                    (("1" (expand "sound?")
                      (("1" (flatten)
                        (("1" (skeep)
                          (("1" (lemma "Eval_inclusion_some")
                            (("1" (inst?)
                              (("1"
                                (beta)
                                (("1"
                                  (expand "evaluate")
                                  (("1"
                                    (lift-if 1)
                                    (("1"
                                      (split 1)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (use
                                             "containment_interval")
                                            (("1"
                                              (expand "containment")
                                              (("1"
                                                (hide 2)
                                                (("1"
                                                  (skeep)
                                                  (("1"
                                                    (inst?)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "subdiv_presound?")
                  (("2" (skeep)
                    (("2" (expand "denorm")
                      (("2" (expand "branch")
                        (("2" (expand "subdivide")
                          (("2" (expand "sound?")
                            (("2" (flatten)
                              (("2"
                                (expand "combine")
                                (("2"
                                  (use "Proper_Safe2")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (flatten)
                                      (("2"
                                        (replaces -3)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (skeep :preds? t)
                                            (("2"
                                              (inst - "vs")
                                              (("2"
                                                (rewrite
                                                 "Union_inclusion")
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (expand "subdiv_sound?")
                  (("3" (skeep)
                    (("3" (expand "denorm")
                      (("3" (expand "branch")
                        (("3" (expand "subdivide")
                          (("3" (expand "sound?")
                            (("3" (flatten)
                              (("3"
                                (expand "combine")
                                (("3"
                                  (use "Proper_Safe2")
                                  (("3"
                                    (assert)
                                    (("3"
                                      (flatten)
                                      (("3"
                                        (replaces -3)
                                        (("3"
                                          (assert)
                                          (("3"
                                            (skeep :preds? t)
                                            (("3"
                                              (lemma
                                               "split_vars_in_box")
                                              (("3"
                                                (inst
                                                 -1
                                                 "dom"
                                                 "vs"
                                                 "v")
                                                (("3"
                                                  (beta)
                                                  (("3"
                                                    (split -1)
                                                    (("1"
                                                      (inst? -5)
                                                      (("1"
                                                        (rewrite
                                                         "Union_inclusion")
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      (("2"
                                                        (inst? -6)
                                                        (("2"
                                                          (rewrite
                                                           "Union_inclusion")
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Box type-eq-decl nil affine_box nil)
    (list type-decl nil list_adt nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (AnsType type-eq-decl nil affine_bandb nil)
    (real nonempty-type-from-decl nil reals nil)
    (RealExpr type-eq-decl nil AffineExpr_adt nil)
    (mult? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (sub? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (neg? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (add? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (varidx? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (const? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (AffineExpr type-decl nil AffineExpr_adt nil)
    (b_and_b_id_sound formula-decl nil branch_and_bound "structures/")
    (Accumulator type-eq-decl nil branch_and_bound "structures/")
    (accumulate const-decl "AnsType" affine_bandb nil)
    (Brancher type-eq-decl nil branch_and_bound "structures/")
    (branch const-decl "[RealExpr, RealExpr]" affine_bandb nil)
    (Combiner type-eq-decl nil branch_and_bound "structures/")
    (combine const-decl "AnsType" affine_bandb nil)
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (DenormAns type-eq-decl nil branch_and_bound "structures/")
    (denorm const-decl "AnsType" affine_bandb nil)
    (Evaluator type-eq-decl nil branch_and_bound "structures/")
    (evaluate const-decl "AnsType" affine_bandb nil)
    (stack type-eq-decl nil stack "structures/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (ExitPred type-eq-decl nil branch_and_bound "structures/")
    (ge const-decl "bool" affine_bandb nil)
    (LocalExitPred type-eq-decl nil branch_and_bound "structures/")
    (le const-decl "bool" affine_bandb nil)
    (prune const-decl "bool" affine_bandb nil)
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (altvar const-decl "DirVar" affine_bandb nil)
    (SoundPred type-eq-decl nil branch_and_bound "structures/")
    (sound? const-decl "bool" affine_bandb nil)
    (SubdivDomain type-eq-decl nil branch_and_bound "structures/")
    (subdivide const-decl "[Box, Box]" affine_bandb nil)
    (subdiv_sound? const-decl "bool" branch_and_bound "structures/")
    (split_vars_in_box formula-decl nil affine_expr nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (HalfLeft const-decl "Interval" interval "interval_arith/")
    (HalfRight const-decl "Interval" interval "interval_arith/")
    (split def-decl "{lrb: [Box, Box] |
         LET (lb, rb) = lrb IN
           length(lb) = length(box) AND
            length(rb) = length(box) AND
             (FORALL (i: below(length(box))):
                IF i = v
                  THEN nth(lb, i) = HalfLeft(nth(box, i)) AND
                        nth(rb, i) = HalfRight(nth(box, i))
                ELSE nth(lb, i) = nth(box, i) AND nth(rb, i) = nth(box, i)
                ENDIF)}" affine_expr nil)
    (v skolem-const-decl "nat" affine_bandb nil)
    (dom skolem-const-decl "Box" affine_bandb nil)
    (vs skolem-const-decl "(vars_in_box?(dom))" affine_bandb nil)
    (subdiv_presound? const-decl "bool" branch_and_bound "structures/")
    (Proper_Safe2 formula-decl nil safe_arith "interval_arith/")
    (Union const-decl "Interval" interval "interval_arith/")
    (Union_inclusion formula-decl nil interval "interval_arith/")
    (accomodates? const-decl "bool" branch_and_bound "structures/")
    (vars_in_box? const-decl "bool" affine_box nil)
    (Env type-eq-decl nil affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (containment const-decl "bool" affine nil)
    (Noise type-eq-decl nil affine nil)
    (ordered_list? def-decl "bool" ordered_list nil)
    (lt_idx const-decl "bool" indexed_list nil)
    (nzEpsilon type-eq-decl nil affine nil)
    (/= const-decl "boolean" notequal nil)
    (Epsilon type-eq-decl nil affine nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (eval_ACExpr_Env def-decl "BaseType" affine_expr nil)
    (Eval_ACExpr_Box const-decl "Maybe[AffineCombination]" affine_expr
                     nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (containment_interval formula-decl nil affine nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (EmptyInterval const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (Proper? const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Eval_inclusion_some formula-decl nil affine_expr nil)
    (simple_affine const-decl "Output" affine_bandb nil))
   nil))
 (trivial_test 0
  (trivial_test-1 nil 3627228126
   ("" (skeep)
    (("" (name-label "sia" "r2E(1)" :hide? t)
      (("" (eval-expr "simple_affine(0,sia,(::))" :safe? nil)
        (("" (lemma "simple_affine_soundness")
          (("" (inst? -1)
            (("" (replaces -2)
              (("" (beta -1)
                (("" (expand "sound?" -1)
                  (("" (split -1)
                    (("1" (inst -1 "list2array(0)((::))")
                      (("1" (invoke (case "%1 = %2") (! -1 1) "1")
                        (("1" (replaces -1)
                          (("1" (decimalize -1 3) nil nil)) nil)
                         ("2" (interval-eq__ "sia" 1) nil nil))
                        nil)
                       ("2" (apply (repeat (expand "list2array" 1)))
                        (("2" (rewrite "vars_in_box")
                          (("2"
                            (apply (repeat
                                    (expand "vars_in_box_rec" 1)))
                            nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (eval-formula) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((r2E const-decl "RealExpr" affine_expr nil)
    (RealExpr type-eq-decl nil AffineExpr_adt nil)
    (mult? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (sub? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (neg? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (add? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (varidx? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (const? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (BaseType type-eq-decl nil affine nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (AffineExpr type-decl nil AffineExpr_adt nil)
    (simple_affine_soundness formula-decl nil affine_bandb nil)
    (sound? const-decl "bool" affine_bandb nil)
    (listn_0 name-judgement "listn[real](0)" affine_bandb nil)
    (Env type-eq-decl nil affine_box nil)
    (vars_in_box? const-decl "bool" affine_box nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list2array def-decl "T" array2list "structures/")
    (sia skolem-const-decl "RealExpr" affine_bandb nil)
    (|##| const-decl "bool" interval "interval_arith/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (eval_ACExpr_Env def-decl "BaseType" affine_expr nil)
    (vars_in_box formula-decl nil affine_box nil)
    (length_null formula-decl nil more_list_props "structures/")
    (vars_in_box_rec def-decl "{b: bool |
         b =
          (EXISTS (N: Noise):
             FORALL (k: subrange(i, n - 1)):
               vs(k) ## nth(box, k - i) AND
                eval_ac_noise(var_ac(nth(box, k - i), k), N) = vs(k) AND
                 (SingInterval?(nth(box, k - i)) IMPLIES
                   get_noise_by_idx(k, N) = 0))}" affine_box nil)
    (real nonempty-type-from-decl nil reals nil)
    (AnsType type-eq-decl nil affine_bandb nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil affine_box nil)
    (Output type-eq-decl nil branch_and_bound "structures/")
    (simple_affine const-decl "Output" affine_bandb nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (simple_test1 0
  (simple_test1-1 nil 3627231847
   ("" (skeep)
    (("" (name-label "sia" "ADD(X(0),X(0))" :hide? t)
      (("" (eval-expr "simple_affine(5,sia,(: [|0,1|] :))" :safe? nil)
        (("" (lemma "simple_affine_soundness")
          (("" (inst? -1)
            (("" (replaces -2)
              (("" (beta -1)
                (("" (expand "sound?" -1)
                  (("" (split -1)
                    (("1" (inst -1 "list2array(0)((:x:))")
                      (("1"
                        (invoke (case "%1 = %2") (! -1 1) "(x + x)")
                        (("1" (replaces -1)
                          (("1" (decimalize -1 3) nil nil)) nil)
                         ("2" (interval-eq__ "sia" 1) nil nil))
                        nil)
                       ("2" (apply (repeat (expand "list2array" 1)))
                        (("2" (rewrite "vars_in_box")
                          (("2"
                            (apply (repeat
                                    (expand "vars_in_box_rec" 1)))
                            nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (eval-formula) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((X const-decl "RealExpr" affine_expr nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]"
     AffineExpr_adt nil)
    (RealExpr type-eq-decl nil AffineExpr_adt nil)
    (mult? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (sub? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (neg? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (add? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (varidx? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (const? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (AffineExpr type-decl nil AffineExpr_adt nil)
    (simple_affine_soundness formula-decl nil affine_bandb nil)
    (sound? const-decl "bool" affine_bandb nil)
    (listn_0 name-judgement "listn[real](0)" affine_bandb nil)
    (BaseType type-eq-decl nil affine nil)
    (Env type-eq-decl nil affine_box nil)
    (vars_in_box? const-decl "bool" affine_box nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list2array def-decl "T" array2list "structures/")
    (x skolem-const-decl "real" affine_bandb nil)
    (sia skolem-const-decl "(add?)" affine_bandb nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (eval_ACExpr_Env def-decl "BaseType" affine_expr nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (vars_in_box formula-decl nil affine_box nil)
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box_rec def-decl "{b: bool |
         b =
          (EXISTS (N: Noise):
             FORALL (k: subrange(i, n - 1)):
               vs(k) ## nth(box, k - i) AND
                eval_ac_noise(var_ac(nth(box, k - i), k), N) = vs(k) AND
                 (SingInterval?(nth(box, k - i)) IMPLIES
                   get_noise_by_idx(k, N) = 0))}" affine_box nil)
    (AnsType type-eq-decl nil affine_bandb nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil affine_box nil)
    (Output type-eq-decl nil branch_and_bound "structures/")
    (simple_affine const-decl "Output" affine_bandb nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (simple_test2 0
  (simple_test2-1 nil 3627231881
   ("" (skeep)
    (("" (name-label "sia" "SUB(X(0),X(0))" :hide? t)
      (("" (eval-expr "simple_affine(5,sia,(: [|0,1|] :))" :safe? nil)
        (("" (lemma "simple_affine_soundness")
          (("" (inst? -1)
            (("" (replaces -2)
              (("" (beta -1)
                (("" (expand "sound?" -1)
                  (("" (split -1)
                    (("1" (inst -1 "list2array(0)((:x:))")
                      (("1"
                        (invoke (case "%1 = %2") (! -1 1) "(x - x)")
                        (("1" (replaces -1)
                          (("1" (decimalize -1 3) nil nil)) nil)
                         ("2" (interval-eq__ "sia" 1) nil nil))
                        nil)
                       ("2" (apply (repeat (expand "list2array" 1)))
                        (("2" (rewrite "vars_in_box")
                          (("2"
                            (apply (repeat
                                    (expand "vars_in_box_rec" 1)))
                            nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (eval-formula) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((X const-decl "RealExpr" affine_expr nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     AffineExpr_adt nil)
    (RealExpr type-eq-decl nil AffineExpr_adt nil)
    (mult? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (sub? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (neg? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (add? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (varidx? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (const? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (AffineExpr type-decl nil AffineExpr_adt nil)
    (simple_affine_soundness formula-decl nil affine_bandb nil)
    (sound? const-decl "bool" affine_bandb nil)
    (listn_0 name-judgement "listn[real](0)" affine_bandb nil)
    (BaseType type-eq-decl nil affine nil)
    (Env type-eq-decl nil affine_box nil)
    (vars_in_box? const-decl "bool" affine_box nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list2array def-decl "T" array2list "structures/")
    (x skolem-const-decl "real" affine_bandb nil)
    (sia skolem-const-decl "(sub?)" affine_bandb nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (eval_ACExpr_Env def-decl "BaseType" affine_expr nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (vars_in_box formula-decl nil affine_box nil)
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box_rec def-decl "{b: bool |
         b =
          (EXISTS (N: Noise):
             FORALL (k: subrange(i, n - 1)):
               vs(k) ## nth(box, k - i) AND
                eval_ac_noise(var_ac(nth(box, k - i), k), N) = vs(k) AND
                 (SingInterval?(nth(box, k - i)) IMPLIES
                   get_noise_by_idx(k, N) = 0))}" affine_box nil)
    (AnsType type-eq-decl nil affine_bandb nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil affine_box nil)
    (Output type-eq-decl nil branch_and_bound "structures/")
    (simple_affine const-decl "Output" affine_bandb nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (simple_test3 0
  (simple_test3-1 nil 3627232209
   ("" (skeep)
    ((""
      (name-label "sia" "SUB(ADD(X(0),SUB(r2E(1),X(0))),r2E(1))" :hide?
       t)
      (("" (eval-expr "simple_affine(5,sia,(: [|0,1|] :))" :safe? nil)
        (("" (lemma "simple_affine_soundness")
          (("" (inst? -1)
            (("" (replaces -2)
              (("" (beta -1)
                (("" (expand "sound?" -1)
                  (("" (split -1)
                    (("1" (inst -1 "list2array(0)((:x:))")
                      (("1"
                        (invoke (case "%1 = %2") (! -1 1)
                         "(x + (1 - x) - 1)")
                        (("1" (replaces -1)
                          (("1" (decimalize -1 3) nil nil)) nil)
                         ("2" (interval-eq__ "sia" 1) nil nil))
                        nil)
                       ("2" (apply (repeat (expand "list2array" 1)))
                        (("2" (rewrite "vars_in_box")
                          (("2"
                            (apply (repeat
                                    (expand "vars_in_box_rec" 1)))
                            nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (eval-formula) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((r2E const-decl "RealExpr" affine_expr nil)
    (BaseType type-eq-decl nil affine nil)
    (X const-decl "RealExpr" affine_expr nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]"
     AffineExpr_adt nil)
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     AffineExpr_adt nil)
    (RealExpr type-eq-decl nil AffineExpr_adt nil)
    (mult? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (sub? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (neg? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (add? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (varidx? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (const? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (AffineExpr type-decl nil AffineExpr_adt nil)
    (simple_affine_soundness formula-decl nil affine_bandb nil)
    (sound? const-decl "bool" affine_bandb nil)
    (listn_0 name-judgement "listn[real](0)" affine_bandb nil)
    (Env type-eq-decl nil affine_box nil)
    (vars_in_box? const-decl "bool" affine_box nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list2array def-decl "T" array2list "structures/")
    (x skolem-const-decl "real" affine_bandb nil)
    (sia skolem-const-decl "(sub?)" affine_bandb nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (eval_ACExpr_Env def-decl "BaseType" affine_expr nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (vars_in_box formula-decl nil affine_box nil)
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box_rec def-decl "{b: bool |
         b =
          (EXISTS (N: Noise):
             FORALL (k: subrange(i, n - 1)):
               vs(k) ## nth(box, k - i) AND
                eval_ac_noise(var_ac(nth(box, k - i), k), N) = vs(k) AND
                 (SingInterval?(nth(box, k - i)) IMPLIES
                   get_noise_by_idx(k, N) = 0))}" affine_box nil)
    (AnsType type-eq-decl nil affine_bandb nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil affine_box nil)
    (Output type-eq-decl nil branch_and_bound "structures/")
    (simple_affine const-decl "Output" affine_bandb nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (simple_test 0
  (simple_test-1 nil 3627231378
   ("" (skeep)
    (("" (name-label "sia" "MULT(X(0),SUB(r2E(1),X(0)))" :hide? t)
      (("" (eval-expr "simple_affine(5,sia,(: [|0,1|] :))" :safe? nil)
        (("" (lemma "simple_affine_soundness")
          (("" (inst? -1)
            (("" (replaces -2)
              (("" (beta -1)
                (("" (expand "sound?" -1)
                  (("" (split -1)
                    (("1" (inst -1 "list2array(0)((:x:))")
                      (("1"
                        (invoke (case "%1 = %2") (! -1 1)
                         "(x * (1 - x))")
                        (("1" (replaces -1)
                          (("1" (decimalize -1 3) nil nil)) nil)
                         ("2" (interval-eq__ "sia" 1) nil nil))
                        nil)
                       ("2" (apply (repeat (expand "list2array" 1)))
                        (("2" (rewrite "vars_in_box")
                          (("2"
                            (apply (repeat
                                    (expand "vars_in_box_rec" 1)))
                            nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (eval-formula) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((r2E const-decl "RealExpr" affine_expr nil)
    (BaseType type-eq-decl nil affine nil)
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     AffineExpr_adt nil)
    (X const-decl "RealExpr" affine_expr nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]"
     AffineExpr_adt nil)
    (RealExpr type-eq-decl nil AffineExpr_adt nil)
    (mult? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (sub? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (neg? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (add? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (varidx? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (const? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (AffineExpr type-decl nil AffineExpr_adt nil)
    (simple_affine_soundness formula-decl nil affine_bandb nil)
    (sound? const-decl "bool" affine_bandb nil)
    (listn_0 name-judgement "listn[real](0)" affine_bandb nil)
    (Env type-eq-decl nil affine_box nil)
    (vars_in_box? const-decl "bool" affine_box nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list2array def-decl "T" array2list "structures/")
    (x skolem-const-decl "real" affine_bandb nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (sia skolem-const-decl "(mult?)" affine_bandb nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (ub_interval formula-decl nil interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (eval_ACExpr_Env def-decl "BaseType" affine_expr nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (vars_in_box formula-decl nil affine_box nil)
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box_rec def-decl "{b: bool |
         b =
          (EXISTS (N: Noise):
             FORALL (k: subrange(i, n - 1)):
               vs(k) ## nth(box, k - i) AND
                eval_ac_noise(var_ac(nth(box, k - i), k), N) = vs(k) AND
                 (SingInterval?(nth(box, k - i)) IMPLIES
                   get_noise_by_idx(k, N) = 0))}" affine_box nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil affine_box nil)
    (AnsType type-eq-decl nil affine_bandb nil)
    (Output type-eq-decl nil branch_and_bound "structures/")
    (simple_affine const-decl "Output" affine_bandb nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (FALSE const-decl "bool" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (simple_test_bad 0
  (simple_test_bad-1 nil 3629651367
   ("" (skeep)
    (("" (name-label "sia" "MULT(X(0),SUB(r2E(1),X(0)))" :hide? t)
      ((""
        (eval-expr "simple_affine(5,sia,(: [|3/10,7/10|] :))" :safe?
         nil)
        (("" (lemma "simple_affine_soundness")
          (("" (inst? -1)
            (("" (replaces -2)
              (("" (beta -1)
                (("" (expand "sound?" -1)
                  (("" (split -1)
                    (("1" (inst -1 "list2array(0)((:x:))")
                      (("1"
                        (invoke (case "%1 = %2") (! -1 1)
                         "(x * (1 - x))")
                        (("1" (replaces -1)
                          (("1" (decimalize -1 3)
                            (("1" (lemma "Member_trans")
                              (("1"
                                (inst? -1 :where 1)
                                (("1"
                                  (inst? -1 :where -2)
                                  (("1"
                                    (assert)
                                    (("1" (eval-formula 1) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (interval-eq__ "sia" 1) nil nil))
                        nil)
                       ("2" (apply (repeat (expand "list2array" 1)))
                        (("2" (rewrite "vars_in_box")
                          (("2"
                            (apply (repeat
                                    (expand "vars_in_box_rec" 1)))
                            nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (eval-formula) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((r2E const-decl "RealExpr" affine_expr nil)
    (BaseType type-eq-decl nil affine nil)
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     AffineExpr_adt nil)
    (X const-decl "RealExpr" affine_expr nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]"
     AffineExpr_adt nil)
    (RealExpr type-eq-decl nil AffineExpr_adt nil)
    (mult? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (sub? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (neg? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (add? adt-recognizer-decl "[AffineExpr -> boolean]" AffineExpr_adt
     nil)
    (varidx? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (const? adt-recognizer-decl "[AffineExpr -> boolean]"
     AffineExpr_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (AffineExpr type-decl nil AffineExpr_adt nil)
    (simple_affine_soundness formula-decl nil affine_bandb nil)
    (sound? const-decl "bool" affine_bandb nil)
    (listn_0 name-judgement "listn[real](0)" affine_bandb nil)
    (Env type-eq-decl nil affine_box nil)
    (vars_in_box? const-decl "bool" affine_box nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list2array def-decl "T" array2list "structures/")
    (x skolem-const-decl "real" affine_bandb nil)
    (empty_ErrorTerms const-decl "ErrorTerms" affine nil)
    ({\|\|} const-decl "AffineCombination" affine nil)
    (sia skolem-const-decl "(mult?)" affine_bandb nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (Member_trans formula-decl nil interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ub_interval formula-decl nil interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (eval_ACExpr_Env def-decl "BaseType" affine_expr nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (vars_in_box formula-decl nil affine_box nil)
    (length_singleton formula-decl nil more_list_props "structures/")
    (vars_in_box_rec def-decl "{b: bool |
         b =
          (EXISTS (N: Noise):
             FORALL (k: subrange(i, n - 1)):
               vs(k) ## nth(box, k - i) AND
                eval_ac_noise(var_ac(nth(box, k - i), k), N) = vs(k) AND
                 (SingInterval?(nth(box, k - i)) IMPLIES
                   get_noise_by_idx(k, N) = 0))}" affine_box nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (Box type-eq-decl nil affine_box nil)
    (AnsType type-eq-decl nil affine_bandb nil)
    (Output type-eq-decl nil branch_and_bound "structures/")
    (simple_affine const-decl "Output" affine_bandb nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   shostak)))

