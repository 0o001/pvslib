(affine_expr_Eval_fnd (CacheData_TCC1 0 (CacheData_TCC1-1 nil 3635095591 ("" (assuming-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (restrict const-decl "R" restrict nil) (irreflexive? const-decl "bool" relations nil) (transitive? const-decl "bool" relations nil) (strict_order? const-decl "bool" orders nil) (strict_total_order_restrict application-judgement "(strict_total_order?[S])" restrict_order_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (CacheData assuming "structures@ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].ordered_list" "order: ASSUMPTION orders[ordered_list.T].strict_order?(ordered_list.<)"))) (CacheData_correct?_TCC1 0 (CacheData_correct?_TCC1-1 nil 3631623248 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (CacheData_correct? subtype "affine_expr_Eval_fnd.re" "(IntervalExpr_adt.pow?)"))) (CacheData_correct?_TCC2 0 (CacheData_correct?_TCC2-1 nil 3631623248 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (real_plus_real_is_real application-judgement "real" reals nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (CacheData_correct? subtype "affine_expr_Eval_fnd.idxs" "(list_adt[nat].cons?)"))) (CacheData_correct?_TCC3 0 (CacheData_correct?_TCC3-1 nil 3631623248 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (real_plus_real_is_real application-judgement "real" reals nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (represents_var? const-decl "bool" affine nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (CacheData_correct? subtype "affine_expr_Eval_fnd.varac" "(affine.represents_var?)"))) (CacheData_correct?_inclusion 0 (CacheData_correct?_inclusion-1 nil 3638271616 ("" (skeep) (("" (expand "CacheData_correct?") (("" (flatten) (("" (assert) (("" (flatten) (("" (split 1) (("1" (use "length_append[Interval]") (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -2) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand "nth_ac") (("1" (use "nth_append[Interval]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth_ac") (("2" (use "nth_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "nth_ac") (("3" (use "nth_append[Interval]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (length_append formula-decl nil list_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (nth_append formula-decl nil more_list_props structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (nth_ac const-decl "AffineCombination" affine_box nil)) shostak)) (correct_cache?_TCC1 0 (correct_cache?_TCC1-1 nil 3631620842 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (length def-decl "nat" list_props nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (nth def-decl "T" list_props nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil (correct_cache? termination "affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.t)" "nil"))) (correct_cache?_alt_def 0 (correct_cache?_alt_def-1 nil 3638269279 ("" (induct "cache") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (length def-decl "nat" list_props nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (nth def-decl "T" list_props nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (list_induction formula-decl nil list_adt nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (= const-decl "[T, T -> boolean]" equalities nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith)) shostak)) (cache_powvar_correct 0 (cache_powvar_correct-1 nil 3632133476 ("" (skolem 1 ("box_" "cache_" "i_")) (("" (name "L" "length(cache_)") (("" (typepred "i_") (("" (generalize-skolem-constants) (("" (induct "L_1") (("1" (skeep) (("1" (grind) nil nil)) nil) ("2" (skolem 1 "j") (("2" (flatten) (("2" (skeep) (("2" (expand "nth" 1) (("2" (split 1) (("1" (flatten) (("1" (typepred "cache_1") (("1" (expand "correct_cache?") (("1" (lift-if -1) (("1" (split -1) (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst? -1 :where 2) (("1" (assert) (("1" (split 3) (("1" (expand "length" -1) (("1" (lift-if -1) (("1" (split -1) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "length" -2) (("2" (lift-if -2) (("2" (split -2) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (typepred "cache_1") (("3" (expand "correct_cache?" -1) (("3" (lift-if -1) (("3" (split -1) (("1" (grind) nil nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (length def-decl "nat" list_props nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (box_1 skolem-const-decl "Box" affine_expr_Eval_fnd nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cache_1 skolem-const-decl "(correct_cache?(box_1))" affine_expr_Eval_fnd nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (i_1 skolem-const-decl "below(length(cache_1))" affine_expr_Eval_fnd nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil)) shostak)) (compatible_pairs_on?_TCC1 0 (compatible_pairs_on?_TCC1-1 nil 3631905767 ("" (subtype-tcc) (("" (grind) nil nil)) nil) ((null_ol? const-decl "bool" ordered_list structures) (eval def-decl "real" interval_expr interval_arith) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (upfrom nonempty-type-eq-decl nil integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (represents_var? const-decl "bool" affine nil) (length_singleton formula-decl nil more_list_props structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (eval_ac_noise const-decl "real" affine nil)) nil (compatible_pairs_on? subtype "affine_box.nth_ac(affine_expr_Eval_fnd.box, affine_expr.varidx_powvar(affine_expr_Eval_fnd.re))" "(affine.represents_var?)"))) (compatible_pairs_on?_TCC2 0 (compatible_pairs_on?_TCC2-1 nil 3631905767 ("" (subtype-tcc) nil nil) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (upfrom nonempty-type-eq-decl nil integers nil) (eval_ac_noise const-decl "real" affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil)) nil (compatible_pairs_on? subtype "affine_expr_Eval_fnd.re" "(IntervalExpr_adt.pow?)"))) (compatible_pairs_on?_TCC3 0 (compatible_pairs_on?_TCC3-2 nil 3638025854 ("" (skeep*) (("" (typepred "l") (("" (use "cache_powvar_correct") (("" (expand "CacheData_correct?") (("" (assert) (("" (flatten) (("" (assert) (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (cache_powvar_correct formula-decl nil affine_expr_Eval_fnd nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) nil (compatible_pairs_on? subtype "list_props[CacheData].nth(affine_expr_Eval_fnd.l, affine_expr_Eval_fnd.i)`3" "{nwidxs: ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(nwidxs), (number_fields.-)(IntervalExpr_adt.opn(affine_expr_Eval_fnd.re), 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(nwidxs)), reals.>=(list_adt[nat].car(nwidxs), affine.next_idx(pd(affine_box.nth_ac(affine_expr_Eval_fnd.box, affine_expr.varidx_powvar(affine_expr_Eval_fnd.re))))))))), list_props[[nat, nzBaseType]].length(pd(affine_box.nth_ac(affine_expr_Eval_fnd.box, affine_expr.varidx_powvar(affine_expr_Eval_fnd.re)))) = 0)}")) (compatible_pairs_on?_TCC3-1 nil 3631905767 ("" (grind) nil nil) ((Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil)) nil (compatible_pairs_on? subtype "list_props[CacheData].nth(affine_expr_Eval_fnd.l, affine_expr_Eval_fnd.i)`3" "{nwidxs: ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(nwidxs), (number_fields.-)(IntervalExpr_adt.opn(affine_expr_Eval_fnd.re), 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(nwidxs)), reals.>=(list_adt[nat].car(nwidxs), affine.next_idx(pd(affine_box.nth_ac(affine_expr_Eval_fnd.box, affine_expr.varidx_powvar(affine_expr_Eval_fnd.re))))))))), list_props[[nat, nzBaseType]].length(pd(affine_box.nth_ac(affine_expr_Eval_fnd.box, affine_expr.varidx_powvar(affine_expr_Eval_fnd.re)))) = 0)}"))) (cache_eq_TCC1 0 (cache_eq_TCC1-1 nil 3766770260 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) nil (cache_eq subtype "affine_expr_Eval_fnd.expr1" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.brel?(x) OR IntervalExpr_adt.fun4?(x) OR IntervalExpr_adt.fun2?(x) OR IntervalExpr_adt.div?(x) OR IntervalExpr_adt.mult?(x) OR IntervalExpr_adt.sub?(x) OR IntervalExpr_adt.add?(x)}"))) (cache_eq_TCC2 0 (cache_eq_TCC2-1 nil 3766770260 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) nil (cache_eq subtype "affine_expr_Eval_fnd.expr2" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.brel?(x) OR IntervalExpr_adt.fun4?(x) OR IntervalExpr_adt.fun2?(x) OR IntervalExpr_adt.div?(x) OR IntervalExpr_adt.mult?(x) OR IntervalExpr_adt.sub?(x) OR IntervalExpr_adt.add?(x)}"))) (cache_eq_TCC3 0 (cache_eq_TCC3-1 nil 3766770260 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) nil (cache_eq subtype "affine_expr_Eval_fnd.expr1" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.bincludes?(x) OR IntervalExpr_adt.fun?(x) OR IntervalExpr_adt.pow?(x) OR IntervalExpr_adt.sq?(x) OR IntervalExpr_adt.neg?(x) OR IntervalExpr_adt.abs?(x)}"))) (cache_eq_TCC4 0 (cache_eq_TCC4-1 nil 3766770260 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) nil (cache_eq subtype "affine_expr_Eval_fnd.expr2" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.bincludes?(x) OR IntervalExpr_adt.fun?(x) OR IntervalExpr_adt.pow?(x) OR IntervalExpr_adt.sq?(x) OR IntervalExpr_adt.neg?(x) OR IntervalExpr_adt.abs?(x)}"))) (cache_eq_TCC5 0 (cache_eq_TCC5-1 nil 3766770260 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) nil (cache_eq subtype "affine_expr_Eval_fnd.expr1" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.bincludes?(x) OR IntervalExpr_adt.fun?(x) OR IntervalExpr_adt.pow?(x) OR IntervalExpr_adt.sq?(x) OR IntervalExpr_adt.neg?(x) OR IntervalExpr_adt.abs?(x)}"))) (cache_eq_TCC6 0 (cache_eq_TCC6-1 nil 3766770260 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) nil (cache_eq subtype "affine_expr_Eval_fnd.expr2" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.bincludes?(x) OR IntervalExpr_adt.fun?(x) OR IntervalExpr_adt.pow?(x) OR IntervalExpr_adt.sq?(x) OR IntervalExpr_adt.neg?(x) OR IntervalExpr_adt.abs?(x)}"))) (cache_eq_TCC7 0 (cache_eq_TCC7-1 nil 3766770260 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) nil (cache_eq subtype "affine_expr_Eval_fnd.expr1" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.brel?(x) OR IntervalExpr_adt.fun4?(x) OR IntervalExpr_adt.fun2?(x) OR IntervalExpr_adt.div?(x) OR IntervalExpr_adt.mult?(x) OR IntervalExpr_adt.sub?(x) OR IntervalExpr_adt.add?(x)}"))) (cache_eq_TCC8 0 (cache_eq_TCC8-1 nil 3766770260 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) nil (cache_eq subtype "affine_expr_Eval_fnd.expr2" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.brel?(x) OR IntervalExpr_adt.fun4?(x) OR IntervalExpr_adt.fun2?(x) OR IntervalExpr_adt.div?(x) OR IntervalExpr_adt.mult?(x) OR IntervalExpr_adt.sub?(x) OR IntervalExpr_adt.add?(x)}"))) (cache_eq_TCC9 0 (cache_eq_TCC9-1 nil 3766770260 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) nil (cache_eq subtype "affine_expr_Eval_fnd.expr1" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.brel?(x) OR IntervalExpr_adt.fun4?(x) OR IntervalExpr_adt.fun2?(x) OR IntervalExpr_adt.div?(x) OR IntervalExpr_adt.mult?(x) OR IntervalExpr_adt.sub?(x) OR IntervalExpr_adt.add?(x)}"))) (cache_eq_TCC10 0 (cache_eq_TCC10-1 nil 3766770260 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) nil (cache_eq subtype "affine_expr_Eval_fnd.expr2" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.brel?(x) OR IntervalExpr_adt.fun4?(x) OR IntervalExpr_adt.fun2?(x) OR IntervalExpr_adt.div?(x) OR IntervalExpr_adt.mult?(x) OR IntervalExpr_adt.sub?(x) OR IntervalExpr_adt.add?(x)}"))) (cache_eq_TCC11 0 (cache_eq_TCC11-1 nil 3766770260 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) nil (cache_eq subtype "affine_expr_Eval_fnd.expr1" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.bincludes?(x) OR IntervalExpr_adt.fun?(x) OR IntervalExpr_adt.pow?(x) OR IntervalExpr_adt.sq?(x) OR IntervalExpr_adt.neg?(x) OR IntervalExpr_adt.abs?(x)}"))) (cache_eq_TCC12 0 (cache_eq_TCC12-1 nil 3766770260 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) nil (cache_eq subtype "affine_expr_Eval_fnd.expr2" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.bincludes?(x) OR IntervalExpr_adt.fun?(x) OR IntervalExpr_adt.pow?(x) OR IntervalExpr_adt.sq?(x) OR IntervalExpr_adt.neg?(x) OR IntervalExpr_adt.abs?(x)}"))) (cache_eq_TCC13 0 (cache_eq_TCC13-1 nil 3766770260 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) nil (cache_eq subtype "affine_expr_Eval_fnd.expr1" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.bincludes?(x) OR IntervalExpr_adt.fun?(x) OR IntervalExpr_adt.pow?(x) OR IntervalExpr_adt.sq?(x) OR IntervalExpr_adt.neg?(x) OR IntervalExpr_adt.abs?(x)}"))) (cache_eq_TCC14 0 (cache_eq_TCC14-1 nil 3766770260 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) nil (cache_eq subtype "affine_expr_Eval_fnd.expr2" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.bincludes?(x) OR IntervalExpr_adt.fun?(x) OR IntervalExpr_adt.pow?(x) OR IntervalExpr_adt.sq?(x) OR IntervalExpr_adt.neg?(x) OR IntervalExpr_adt.abs?(x)}"))) (cache_eq_TCC15 0 (cache_eq_TCC15-1 nil 3766770260 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) nil (cache_eq subtype "affine_expr_Eval_fnd.expr1" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.brel?(x) OR IntervalExpr_adt.fun4?(x) OR IntervalExpr_adt.fun2?(x) OR IntervalExpr_adt.div?(x) OR IntervalExpr_adt.mult?(x) OR IntervalExpr_adt.sub?(x) OR IntervalExpr_adt.add?(x)}"))) (cache_eq_TCC16 0 (cache_eq_TCC16-1 nil 3766770260 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) nil (cache_eq subtype "affine_expr_Eval_fnd.expr2" "{x: IntervalExpr_adt.IntervalExpr |      IntervalExpr_adt.brel?(x) OR IntervalExpr_adt.fun4?(x) OR IntervalExpr_adt.fun2?(x) OR IntervalExpr_adt.div?(x) OR IntervalExpr_adt.mult?(x) OR IntervalExpr_adt.sub?(x) OR IntervalExpr_adt.add?(x)}"))) (cache_eq_sound 0 (cache_eq_sound-1 nil 3766770276 ("" (induct "expr1") (("1" (skeep) (("1" (expand "cache_eq") (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (hide -1) (("2" (skeep) (("2" (expand "cache_eq") (("2" (flatten) (("2" (decompose-equality 1) (("2" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (hide -1) (("3" (skeep) (("3" (expand "cache_eq") (("3" (flatten) (("3" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (hide -3) (("4" (typepred "ADD1_var") (("4" (replaces -1) (("4" (typepred "ADD2_var") (("4" (replaces -1) (("4" (skeep) (("4" (expand "cache_eq" -3) (("4" (flatten) (("4" (decompose-equality 1) (("1" (inst -1 "op1(expr2)") (("1" (assert) nil nil)) nil) ("2" (inst -2 "op2(expr2)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (hide -2) (("5" (typepred "ABS1_var") (("5" (replaces -1) (("5" (skeep) (("5" (expand "cache_eq" -2) (("5" (flatten) (("5" (decompose-equality 1) (("5" (inst -1 "op(expr2)") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep) (("6" (hide -2) (("6" (typepred "NEG1_var") (("6" (replaces -1) (("6" (skeep) (("6" (expand "cache_eq" -2) (("6" (flatten) (("6" (decompose-equality 1) (("6" (inst -1 "op(expr2)") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skeep) (("7" (hide -3) (("7" (typepred "SUB1_var") (("7" (replaces -1) (("7" (typepred "SUB2_var") (("7" (replaces -1) (("7" (skeep) (("7" (expand "cache_eq" -3) (("7" (flatten) (("7" (decompose-equality 1) (("1" (inst -1 "op1(expr2)") (("1" (assert) nil nil)) nil) ("2" (inst -2 "op2(expr2)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skeep) (("8" (hide -3) (("8" (typepred "MULT1_var") (("8" (replaces -1) (("8" (typepred "MULT2_var") (("8" (replaces -1) (("8" (skeep) (("8" (expand "cache_eq" -3) (("8" (flatten) (("8" (decompose-equality 1) (("1" (inst -1 "op1(expr2)") (("1" (assert) nil nil)) nil) ("2" (inst -2 "op2(expr2)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (skeep) (("9" (hide -2) (("9" (typepred "SQ1_var") (("9" (replaces -1) (("9" (skeep) (("9" (expand "cache_eq" -2) (("9" (flatten) (("9" (decompose-equality 1) (("9" (inst -1 "op(expr2)") (("9" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("10" (skeep) (("10" (hide -2) (("10" (typepred "POW1_var") (("10" (replaces -1) (("10" (skeep) (("10" (expand "cache_eq" -2) (("10" (flatten) (("10" (decompose-equality 1) (("10" (inst -1 "op(expr2)") (("10" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("11" (skeep) (("11" (hide -3) (("11" (typepred "DIV1_var") (("11" (replaces -1) (("11" (typepred "DIV2_var") (("11" (replaces -1) (("11" (skeep) (("11" (expand "cache_eq" -3) (("11" (flatten) (("11" (decompose-equality 1) (("1" (inst -1 "op1(expr2)") (("1" (assert) nil nil)) nil) ("2" (inst -2 "op2(expr2)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (skeep) (("12" (hide -) (("12" (skeep) (("12" (expand "cache_eq") (("12" (propax) nil nil)) nil)) nil)) nil)) nil) ("13" (skeep) (("13" (hide -) (("13" (skeep) (("13" (expand "cache_eq") (("13" (propax) nil nil)) nil)) nil)) nil)) nil) ("14" (skeep) (("14" (hide -) (("14" (skeep) (("14" (expand "cache_eq") (("14" (propax) nil nil)) nil)) nil)) nil)) nil) ("15" (skeep) (("15" (hide -) (("15" (skeep) (("15" (expand "cache_eq") (("15" (propax) nil nil)) nil)) nil)) nil)) nil) ("16" (skeep) (("16" (hide -) (("16" (skeep) (("16" (expand "cache_eq") (("16" (propax) nil nil)) nil)) nil)) nil)) nil) ("17" (skeep) (("17" (hide -) (("17" (skeep) (("17" (expand "cache_eq") (("17" (propax) nil nil)) nil)) nil)) nil)) nil) ("18" (skeep) (("18" (hide -) (("18" (skeep) (("18" (expand "cache_eq") (("18" (propax) nil nil)) nil)) nil)) nil)) nil) ("19" (skeep) (("19" (hide -) (("19" (skeep) (("19" (expand "cache_eq") (("19" (propax) nil nil)) nil)) nil)) nil)) nil) ("20" (skeep) (("20" (hide -) (("20" (skeep) (("20" (expand "cache_eq") (("20" (propax) nil nil)) nil)) nil)) nil)) nil) ("21" (skeep) (("21" (hide -) (("21" (skeep) (("21" (expand "cache_eq") (("21" (propax) nil nil)) nil)) nil)) nil)) nil) ("22" (skeep) (("22" (hide -) (("22" (skeep) (("22" (expand "cache_eq") (("22" (propax) nil nil)) nil)) nil)) nil)) nil) ("23" (skeep) (("23" (hide -) (("23" (skeep) (("23" (expand "cache_eq") (("23" (propax) nil nil)) nil)) nil)) nil)) nil) ("24" (skeep) (("24" (hide -) (("24" (skeep) (("24" (expand "cache_eq") (("24" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((IntervalExpr_DIV_extensionality formula-decl nil IntervalExpr_adt interval_arith) (DIV adt-constructor-decl "[[RealExpr, RealExpr] -> (div?)]" IntervalExpr_adt interval_arith) (expr2 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (IntervalExpr_POW_extensionality formula-decl nil IntervalExpr_adt interval_arith) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (IntervalExpr_SQ_extensionality formula-decl nil IntervalExpr_adt interval_arith) (SQ adt-constructor-decl "[RealExpr -> (sq?)]" IntervalExpr_adt interval_arith) (expr2 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (IntervalExpr_MULT_extensionality formula-decl nil IntervalExpr_adt interval_arith) (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]" IntervalExpr_adt interval_arith) (expr2 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (IntervalExpr_SUB_extensionality formula-decl nil IntervalExpr_adt interval_arith) (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]" IntervalExpr_adt interval_arith) (expr2 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (IntervalExpr_NEG_extensionality formula-decl nil IntervalExpr_adt interval_arith) (NEG adt-constructor-decl "[RealExpr -> (neg?)]" IntervalExpr_adt interval_arith) (expr2 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (op shared-adt-accessor-decl "[{x: IntervalExpr |
         bincludes?(x) OR fun?(x) OR pow?(x) OR sq?(x) OR neg?(x)
     OR abs?(x)} ->
   RealExpr]" IntervalExpr_adt interval_arith) (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr_ABS_extensionality formula-decl nil IntervalExpr_adt interval_arith) (ABS adt-constructor-decl "[RealExpr -> (abs?)]" IntervalExpr_adt interval_arith) (expr2 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (NOT const-decl "[bool -> bool]" booleans nil) (op2 shared-adt-accessor-decl "[{x: IntervalExpr |
         brel?(x) OR fun4?(x) OR fun2?(x) OR div?(x) OR mult?(x) OR sub?(x)
     OR add?(x)} ->
   RealExpr]" IntervalExpr_adt interval_arith) (op1 shared-adt-accessor-decl "[{x: IntervalExpr |
         brel?(x) OR fun4?(x) OR fun2?(x) OR div?(x) OR mult?(x) OR sub?(x)
     OR add?(x)} ->
   RealExpr]" IntervalExpr_adt interval_arith) (brel? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr_ADD_extensionality formula-decl nil IntervalExpr_adt interval_arith) (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]" IntervalExpr_adt interval_arith) (expr2 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (TRUE const-decl "bool" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (VARIDX adt-constructor-decl "[nat -> (varidx?)]" IntervalExpr_adt interval_arith) (IntervalExpr_VARIDX_extensionality formula-decl nil IntervalExpr_adt interval_arith) (opc adt-accessor-decl "[(const?) -> [Unit -> real]]" IntervalExpr_adt interval_arith) (IntervalExpr_CONST_extensionality formula-decl nil IntervalExpr_adt interval_arith) (CONST adt-constructor-decl "[[opc: [Unit -> real], (Includes?(opc(unit)))] -> (const?)]" IntervalExpr_adt interval_arith) (unit adt-constructor-decl "(unit?)" Unit_adt structures) (unit? adt-recognizer-decl "[Unit -> boolean]" Unit_adt structures) (Includes? const-decl "bool" interval interval_arith) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Unit type-decl nil Unit_adt structures) (IntervalExpr_induction formula-decl nil IntervalExpr_adt interval_arith) (= const-decl "[T, T -> boolean]" equalities nil) (cache_eq inductive-decl "bool" affine_expr_Eval_fnd nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith)) shostak)) (cache_get_TCC1 0 (cache_get_TCC1-1 nil 3631365124 ("" (termination-tcc) nil nil) nil nil (cache_get subtype "Maybe[AffineCombination].None" "{res: Maybe[AffineCombination].Maybe | booleans.IMPLIES(Maybe[AffineCombination].some?(res), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): booleans.AND(list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i)`1 = affine_expr_Eval_fnd.re, list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i)`2 = Maybe[AffineCombination].val(res)))}"))) (cache_get_TCC2 0 (cache_get_TCC2-2 "" 3803764425 ("" (skeep*) (("" (lemma "cache_eq_sound") (("" (inst?) (("" (assert) (("" (inst 1 "0") (("1" (expand "nth") (("1" (replace -1 :dir RL) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak (cache_get subtype "Maybe[AffineCombination].Some(affine_expr_Eval_fnd.h`2)" "{res: Maybe[AffineCombination].Maybe | booleans.IMPLIES(Maybe[AffineCombination].some?(res), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): booleans.AND(list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i)`1 = affine_expr_Eval_fnd.re, list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i)`2 = Maybe[AffineCombination].val(res)))}")) (cache_get_TCC2-1 nil 3631366154 ("" (skeep*) (("" (lemma "cache_eq_sound") (("" (inst?) (("" (assert) (("" (hide -2) (("" (inst 1 "0") (("1" (expand "nth") (("1" (replace -1 :dir RL) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cache_eq_sound formula-decl nil affine_expr_Eval_fnd nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (cache skolem-const-decl "list[CacheData]" affine_expr_Eval_fnd nil) (length def-decl "nat" list_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cache_get subtype "Maybe[AffineCombination].Some(affine_expr_Eval_fnd.h`2)" "{res: Maybe[AffineCombination].Maybe | booleans.IMPLIES(Maybe[AffineCombination].some?(res), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): booleans.AND(list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i)`1 = affine_expr_Eval_fnd.re, list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i)`2 = Maybe[AffineCombination].val(res)))}"))) (cache_get_TCC3 0 (cache_get_TCC3-1 nil 3631366154 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil (cache_get termination "affine_expr_Eval_fnd.cache_get(affine_expr_Eval_fnd.t)" "nil"))) (cache_get_TCC4 0 (cache_get_TCC4-1 nil 3631366154 ("" (skeep*) (("" (typepred "v(t)(re)") (("" (assert) (("" (skeep) (("" (inst 2 "i+1") (("1" (replace -3) (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((val adt-accessor-decl "[(some?) -> T]" Maybe structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (cache skolem-const-decl "list[CacheData]" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(t))" affine_expr_Eval_fnd nil) (t skolem-const-decl "list[CacheData]" affine_expr_Eval_fnd nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cache_get subtype "affine_expr_Eval_fnd.cache_get(affine_expr_Eval_fnd.t)(affine_expr_Eval_fnd.re)" "{res: Maybe[AffineCombination].Maybe | booleans.IMPLIES(Maybe[AffineCombination].some?(res), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): booleans.AND(list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i)`1 = affine_expr_Eval_fnd.re, list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i)`2 = Maybe[AffineCombination].val(res)))}"))) (cache_get_powvar_TCC1 0 (cache_get_powvar_TCC1-1 nil 3631466640 ("" (subtype-tcc) nil nil) ((powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil)) nil (cache_get_powvar subtype "Maybe[CacheData].None" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}"))) (cache_get_powvar_TCC2 0 (cache_get_powvar_TCC2-1 nil 3631466640 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (powvar? const-decl "bool" affine_expr nil)) nil (cache_get_powvar termination "affine_expr_Eval_fnd.cache_get_powvar(affine_expr_Eval_fnd.t)" "nil"))) (cache_get_powvar_TCC3 0 (cache_get_powvar_TCC3-1 nil 3631466640 ("" (skeep*) (("" (typepred "v(t)(re)") (("" (assert) (("" (flatten) (("" (assert) (("" (skeep) (("" (inst 2 "i+1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (cache skolem-const-decl "list[CacheData]" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(t))" affine_expr_Eval_fnd nil) (t skolem-const-decl "list[CacheData]" affine_expr_Eval_fnd nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (cache_get_powvar subtype "affine_expr_Eval_fnd.cache_get_powvar(affine_expr_Eval_fnd.t)(affine_expr_Eval_fnd.re)" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}"))) (cache_get_powvar_TCC4 0 (cache_get_powvar_TCC4-1 nil 3631466640 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil)) nil (cache_get_powvar termination "affine_expr_Eval_fnd.cache_get_powvar(affine_expr_Eval_fnd.t)" "nil"))) (cache_get_powvar_TCC5 0 (cache_get_powvar_TCC5-2 nil 3637320258 ("" (skeep*) (("" (typepred "v(t)(re)") (("" (assert) (("" (flatten) (("" (assert) (("" (skeep) (("" (inst 2 "i+1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (cache skolem-const-decl "list[CacheData]" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(t))" affine_expr_Eval_fnd nil) (t skolem-const-decl "list[CacheData]" affine_expr_Eval_fnd nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cache_get_powvar subtype "affine_expr_Eval_fnd.cache_get_powvar(affine_expr_Eval_fnd.t)(affine_expr_Eval_fnd.re)" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}")) (cache_get_powvar_TCC5-1 nil 3631466640 ("" (termination-tcc) nil nil) nil nil (cache_get_powvar subtype "affine_expr_Eval_fnd.cache_get_powvar(affine_expr_Eval_fnd.t)(affine_expr_Eval_fnd.re)" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}"))) (cache_get_powvar_TCC6 0 (cache_get_powvar_TCC6-1 nil 3631466640 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil)) shostak (cache_get_powvar subtype "affine_expr_Eval_fnd.h`1" "(IntervalExpr_adt.pow?)"))) (cache_get_powvar_TCC7 0 (cache_get_powvar_TCC8-1 nil 3631466640 ("" (skeep*) (("" (assert) (("" (inst 1 "0") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (length def-decl "nat" list_props nil) (cache skolem-const-decl "list[CacheData]" affine_expr_Eval_fnd nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cache_get_powvar subtype "Maybe[CacheData].Some(affine_expr_Eval_fnd.h)" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}"))) (cache_get_powvar_TCC8 0 (cache_get_powvar_TCC8-1 "" 3789917494 ("" (skeep*) (("" (assert) (("" (grind) nil nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (cache_get_powvar termination "affine_expr_Eval_fnd.cache_get_powvar(affine_expr_Eval_fnd.t)" "nil")) (cache_get_powvar_TCC9-1 nil 3631466640 ("" (skeep*) (("" (assert) (("" (inst 2 "0") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((ge_realorder name-judgement "RealOrder" real_orders reals) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil)) shostak (cache_get_powvar termination "affine_expr_Eval_fnd.cache_get_powvar(affine_expr_Eval_fnd.t)" "nil"))) (cache_get_powvar_TCC9 0 (cache_get_powvar_TCC9-1 "" 3789917494 ("" (skeep*) (("" (assert) nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (cache_get_powvar subtype "affine_expr_Eval_fnd.nextresult" "(Maybe[CacheData].some?)")) (cache_get_powvar_TCC10-1 nil 3631466640 ("" (skeep*) (("" (assert) (("" (typepred "nextresult") (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((ge_realorder name-judgement "RealOrder" real_orders reals)) shostak (cache_get_powvar subtype "affine_expr_Eval_fnd.nextresult" "(Maybe[CacheData].some?)"))) (cache_get_powvar_TCC10 0 (cache_get_powvar_TCC11-2 nil 3767012435 ("" (skeep*) (("" (assert) (("" (typepred "nextresult") (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (varidx_powvar const-decl "nat" affine_expr nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cache_get_powvar subtype "Maybe[CacheData].val(affine_expr_Eval_fnd.nextresult)`1" "(IntervalExpr_adt.pow?)")) (cache_get_powvar_TCC11-1 nil 3631466640 ("" (skeep*) (("" (assert) (("" (inst 2 "0") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((ge_realorder name-judgement "RealOrder" real_orders reals) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (lt_realorder name-judgement "RealOrder" real_orders reals)) shostak (cache_get_powvar subtype "Maybe[CacheData].val(affine_expr_Eval_fnd.nextresult)`1" "(IntervalExpr_adt.pow?)"))) (cache_get_powvar_TCC11 0 (cache_get_powvar_TCC12-2 nil 3767012422 ("" (skeep*) (("" (assert) (("" (inst 2 "0") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (below type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (length def-decl "nat" list_props nil) (cache skolem-const-decl "list[CacheData]" affine_expr_Eval_fnd nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cache_get_powvar subtype "Maybe[CacheData].Some(affine_expr_Eval_fnd.h)" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}")) (cache_get_powvar_TCC12-1 nil 3631554556 ("" (skeep*) (("" (assert) (("" (typepred "nextresult") (("" (assert) (("" (flatten) (("" (assert) (("" (skeep) (("" (inst 4 "i+1") (("1" (grind) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (varidx_powvar const-decl "nat" affine_expr nil)) nil (cache_get_powvar subtype "Maybe[CacheData].Some(affine_expr_Eval_fnd.h)" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}"))) (cache_get_powvar_TCC12 0 (cache_get_powvar_TCC13-2 nil 3767012408 ("" (skeep*) (("" (assert) (("" (typepred "nextresult") (("" (assert) (("" (flatten) (("" (assert) (("" (skeep) (("" (inst 4 "i+1") (("1" (grind) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (t skolem-const-decl "list[CacheData]" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(t))" affine_expr_Eval_fnd nil) (cache skolem-const-decl "list[CacheData]" affine_expr_Eval_fnd nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (varidx_powvar const-decl "nat" affine_expr nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (cache_get_powvar subtype "affine_expr_Eval_fnd.nextresult" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}")) (cache_get_powvar_TCC13-1 nil 3631554556 ("" (termination-tcc) nil nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (ge_realorder name-judgement "RealOrder" real_orders reals) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil)) nil (cache_get_powvar subtype "affine_expr_Eval_fnd.nextresult" "{res: Maybe[CacheData].Maybe | booleans.IMPLIES(Maybe[CacheData].some?(res), booleans.AND(affine_expr.powvar?(Maybe[CacheData].val(res)`1), booleans.AND(affine_expr.varidx_powvar(Maybe[CacheData].val(res)`1) = affine_expr.varidx_powvar(affine_expr_Eval_fnd.re), EXISTS (i: naturalnumbers.below(list_props[CacheData].length(affine_expr_Eval_fnd.cache))): list_props[CacheData].nth(affine_expr_Eval_fnd.cache, i) = Maybe[CacheData].val(res))))}"))) (cache_powvar_correct_result 0 (cache_powvar_correct_result-1 nil 3632140157 ("" (skeep) (("" (assert) (("" (flatten) (("" (typepred "cache_get_powvar(cache)(re)") (("" (assert) (("" (flatten) (("" (skeep) (("" (use "cache_powvar_correct") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cache_get_powvar def-decl "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" affine_expr_Eval_fnd nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (cache_powvar_correct formula-decl nil affine_expr_Eval_fnd nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)) shostak)) (RE2AC_TCC1 0 (RE2AC_TCC1-1 nil 3631293338 ("" (subtype-tcc) nil nil) nil nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(affine_expr_Eval_fnd.result)`2" "(list_adt[CacheData].cons?)"))) (RE2AC_TCC2 0 (RE2AC_TCC2-3 "" 3789917499 ("" (lemma "well_founded_restrict[IntervalExpr, RealExpr]") (("" (inst?) (("" (expand "well_founded?") (("" (propax) nil nil)) nil)) nil)) nil) ((<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith) (strict_well_founded? const-decl "bool" orders nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (well_founded_restrict judgement-tcc nil restrict_order_props nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith)) shostak (RE2AC well-founded "restrict[[IntervalExpr_adt.IntervalExpr, IntervalExpr_adt.IntervalExpr], [RealExpr, RealExpr], booleans.bool].restrict(IntervalExpr_adt.<<)" "nil")) (RE2AC_TCC2-2 nil 3637320866 ("" (then (lemma "well_founded_restrict[IntervalExpr, RealExpr]") (inst?) (expand "well_founded?") (propax)) nil nil) ((RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith)) nil (RE2AC well-founded "restrict[[IntervalExpr_adt.IntervalExpr, IntervalExpr_adt.IntervalExpr], [RealExpr, RealExpr], booleans.bool].restrict(IntervalExpr_adt.<<)" "nil")) (RE2AC_TCC2-1 nil 3631293338 ("" (lemma "well_founded_restrict[AffineExpr, RealExpr]") (("" (inst?) (("" (expand "well_founded?") (("" (propax) nil nil)) nil)) nil)) nil) nil nil (RE2AC well-founded "restrict[[IntervalExpr_adt.IntervalExpr, IntervalExpr_adt.IntervalExpr], [RealExpr, RealExpr], booleans.bool].restrict(IntervalExpr_adt.<<)" "nil"))) (RE2AC_TCC3 0 (RE2AC_TCC3-1 "" 3789917499 ("" (skeep*) (("" (assert) (("" (hide -1) (("" (grind) nil nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC4-2 nil 3632065384 ("" (then (skeep*) (assert) (replaces -1) (replaces -1) (hide -1) (assert) (spread (split 1) ((spread (inst 1 "(:(CONST(opc, opC), const_ac(opc(unit)), null):)") ((grind) (grind) (grind))) (then (typepred "cache") (expand "compatible_pairs?") (skeep) (inst 1 "N") (assert) (expand "compatible_pairs_on?") (skeep) (spread (case "i=0") ((then (hide-all-but (-1 1)) (replaces -1) (grind) (expand "eval_pd_noise") (grind)) (then (name "j" "i-1") (spread (case "j< length(cache)") ((then (expand "nth" 2) (assert) (skeep) (replace -2) (inst -5 "j") (inst -5 "n")) (then (hide (3 -4)) (typepred "i") (expand "length" -1) (assert)))))))) (then (typepred "cache") (expand "idxs_bounded") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth") (typepred "nextfreeidx") (typepred "opC") (replaces -1) (expand "next_idx") (expand "const_ac") (hide-all-but (1 -1)) (grind)) (then (expand "nth" 2) (assert) (inst -3 "i-1")))))))) nil nil) ((ordered_list? def-decl "bool" ordered_list structures)) nil (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC4-1 nil 3631293338 ("" (skeep) (("" (assert) (("" (expand "compatible_pairs?") (("" (typepred "cache") (("" (expand "compatible_pairs?") (("" (skeep) (("" (inst 1 "N") (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (Interval type-eq-decl nil interval interval_arith) (BaseType type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC4 0 (RE2AC_TCC4-1 "" 3789917500 ("" (skeep*) (("" (assert) (("" (replaces (-1 -2)) (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((empty_ErrorTerms const-decl "ErrorTerms" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (const_ac const-decl "AffineCombination" affine nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (/= const-decl "boolean" notequal nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length def-decl "nat" list_props nil) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (nth def-decl "T" list_props nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC5-1 nil 3631294584 ("" (then (skeep*) (assert) (replaces (-1 -2)) (replace -1) (assert) (hide -2) (spread (split 2) ((then (inst 1 "(:car(result`2):)") (grind)) (then (typepred "cache") (expand "compatible_pairs?") (skeep) (inst 1 "N") (spread (split 1) ((propax) (then (expand "compatible_pairs_on?") (skeep :preds? t) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (expand "vars_in_box_compatible?") (expand "eval_ACExpr_Env" 1) (inst -2 "varidx") (flatten) (replaces -2 :dir RL) (expand "nth_ac" 1) (propax)) (then (expand "nth" 2) (assert) (inst -3 "i-1")))))))) (then (expand "idxs_bounded") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth") (expand "nth_ac") (hide -1) (expand "var_ac") (typepred "nextfreeidx") (spread (case "null?(box)") ((grind) (grind)))) (then (typepred "cache") (expand "idxs_bounded") (spread (inst -2 "i-1") ((then (expand "nth" 2) (assert)) (then (typepred "i") (grind))))))))))) nil nil) ((null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (const_ac const-decl "AffineCombination" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC5 0 (RE2AC_TCC5-1 "" 3789917502 ("" (skeep*) (("" (assert) (("" (replaces -1) (("" (replaces -1) (("" (hide -1) (("" (assert) (("" (split 1) (("1" (inst 1 "(:(CONST(opc, opC), const_ac(opc(unit)), null):)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (typepred "cache") (("2" (expand "compatible_pairs?") (("2" (skeep) (("2" (inst 1 "N") (("2" (assert) (("2" (expand "compatible_pairs_on?") (("2" (skeep) (("2" (case "i=0") (("1" (hide-all-but (-1 1)) (("1" (replaces -1) (("1" (grind) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (name "j" "i-1") (("2" (case "j< length(cache)") (("1" (expand "nth" 2) (("1" (assert) (("1" (skeep) (("1" (replace -2) (("1" (inst -5 "j") (("1" (inst -5 "n") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (3 -4)) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "cache") (("3" (expand "idxs_bounded") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth") (("1" (typepred "nextfreeidx") (("1" (typepred "opC") (("1" (expand "next_idx") (("1" (expand "const_ac") (("1" (hide-all-but (1 -1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst -3 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((next_idx const-decl "nat" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (last_idx const-decl "int" indexed_list structures) (|##| const-decl "bool" interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (eval def-decl "real" interval_expr interval_arith) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (nth def-decl "T" list_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (eval_pd_noise def-decl "real" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (Unit type-decl nil Unit_adt structures) (Interval type-eq-decl nil interval interval_arith) (Includes? const-decl "bool" interval interval_arith) (unit? adt-recognizer-decl "[Unit -> boolean]" Unit_adt structures) (unit adt-constructor-decl "(unit?)" Unit_adt structures) (CONST adt-constructor-decl "[[opc: [Unit -> real], (Includes?(opc(unit)))] -> (const?)]" IntervalExpr_adt interval_arith) (const_ac const-decl "AffineCombination" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (append def-decl "list[T]" list_props nil) ({\|\|} const-decl "AffineCombination" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC6-3 nil 3767012201 ("" (skeep*) (("" (assert) (("" (replaces -1) (("" (replaces -1) (("" (hide -1) (("" (assert) (("" (split 1) (("1" (inst 1 "(:(CONST(opc, opC), const_ac(opc(unit)), null):)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (typepred "cache") (("2" (expand "compatible_pairs?") (("2" (skeep) (("2" (inst 1 "N") (("2" (assert) (("2" (expand "compatible_pairs_on?") (("2" (skeep) (("2" (case "i=0") (("1" (hide-all-but (-1 1)) (("1" (replaces -1) (("1" (grind) (("1" (expand "eval_pd_noise") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (name "j" "i-1") (("2" (case "j< length(cache)") (("1" (expand "nth" 2) (("1" (assert) (("1" (skeep) (("1" (replace -2) (("1" (inst -5 "j") (("1" (inst -5 "n") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (3 -4)) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "cache") (("3" (expand "idxs_bounded") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth") (("1" (typepred "nextfreeidx") (("1" (typepred "opC") (("1" (replaces -1) (("1" (expand "next_idx") (("1" (expand "const_ac") (("1" (hide-all-but (1 -1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst -3 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((next_idx const-decl "nat" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (last_idx const-decl "int" indexed_list structures) (|##| const-decl "bool" interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (Box type-eq-decl nil box interval_arith) (lt_realorder name-judgement "RealOrder" real_orders reals) (pow_var_compatible? const-decl "bool" affine_pow nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (eval def-decl "real" interval_expr interval_arith) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (eval_pd_noise def-decl "real" affine nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (Unit type-decl nil Unit_adt structures) (Interval type-eq-decl nil interval interval_arith) (Includes? const-decl "bool" interval interval_arith) (unit? adt-recognizer-decl "[Unit -> boolean]" Unit_adt structures) (unit adt-constructor-decl "(unit?)" Unit_adt structures) (CONST adt-constructor-decl "[[opc: [Unit -> real], (Includes?(opc(unit)))] -> (const?)]" IntervalExpr_adt interval_arith) (const_ac const-decl "AffineCombination" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC6-2 nil 3767011439 ("" (skeep*) (("" (replaces -1) (("" (replaces -2) (("" (assert) (("" (split 2) (("1" (inst 1 "(:(VARIDX(varidx), ac, null):)") (("1" (expand "append") (("1" (grind) nil))) ("2" (grind) nil) ("3" (grind) nil))) ("2" (typepred "cache") (("2" (expand "compatible_pairs?") (("2" (skeep) (("2" (inst 1 "N") (("2" (assert) (("2" (expand "compatible_pairs_on?" 1) (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env") (("1" (expand "vars_in_box_compatible?") (("1" (inst?) (("1" (flatten) (("1" (replaces -6) (("1" (expand "nth_ac") (("1" (propax) nil))))))))))))))))))) ("2" (expand "compatible_pairs_on?") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) (("2" (typepred "i") (("2" (assert) (("2" (grind) nil))))))))))))))))))))))))))))) ("3" (hide -2) (("3" (typepred "cache") (("3" (expand "idxs_bounded" 1) (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (replaces -6) (("1" (expand "nth_ac") (("1" (assert) nil))))))))))))) ("2" (expand "idxs_bounded" -2) (("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) nil))))))))))))))))) ("4" (expand "correct_cache?") (("4" (typepred "cache") (("4" (expand "CacheData_correct?") (("4" (propax) nil)))))))))))))))) nil) nil nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC6-1 nil 3631294584 ("" (grind) nil nil) ((ordered_list? def-decl "bool" ordered_list structures)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC6 0 (RE2AC_TCC6-1 "" 3789917503 ("" (skeep*) (("" (replaces -1) (("" (replaces -2) (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC7-1 nil 3631294584 ("" (skeep*) (("" (replaces -1) (("" (replaces -2) (("" (assert) (("" (split 2) (("1" (inst 1 "(:(VARIDX(varidx), ac, null):)") (("1" (expand "append") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ("2" (typepred "cache") (("2" (expand "compatible_pairs?") (("2" (skeep) (("2" (inst 1 "N") (("2" (assert) (("2" (expand "compatible_pairs_on?" 1) (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env") (("1" (expand "vars_in_box_compatible?") (("1" (inst?) (("1" (flatten) (("1" (replaces -6) (("1" (expand "nth_ac") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) (("2" (typepred "i") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -2) (("3" (typepred "cache") (("3" (expand "idxs_bounded" 1) (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (replaces -6) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "idxs_bounded" -2) (("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "correct_cache?") (("4" (typepred "cache") (("4" (expand "CacheData_correct?") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures)) nil (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC7 0 (RE2AC_TCC7-1 "" 3789917504 ("" (skeep*) (("" (assert) (("" (grind) nil nil)) nil)) nil) ((powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (length def-decl "nat" list_props nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (nth def-decl "T" list_props nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC8-1 nil 3631295747 ("" (skeep*) (("" (assert) (("" (split 1) (("1" (grind) nil nil) ("2" (replace -4 1) (("2" (assert) (("2" (inst 1 "(:car(result`2):)") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (typepred "cache") (("3" (expand "compatible_pairs?") (("3" (skeep) (("3" (inst 1 "N") (("3" (assert) (("3" (replace -8 1) (("3" (assert) (("3" (expand "compatible_pairs_on?") (("3" (skeep) (("3" (skeep) (("3" (expand "nth" 1) (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (typepred "cache_get(cache)(re)") (("1" (assert) (("1" (skeep) (("1" (inst? :subst ("i" "i!1" "n" "n")) (("1" (assert) (("1" (expand "powvar?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (typepred "i") (("2" (inst? :subst ("i" "i - 1" "n" "n")) (("1" (expand "length" -1) (("1" (assert) nil nil)) nil) ("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -5) (("4" (replace -4) (("4" (assert) (("4" (typepred "cache") (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace -6) (("1" (typepred "cache_get(cache)(re)") (("1" (assert) (("1" (skeep) (("1" (inst? :subst ("i" "i!1")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst? :subst ("i" "i-1")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC8 0 (RE2AC_TCC9-4 nil 3767012646 ("" (skeep*) (("" (assert) (("" (split 1) (("1" (grind) nil nil) ("2" (replace -4 1) (("2" (assert) (("2" (inst 1 "(:car(result`2):)") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (typepred "cache") (("3" (expand "compatible_pairs?") (("3" (skeep) (("3" (inst 1 "N") (("3" (assert) (("3" (replace -8 1) (("3" (assert) (("3" (expand "compatible_pairs_on?") (("3" (skeep) (("3" (skeep) (("3" (expand "nth" 1) (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (typepred "cache_get(cache)(re)") (("1" (assert) (("1" (skeep) (("1" (inst? :subst ("i" "i!1" "n" "n")) (("1" (assert) (("1" (expand "powvar?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (typepred "i") (("2" (inst? :subst ("i" "i - 1" "n" "n")) (("1" (expand "length" -1) (("1" (assert) nil nil)) nil) ("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -5) (("4" (replace -4) (("4" (assert) (("4" (typepred "cache") (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace -6) (("1" (typepred "cache_get(cache)(re)") (("1" (assert) (("1" (skeep) (("1" (inst? :subst ("i" "i!1")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst? :subst ("i" "i-1")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (NOT const-decl "[bool -> bool]" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (nth def-decl "T" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (cache_get def-decl "{res: Maybe[AffineCombination] |
   some?(res) IMPLIES
    EXISTS (i: below(length(cache))):
      nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res)}" affine_expr_Eval_fnd nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (eval def-decl "real" interval_expr interval_arith) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (powvar? const-decl "bool" affine_expr nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (re skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (cached skolem-const-decl "{res: Maybe[AffineCombination] |
   some?(res) IMPLIES
    EXISTS (i: below(length(cache))):
      nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res)}" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(cons((re, val(cached), null), cache)))" affine_expr_Eval_fnd nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (> const-decl "bool" reals nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (append def-decl "list[T]" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC9-3 nil 3638025920 ("" (grind) nil nil) ((empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC9-2 nil 3632065729 ("" (skeep*) (("" (replaces -1) (("" (replaces -2) (("" (assert) (("" (split 2) (("1" (inst 1 "(:(VARIDX(varidx), ac, null):)") (("1" (expand "append") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ("2" (typepred "cache") (("2" (expand "compatible_pairs?") (("2" (skeep) (("2" (inst 1 "N") (("2" (assert) (("2" (expand "compatible_pairs_on?" 1) (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth" 1) (("1" (expand "powvar?") (("1" (expand "eval_ACExpr_Env") (("1" (expand "eval") (("1" (expand "vars_in_box_compatible?") (("1" (inst?) (("1" (flatten) (("1" (replaces -6) (("1" (expand "nth_ac") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) (("2" (typepred "i") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -2) (("3" (typepred "cache") (("3" (expand "idxs_bounded" 1) (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (replaces -6) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "idxs_bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ge_realorder name-judgement "RealOrder" real_orders reals) (last_idx_box formula-decl nil affine_box nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (lt_realorder name-judgement "RealOrder" real_orders reals) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (nth_ac const-decl "AffineCombination" affine_box nil) (eval def-decl "real" interval_expr interval_arith) (powvar? const-decl "bool" affine_expr nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (ordered_list type-eq-decl nil ordered_list structures) (VARIDX adt-constructor-decl "[nat -> (varidx?)]" IntervalExpr_adt interval_arith)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC9-1 nil 3631295747 ("" (termination-tcc) nil nil) ((var_ac const-decl "AffineCombination" affine nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC9 0 (RE2AC_TCC9-1 "" 3789917507 ("" (skeep*) (("" (assert) nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC3-1 nil 3631293338 ("" (then (skeep*) (assert) (replaces -1) (replaces -1) (hide -1) (assert) (spread (split 1) ((spread (inst 1 "(:(CONST(opc, opC), opC, null):)") ((grind) (grind) (grind))) (then (typepred "cache") (expand "compatible_pairs?") (skeep) (inst 1 "N") (assert) (expand "compatible_pairs_on?") (skeep) (spread (case "i=0") ((then (hide-all-but (-1 1)) (replaces -1) (grind) (typepred "opC") (grind) (expand "eval_pd_noise") (grind)) (then (name "j" "i-1") (spread (case "j< length(cache)") ((then (expand "nth" 2) (assert) (replace -2) (grind)) (grind))))))) (then (typepred "cache") (expand "idxs_bounded") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth") (typepred "nextfreeidx") (typepred "opC") (replaces -1) (expand "next_idx") (expand "const_ac") (hide-all-but (1 -1)) (grind)) (then (expand "nth" 2) (assert) (inst -2 "i-1"))))) (then (typepred "cache") (hide -1 -2) (expand "correct_cache?" 1) (hide -1) (expand "CacheData_correct?") (propax))))) nil nil) ((ge_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC10 0 (RE2AC_TCC10-1 nil 3631295747 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.varidx" "{i | reals.<(affine_box.i, list_props[Interval].length(affine_expr_Eval_fnd.box))}"))) (RE2AC_TCC11 0 (RE2AC_TCC11-2 "" 3789917508 ("" (skeep*) (("" (replaces -1) (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil) ((/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (ordered_list? def-decl "bool" ordered_list structures) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC11-1 nil 3631295747 ("" (then (skeep*) (replaces -1) (replaces -2) (assert) (spread (split 2) ((spread (inst 1 "(:(VARIDX(varidx), ac, null):)") ((then (expand "append") (grind)) (grind) (grind))) (then (typepred "cache") (expand "compatible_pairs?") (skeep) (inst 1 "N") (assert) (expand "compatible_pairs_on?" 1) (skeep) (spread (case "i=0") ((then (replaces -1) (assert) (expand "nth" 1) (expand "eval_ACExpr_Env") (expand "vars_in_box_compatible?") (inst?) (flatten) (replaces -6) (expand "nth_ac") (propax)) (then (expand "compatible_pairs_on?") (expand "nth" 2) (assert) (inst?) (typepred "i") (assert) (grind))))) (then (hide -2) (typepred "cache") (expand "idxs_bounded" 1) (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (typepred "nextfreeidx") (use "last_idx_box") (replaces -6) (expand "nth_ac") (assert)) (then (expand "idxs_bounded" -2) (expand "nth" 2) (assert) (inst?))))) (then (expand "correct_cache?") (typepred "cache") (expand "CacheData_correct?") (propax))))) nil nil) ((ge_realorder name-judgement "RealOrder" real_orders reals) (ordered_list? def-decl "bool" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil)) nil (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC12 0 (RE2AC_TCC12-1 nil 3631295747 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (last_ol def-decl "T" ordered_list structures) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC13 0 (RE2AC_TCC13-2 "" 3789917511 ("" (skeep*) (("" (replaces -1) (("" (replaces -3) (("" (assert) (("" (split 3) (("1" (inst 1 "(:(VARIDX(varidx), ac, null):)") (("1" (expand "append") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (typepred "cache") (("2" (expand "compatible_pairs?") (("2" (skeep) (("2" (inst 1 "N") (("2" (assert) (("2" (expand "compatible_pairs_on?" 1) (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth" 1) (("1" (expand "powvar?") (("1" (expand "eval_ACExpr_Env") (("1" (expand "eval") (("1" (expand "vars_in_box_compatible?") (("1" (inst?) (("1" (flatten) (("1" (replaces -7) (("1" (expand "nth_ac") (("1" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) (("2" (typepred "i") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -3) (("3" (typepred "cache") (("3" (expand "idxs_bounded" 1) (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (replaces -6) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "idxs_bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (last_idx_box formula-decl nil affine_box nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (NOT const-decl "[bool -> bool]" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (i skolem-const-decl "below(length(cons((VARIDX(varidx), ac, null), cache)))" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (ac skolem-const-decl "AffineCombination" affine_expr_Eval_fnd nil) (varidx skolem-const-decl "nat" affine_expr_Eval_fnd nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nth def-decl "T" list_props nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (nth_ac const-decl "AffineCombination" affine_box nil) (eval def-decl "real" interval_expr interval_arith) (powvar? const-decl "bool" affine_expr nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (VARIDX adt-constructor-decl "[nat -> (varidx?)]" IntervalExpr_adt interval_arith) (append def-decl "list[T]" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC13-1 nil 3631295747 ("" (skeep*) (("" (replaces -1) (("" (replaces -3) (("" (assert) (("" (split 3) (("1" (inst 1 "(:(VARIDX(varidx), ac, null):)") (("1" (expand "append") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ("2" (typepred "cache") (("2" (expand "compatible_pairs?") (("2" (skeep) (("2" (inst 1 "N") (("2" (assert) (("2" (expand "compatible_pairs_on?" 1) (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth" 1) (("1" (expand "powvar?") (("1" (expand "eval_ACExpr_Env") (("1" (expand "eval") (("1" (expand "vars_in_box_compatible?") (("1" (inst?) (("1" (flatten) (("1" (replaces -7) (("1" (expand "nth_ac") (("1" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) (("2" (typepred "i") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -3) (("3" (typepred "cache") (("3" (expand "idxs_bounded" 1) (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (replaces -6) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "idxs_bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ge_realorder name-judgement "RealOrder" real_orders reals) (last_idx_box formula-decl nil affine_box nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (nth_ac const-decl "AffineCombination" affine_box nil) (eval def-decl "real" interval_expr interval_arith) (powvar? const-decl "bool" affine_expr nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (VARIDX adt-constructor-decl "[nat -> (varidx?)]" IntervalExpr_adt interval_arith)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC14 0 (RE2AC_TCC14-2 nil 3767016208 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (restrict const-decl "R" restrict nil)) nil (RE2AC termination "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re1, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.nextfreeidx, affine_expr_Eval_fnd.cache)" "nil")) (RE2AC_TCC14-1 nil 3631295747 ("" (then (skeep*) (typepred "res1") (assert) (flatten) (spread (split 3) ((then (expand "compatible_pairs?") (skeep -3) (inst 1 "N") (assert)) (then (replace -9 :dir RL) (assert))))) nil nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil)) nil (RE2AC termination "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re1, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.nextfreeidx, affine_expr_Eval_fnd.cache)" "nil"))) (RE2AC_TCC15 0 (RE2AC_TCC15-1 nil 3789916158 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length_singleton formula-decl nil more_list_props structures) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC16 0 (RE2AC_TCC16-1 "" 3789917514 ("" (skeep*) (("" (typepred "res1") (("" (assert) nil nil)) nil)) nil) ((compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)")) (RE2AC_TCC15-2 nil 3632066118 ("" (then (skeep*) (typepred "res1") (assert) (replaces -5 :dir RL) (flatten) (assert) (expand "compatible_pairs?" 3) (propax)) nil nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)")) (RE2AC_TCC15-1 nil 3631300447 ("" (grind) nil nil) ((var_ac const-decl "AffineCombination" affine nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)"))) (RE2AC_TCC17 0 (RE2AC_TCC17-1 "" 3789917516 ("" (skeep*) (("" (typepred "res1") (("" (assert) nil nil)) nil)) nil) ((compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.cache1" "(list_adt[CacheData].cons?)")) (RE2AC_TCC16-1 nil 3631300447 ("" (then (skeep*) (replaces -1) (typepred "res1") (assert) (replaces -5 :dir RL) (flatten) (assert) (expand "compatible_pairs?") (propax)) nil nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.cache1" "(list_adt[CacheData].cons?)"))) (RE2AC_TCC18 0 (RE2AC_TCC17-1 nil 3631300447 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box))}"))) (RE2AC_TCC19 0 (RE2AC_TCC19-1 "" 3789917519 ("" (skeep*) (("" (typepred "res1") (("" (assert) (("" (replaces -5 :dir RL) (("" (flatten) (("" (assert) (("" (expand "compatible_pairs?") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.cache1" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.newid1)(cache)}")) (RE2AC_TCC18-1 nil 3631359170 ("" (then (skeep*) (replaces -1) (typepred "res1") (assert) (replaces -5 :dir RL) (flatten) (assert) (expand "compatible_pairs?") (propax)) nil nil) ((ge_realorder name-judgement "RealOrder" real_orders reals) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.cache1" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.newid1)(cache)}"))) (RE2AC_TCC20 0 (RE2AC_TCC20-1 "" 3789917521 ("" (skeep*) (("" (assert) (("" (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten) (label "re2" -1) (label "cache2-form" -2) (label "N2" -3) (label "newid2-prop" -4) (label "cache2-idxs_bound" -5))) (("" (deftactic typepred_res1 nil (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten) (label "re1" -1) (label "cache1-form" -2) (label "N1" -3) (label "newid1-prop" -4) (label "cache1-idxs_bound" -5))) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((strict_order_restrict application-judgement "(strict_order?[S])" restrict_order_props nil) (well_founded_restrict application-judgement "(well_founded?[S])" restrict_order_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith) (restrict const-decl "R" restrict nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC termination "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re2, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.newid1, affine_expr_Eval_fnd.cache1)" "nil")) (RE2AC_TCC19-2 nil 3631632051 ("" (then (skeep*) (assert) (hide -11) (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (deftactic typepred_res2 nil (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten) (label "re2" -1) (label "cache2-form" -2) (label "N2" -3) (label "newid2-prop" -4) (label "cache2-idxs_bound" -5))) (deftactic typepred_res1 nil (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten) (label "re1" -1) (label "cache1-form" -2) (label "N1" -3) (label "newid1-prop" -4) (label "cache1-idxs_bound" -5))) (spread (split 3) ((grind) (then (replaces "result") (assert) (typepred_res1) (typepred_res2) (skolem "cache2-form" "l2") (skolem "cache1-form" "l1") (replace "cache1-form" "cache2-form") (replace "cache2-form" 3) (inst 3 "cons((re, add_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") (hide-all-but 3) (expand "append" 1 3) (use "append_assoc[CacheData]") (assert)) (then (typepred_res2) (skolem "N2" "N2") (with-labels (flatten) (("N2 vars in box comp" "N2 compatible pairs"))) (inst 2 "N2") (assert) (expand "compatible_pairs_on?") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 2) (replace "result") (assert) (expand "eval_ACExpr_Env" 2) (replaces "re") (assert) (use "containment_add") (assert) (hide 3) (spread (split 1) ((then (typepred_res1) (replaces "re1" :dir RL) (skolem "N1" "N1") (with-labels (flatten) (("N1 vars in box comp" "N1 compatible pairs"))) (spread (case "FORALL (i: below(length(cache1))):
                                                                                                                                         eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                          eval_ac_noise(nth(cache1, i)`2, N1)") ((then (replace "ac1") (spread (inst -1 "0") ((then (expand "nth" -1) (replaces -1) (expand "compatible_pairs_on?" "N1 compatible pairs") (spread (inst "N1 compatible pairs" "0") ((then (expand "nth" "N1 compatible pairs") (propax)) (then (expand "length") (assert))))) (then (expand "length") (assert))))) (then (expand "compatible_pairs_on?" "N1 compatible pairs") (skeep) (inst "N1 compatible pairs" "i!1") (replace "N1 compatible pairs" 1) (skolem "cache2-form" "l2") (replace "cache2-form" "N2 compatible pairs") (spread (inst "N2 compatible pairs" "length(l2)+i!1") ((spread (case "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") ((assert) (then (hide-all-but 1) (use "nth_append[CacheData]") (assert)))) (then (replace "cache2-form" 1) (use "length_append[CacheData]") (replaces -1) (assert)))))))) (spread (inst "N2 compatible pairs" "0") ((then (expand "nth" "N2 compatible pairs") (assert)) (then (expand "length") (assert))))))) (then (name "j" "i-1") (typepred "i") (expand "length") (expand "nth" 3) (assert) (replace -2) (replace "result") (assert) (inst "N2 compatible pairs" "j"))))) (then (replaces "result") (assert) (typepred_res2) (typepred_res1)) (then (replaces "result") (assert) (expand "idxs_bounded") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (use "next_idx_add_ac_ac") (expand ">=") (typepred_res2) (typepred_res1) (expand "idxs_bounded") (spread (inst "cache1-idxs_bound" "0") ((then (expand "nth" "cache1-idxs_bound") (replace "ac1" :dir RL) (spread (inst "cache2-idxs_bound" "0") ((then (expand "nth" "cache2-idxs_bound") (replace "ac2" :dir RL) (hide-all-but (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -11)) (expand "max") (lift-if -4) (spread (split -4) ((then (flatten) (expand ">=") (assert)) (then (flatten) (assert))))) (grind)))) (grind)))) (then (typepred_res2) (expand "idxs_bounded") (spread (inst "cache2-idxs_bound" "i-1") ((then (expand "nth" 3) (propax)) (then (typepred "i") (grind))))))))))) nil nil) ((<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith)) nil (RE2AC termination "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re2, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.newid1, affine_expr_Eval_fnd.cache1)" "nil")) (RE2AC_TCC19-1 nil 3631365124 ("" (termination-tcc) nil nil) ((Interval type-eq-decl nil interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (var_ac const-decl "AffineCombination" affine nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures)) nil (RE2AC termination "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re2, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.newid1, affine_expr_Eval_fnd.cache1)" "nil"))) (RE2AC_TCC21 0 (RE2AC_TCC21-1 nil 3789916158 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length_singleton formula-decl nil more_list_props structures) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC22 0 (RE2AC_TCC20-1 nil 3631365124 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "affine_expr_Eval_fnd.res2" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)"))) (RE2AC_TCC23 0 (RE2AC_TCC21-2 nil 3767016128 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.cache2" "(list_adt[CacheData].cons?)")) (RE2AC_TCC21-1 nil 3631365124 ("" (then (skeep*) (assert) (hide -11) (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (deftactic typepred_res2 nil (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten) (label "re2" -1) (label "cache2-form" -2) (label "N2" -3) (label "newid2-prop" -4) (label "cache2-idxs_bound" -5) (label "cache2 correct" -6))) (deftactic typepred_res1 nil (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten) (label "re1" -1) (label "cache1-form" -2) (label "N1" -3) (label "newid1-prop" -4) (label "cache1-idxs_bound" -5) (label "cache1 correct" -6))) (spread (split 3) ((grind) (then (replaces "result") (assert) (typepred_res1) (typepred_res2) (skolem "cache2-form" "l2") (skolem "cache1-form" "l1") (replace "cache1-form" "cache2-form") (replace "cache2-form" 3) (spread (inst 3 "cons((re, add_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") ((then (hide-all-but 3) (expand "append" 1 3) (use "append_assoc[CacheData]") (assert)) (grind)))) (then (typepred_res2) (skolem "N2" "N2") (with-labels (flatten) (("N2 vars in box comp" "N2 compatible pairs"))) (inst 2 "N2") (assert) (expand "compatible_pairs_on?") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 2) (replace "result") (assert) (expand "eval_ACExpr_Env" 2) (replaces "re") (assert) (use "containment_add") (assert) (hide 3) (spread (split 1) ((then (typepred_res1) (replaces "re1" :dir RL) (skolem "N1" "N1") (with-labels (flatten) (("N1 vars in box comp" "N1 compatible pairs"))) (spread (case "FORALL (i: below(length(cache1))):
                                                                                                                                                      eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                       eval_ac_noise(nth(cache1, i)`2, N1)") ((then (replace "ac1") (spread (inst -1 "0") ((then (expand "nth" -1) (replaces -1) (expand "compatible_pairs_on?" "N1 compatible pairs") (spread (inst "N1 compatible pairs" "0") ((then (expand "nth" "N1 compatible pairs") (propax)) (then (expand "length") (assert))))) (then (expand "length") (assert))))) (then (expand "compatible_pairs_on?" "N1 compatible pairs") (skeep) (inst "N1 compatible pairs" "i!1") (replace "N1 compatible pairs" 1) (skolem "cache2-form" "l2") (replace "cache2-form" "N2 compatible pairs") (spread (inst "N2 compatible pairs" "length(l2)+i!1") ((spread (case "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") ((assert) (then (hide-all-but 1) (use "nth_append[CacheData]") (assert)))) (then (replace "cache2-form" 1) (use "length_append[CacheData]") (replaces -1) (assert)))))))) (spread (inst "N2 compatible pairs" "0") ((then (expand "nth" "N2 compatible pairs") (assert)) (then (expand "length") (assert))))))) (then (name "j" "i-1") (typepred "i") (expand "length") (expand "nth" 3) (assert) (replace -2) (replace "result") (assert) (inst "N2 compatible pairs" "j"))))) (then (replaces "result") (assert) (typepred_res2) (typepred_res1)) (then (replaces "result") (assert) (expand "idxs_bounded") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (use "next_idx_add_ac_ac") (expand ">=") (typepred_res2) (typepred_res1) (expand "idxs_bounded") (spread (inst "cache1-idxs_bound" "0") ((then (expand "nth" "cache1-idxs_bound") (replace "ac1" :dir RL) (spread (inst "cache2-idxs_bound" "0") ((then (expand "nth" "cache2-idxs_bound") (replace "ac2" :dir RL) (hide-all-but (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -13)) (expand "max") (lift-if -4) (spread (split -4) ((then (flatten) (expand ">=") (assert)) (then (flatten) (assert))))) (grind)))) (grind)))) (then (typepred_res2) (expand "idxs_bounded") (spread (inst "cache2-idxs_bound" "i-1") ((then (expand "nth" 3) (propax)) (then (typepred "i") (grind)))))))) (then (replaces "result") (assert) (expand "correct_cache?" 1) (typepred_res2) (assert) (expand "CacheData_correct?") (propax))))) nil nil) nil nil (RE2AC subtype "affine_expr_Eval_fnd.cache2" "(list_adt[CacheData].cons?)"))) (RE2AC_TCC24 0 (RE2AC_TCC22-3 nil 3632067579 ("" (termination-tcc) nil nil) ((ordered_list? def-decl "bool" ordered_list structures)) nil (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC22-2 nil 3632066368 ("" (skeep*) (("" (assert) (("" (hide -11) (("" (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten) (label "re2" -1) (label "cache2-form" -2) (label "N2" -3) (label "newid2-prop" -4) (label "cache2-idxs_bound" -5) (label "cache2 correct" -6))) (("" (deftactic typepred_res1 nil (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten) (label "re1" -1) (label "cache1-form" -2) (label "N1" -3) (label "newid1-prop" -4) (label "cache1-idxs_bound" -5) (label "cache1 correct" -6))) (("" (split 3) (("1" (grind) nil) ("2" (replaces "result") (("2" (assert) (("2" (typepred_res1) (("2" (typepred_res2) (("2" (skolem "cache2-form" "l2") (("2" (skolem "cache1-form" "l1") (("2" (replace "cache1-form" "cache2-form") (("2" (replace "cache2-form" 3) (("2" (inst 3 "cons((re, add_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") (("1" (hide-all-but 3) (("1" (expand "append" 1 3) (("1" (use "append_assoc[CacheData]") (("1" (assert) nil))))))) ("2" (grind) nil))))))))))))))))))) ("3" (typepred_res2) (("3" (skolem "N2" "N2") (("3" (with-labels (flatten) (("N2 vars in box comp" "N2 compatible pairs"))) (("3" (inst 2 "N2") (("3" (assert) (("3" (expand "compatible_pairs_on?") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 2) (("1" (replace "result") (("1" (assert) (("1" (expand "eval_ACExpr_Env" 2) (("1" (replaces "re") (("1" (assert) (("1" (use "containment_add") (("1" (assert) (("1" (hide 3) (("1" (split 1) (("1" (typepred_res1) (("1" (replaces "re1" :dir RL) (("1" (skolem "N1" "N1") (("1" (with-labels (flatten) (("N1 vars in box comp" "N1 compatible pairs"))) (("1" (case "FORALL (i: below(length(cache1))):
                                                                                                                                                               eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                eval_ac_noise(nth(cache1, i)`2, N1)") (("1" (replace "ac1") (("1" (inst -1 "0") (("1" (expand "nth" -1) (("1" (replaces -1) (("1" (expand "compatible_pairs_on?" "N1 compatible pairs") (("1" (inst "N1 compatible pairs" "0") (("1" (expand "nth" "N1 compatible pairs") (("1" (flatten) nil))) ("2" (expand "length") (("2" (assert) nil))))))))))) ("2" (expand "length") (("2" (assert) nil))))))) ("2" (expand "compatible_pairs_on?" "N1 compatible pairs") (("2" (skeep) (("2" (inst "N1 compatible pairs" "i!1") (("2" (skolem "cache2-form" "l2") (("2" (replace "cache2-form" "N2 compatible pairs") (("2" (inst "N2 compatible pairs" "length(l2)+i!1") (("1" (case "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") (("1" (flatten) (("1" (replaces -1) (("1" (assert) nil))))) ("2" (hide-all-but 1) (("2" (use "nth_append[CacheData]") (("2" (assert) nil))))))) ("2" (replace "cache2-form" 1) (("2" (use "length_append[CacheData]") (("2" (replaces -1) (("2" (assert) nil))))))))))))))))))))))))))))) ("2" (inst "N2 compatible pairs" "0") (("1" (expand "nth" "N2 compatible pairs") (("1" (assert) nil))) ("2" (expand "length") (("2" (assert) nil))))))))))))))))))))))))))) ("2" (name "j" "i-1") (("2" (typepred "i") (("2" (expand "length") (("2" (expand "nth" 3) (("2" (assert) (("2" (replace -2) (("2" (replace "result") (("2" (assert) (("2" (inst "N2 compatible pairs" "j") nil))))))))))))))))))))))))))))))))) ("4" (replaces "result") (("4" (assert) (("4" (typepred_res2) (("4" (typepred_res1) nil))))))) ("5" (replaces "result") (("5" (assert) (("5" (expand "idxs_bounded") (("5" (skeep) (("5" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (use "next_idx_add_ac_ac") (("1" (expand ">=") (("1" (typepred_res2) (("1" (typepred_res1) (("1" (expand "idxs_bounded") (("1" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -13)) (("1" (expand "max") (("1" (lift-if -4) (("1" (split -4) (("1" (flatten) (("1" (expand ">=") (("1" (assert) nil))))) ("2" (flatten) (("2" (assert) nil))))))))))))))) ("2" (grind) nil))))))) ("2" (grind) nil))))))))))))))))) ("2" (typepred_res2) (("2" (expand "idxs_bounded") (("2" (inst "cache2-idxs_bound" "i-1") (("1" (expand "nth" 3) (("1" (propax) nil))) ("2" (typepred "i") (("2" (grind) nil))))))))))))))))))) ("6" (replaces "result") (("6" (assert) (("6" (expand "correct_cache?" 1) (("6" (typepred_res2) (("6" (assert) (("6" (expand "CacheData_correct?") (("6" (propax) nil)))))))))))))))))))))))))) nil) nil nil (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC22-1 nil 3631365124 ("" (skeep*) (("" (assert) (("" (split 1) (("1" (grind) nil nil) ("2" (replace -4 1) (("2" (assert) (("2" (inst 1 "(:car(result`2):)") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (typepred "cache") (("3" (expand "compatible_pairs?") (("3" (skeep) (("3" (inst 1 "N") (("3" (assert) (("3" (replace -8 1) (("3" (assert) (("3" (expand "compatible_pairs_on?") (("3" (skeep) (("3" (expand "nth" 1) (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (typepred "cache_get(cache)(re)") (("1" (assert) (("1" (skeep) (("1" (inst -5 "i!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -2 "i-1") (("2" (assert) (("2" (typepred "i") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -5) (("4" (replace -4) (("4" (assert) (("4" (typepred "cache") (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace -6) (("1" (typepred "cache_get(cache)(re)") (("1" (assert) (("1" (skeep) (("1" (inst -4 "i!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (replaces -4) (("5" (assert) (("5" (hide -4) (("5" (expand "correct_cache?") (("5" (expand "CacheData_correct?") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Env type-eq-decl nil affine_box nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Interval type-eq-decl nil interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC25 0 (RE2AC_TCC23-1 nil 3631365124 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (last_ol def-decl "T" ordered_list structures) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures) (add_pd_pd const-decl "ErrorTerms" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (add_ac_ac const-decl "AffineCombination" affine nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC26 0 (RE2AC_TCC24-2 nil 3767009989 ("" (skeep*) (("" (assert) (("" (hide -11) (("" (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (with-labels (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten)) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (("" (deftactic typepred_res1 nil (with-labels (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten)) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (split 3) (("1" (grind) nil nil) ("2" (replaces "result") (("2" (assert) (("2" (typepred_res1) (("2" (typepred_res2) (("2" (skolem "cache2-form" "l2") (("2" (skolem "cache1-form" "l1") (("2" (replace "cache1-form" "cache2-form") (("2" (replace "cache2-form" 3) (("2" (inst 3 "cons((re, add_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") (("1" (hide-all-but 3) (("1" (expand "append" 1 3) (("1" (use "append_assoc[CacheData]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred_res2) (("3" (skolem "N2" "N2") (("3" (with-labels (flatten) (("N2 vars in box comp" "N2 compatible pairs"))) (("3" (inst 2 "N2") (("3" (assert) (("3" (expand "compatible_pairs_on?") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 2) (("1" (replace "result") (("1" (assert) (("1" (expand "powvar?" 2) (("1" (expand "eval_ACExpr_Env" 2) (("1" (replaces "re") (("1" (expand "eval" 2) (("1" (skeep) (("1" (use "containment_add") (("1" (assert) (("1" (hide 3) (("1" (split 1) (("1" (typepred_res1) (("1" (replaces "re1" :dir RL) (("1" (skolem "N1" "N1") (("1" (with-labels (flatten) (("N1 vars in box comp" "N1 compatible pairs"))) (("1" (case "FORALL (i: below(length(cache1))):
                                                                                                                                                                                                                                                 eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                                                                                                  eval_ac_noise(nth(cache1, i)`2, N1)") (("1" (replace "ac1") (("1" (inst -1 "0") (("1" (expand "nth" -1) (("1" (replaces -1) (("1" (expand "compatible_pairs_on?" "N1 compatible pairs") (("1" (inst "N1 compatible pairs" "0") (("1" (expand "nth" "N1 compatible pairs") (("1" (inst "N1 compatible pairs" "n") (("1" (flatten) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?" "N1 compatible pairs") (("2" (skeep) (("2" (inst "N1 compatible pairs" "i!1") (("2" (inst "N1 compatible pairs" "n") (("2" (skolem "cache2-form" "l2") (("2" (replace "cache2-form" "N2 compatible pairs") (("2" (inst "N2 compatible pairs" "length(l2)+i!1") (("1" (inst "N2 compatible pairs" "n") (("1" (case "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") (("1" (flatten) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (use "more_list_props[CacheData].nth_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace "cache2-form" 1) (("2" (use "length_append[CacheData]") (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst "N2 compatible pairs" "0") (("1" (inst "N2 compatible pairs" "n") (("1" (expand "nth" "N2 compatible pairs") (("1" (assert) (("1" (expand "length") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "j" "i-1") (("2" (typepred "i") (("2" (expand "length") (("2" (expand "nth" 3) (("2" (assert) (("2" (replace -2) (("2" (replace "result") (("2" (assert) (("2" (inst "N2 compatible pairs" "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replaces "result") (("4" (assert) (("4" (typepred_res2) (("4" (typepred_res1) nil nil)) nil)) nil)) nil) ("5" (replaces "result") (("5" (assert) (("5" (expand "idxs_bounded") (("5" (skeep) (("5" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (use "next_idx_add_ac_ac") (("1" (expand ">=") (("1" (typepred_res2) (("1" (typepred_res1) (("1" (expand "idxs_bounded") (("1" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -11)) (("1" (expand "max") (("1" (lift-if -4) (("1" (split -4) (("1" (flatten) (("1" (expand ">=") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred_res2) (("2" (expand "idxs_bounded") (("2" (inst "cache2-idxs_bound" "i-1") (("1" (expand "nth" 3) (("1" (propax) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (next_idx_add_ac_ac formula-decl nil affine nil) (i skolem-const-decl "below(length(cons((re, add_ac_ac(ac1, ac2), null), cache2)))" affine_expr_Eval_fnd nil) (ac2 skolem-const-decl "AffineCombination" affine_expr_Eval_fnd nil) (ac1 skolem-const-decl "AffineCombination" affine_expr_Eval_fnd nil) (re skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (powvar? const-decl "bool" affine_expr nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (l2 skolem-const-decl "list[CacheData]" affine_expr_Eval_fnd nil) (i!1 skolem-const-decl "below(length(cache1))" affine_expr_Eval_fnd nil) (cache2 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval_fnd nil) (nth_append formula-decl nil more_list_props structures) (length_append formula-decl nil list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (SingInterval? const-decl "bool" affine nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (cache1 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil nat_types nil) (eval_ac_noise const-decl "real" affine nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (Env type-eq-decl nil box interval_arith) (containment_add formula-decl nil affine nil) (eval def-decl "real" interval_expr interval_arith) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (null adt-constructor-decl "(null?)" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (append_assoc formula-decl nil list_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (null_ol? const-decl "bool" ordered_list structures) (add_pd_pd const-decl "ErrorTerms" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (add_ac_ac const-decl "AffineCombination" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC24-1 nil 3631365124 ("" (grind) nil nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Env type-eq-decl nil affine_box nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (last_ol def-decl "T" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (null_ol? const-decl "bool" ordered_list structures) (add_pd_pd const-decl "ErrorTerms" affine nil) (add_ac_ac const-decl "AffineCombination" affine nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC27 0 (RE2AC_TCC27-1 "" 3789917536 ("" (skeep*) (("" (assert) (("" (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (with-labels (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten)) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (("" (deftactic typepred_res1 nil (with-labels (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten)) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (ordered_list? def-decl "bool" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC25-1 nil 3631365124 ("" (skeep*) (("" (assert) (("" (hide -11) (("" (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (with-labels (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten)) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (("" (deftactic typepred_res1 nil (with-labels (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten)) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (split 3) (("1" (grind) nil nil) ("2" (replaces "result") (("2" (assert) (("2" (typepred_res1) (("2" (typepred_res2) (("2" (skolem "cache2-form" "l2") (("2" (skolem "cache1-form" "l1") (("2" (replace "cache1-form" "cache2-form") (("2" (replace "cache2-form" 3) (("2" (inst 3 "cons((re, add_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") (("1" (hide-all-but 3) (("1" (expand "append" 1 3) (("1" (use "append_assoc[CacheData]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred_res2) (("3" (skolem "N2" "N2") (("3" (with-labels (flatten) (("N2 vars in box comp" "N2 compatible pairs"))) (("3" (inst 2 "N2") (("3" (assert) (("3" (expand "compatible_pairs_on?") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 2) (("1" (replace "result") (("1" (assert) (("1" (expand "powvar?" 2) (("1" (expand "eval_ACExpr_Env" 2) (("1" (replaces "re") (("1" (expand "eval" 2) (("1" (skeep) (("1" (use "containment_add") (("1" (assert) (("1" (hide 3) (("1" (split 1) (("1" (typepred_res1) (("1" (replaces "re1" :dir RL) (("1" (skolem "N1" "N1") (("1" (with-labels (flatten) (("N1 vars in box comp" "N1 compatible pairs"))) (("1" (case "FORALL (i: below(length(cache1))):
                                                                                                                                                                                                                                    eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                                                                                     eval_ac_noise(nth(cache1, i)`2, N1)") (("1" (replace "ac1") (("1" (inst -1 "0") (("1" (expand "nth" -1) (("1" (replaces -1) (("1" (expand "compatible_pairs_on?" "N1 compatible pairs") (("1" (inst "N1 compatible pairs" "0") (("1" (expand "nth" "N1 compatible pairs") (("1" (inst "N1 compatible pairs" "n") (("1" (flatten) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?" "N1 compatible pairs") (("2" (skeep) (("2" (inst "N1 compatible pairs" "i!1") (("2" (inst "N1 compatible pairs" "n") (("2" (skolem "cache2-form" "l2") (("2" (replace "cache2-form" "N2 compatible pairs") (("2" (inst "N2 compatible pairs" "length(l2)+i!1") (("1" (inst "N2 compatible pairs" "n") (("1" (case "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") (("1" (flatten) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (use "more_list_props[CacheData].nth_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace "cache2-form" 1) (("2" (use "length_append[CacheData]") (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst "N2 compatible pairs" "0") (("1" (inst "N2 compatible pairs" "n") (("1" (expand "nth" "N2 compatible pairs") (("1" (assert) (("1" (expand "length") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "j" "i-1") (("2" (typepred "i") (("2" (expand "length") (("2" (expand "nth" 3) (("2" (assert) (("2" (replace -2) (("2" (replace "result") (("2" (assert) (("2" (inst "N2 compatible pairs" "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replaces "result") (("4" (assert) (("4" (typepred_res2) (("4" (typepred_res1) nil nil)) nil)) nil)) nil) ("5" (replaces "result") (("5" (assert) (("5" (expand "idxs_bounded") (("5" (skeep) (("5" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (use "next_idx_add_ac_ac") (("1" (expand ">=") (("1" (typepred_res2) (("1" (typepred_res1) (("1" (expand "idxs_bounded") (("1" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -11)) (("1" (expand "max") (("1" (lift-if -4) (("1" (split -4) (("1" (flatten) (("1" (expand ">=") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred_res2) (("2" (expand "idxs_bounded") (("2" (inst "cache2-idxs_bound" "i-1") (("1" (expand "nth" 3) (("1" (propax) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures)) nil (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC28 0 (RE2AC_TCC26-2 nil 3632067889 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (last_ol def-decl "T" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_minus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC26-1 nil 3631365124 ("" (subtype-tcc) nil nil) ((Interval type-eq-decl nil interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (next_idx const-decl "nat" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC29 0 (RE2AC_TCC27-2 nil 3767011072 ("" (skeep*) (("" (assert) (("" (split 1) (("1" (grind) nil nil) ("2" (replace -4 1) (("2" (assert) (("2" (inst 1 "(:car(result`2):)") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (typepred "cache") (("3" (expand "compatible_pairs?") (("3" (skeep) (("3" (inst 1 "N") (("3" (assert) (("3" (replace -8 1) (("3" (assert) (("3" (expand "compatible_pairs_on?") (("3" (skeep) (("3" (skeep) (("3" (expand "nth" 1) (("3" (lift-if 1) (("3" (split 1) (("1" (flatten) (("1" (typepred "cache_get(cache)(re)") (("1" (assert) (("1" (skeep) (("1" (inst? :subst ("i" "i!1" "n" "n")) (("1" (assert) (("1" (expand "powvar?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (typepred "i") (("2" (inst? :subst ("i" "i - 1" "n" "n")) (("1" (expand "length" -1) (("1" (assert) nil nil)) nil) ("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -5) (("4" (replace -4) (("4" (assert) (("4" (typepred "cache") (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace -6) (("1" (typepred "cache_get(cache)(re)") (("1" (assert) (("1" (skeep) (("1" (inst? :subst ("i" "i!1")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst? :subst ("i" "i-1")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (NOT const-decl "[bool -> bool]" booleans nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (nth def-decl "T" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (cache_get def-decl "{res: Maybe[AffineCombination] |
   some?(res) IMPLIES
    EXISTS (i: below(length(cache))):
      nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res)}" affine_expr_Eval_fnd nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (eval def-decl "real" interval_expr interval_arith) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (powvar? const-decl "bool" affine_expr nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (re skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (cached skolem-const-decl "{res: Maybe[AffineCombination] |
   some?(res) IMPLIES
    EXISTS (i: below(length(cache))):
      nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res)}" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(cons((re, val(cached), null), cache)))" affine_expr_Eval_fnd nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (> const-decl "bool" reals nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (append def-decl "list[T]" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC27-1 nil 3631365124 ("" (grind) nil nil) ((ordered_list? def-decl "bool" ordered_list structures)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC30 0 (RE2AC_TCC28-1 nil 3631365124 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (restrict const-decl "R" restrict nil)) nil (RE2AC termination "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re1, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.nextfreeidx, affine_expr_Eval_fnd.cache)" "nil"))) (RE2AC_TCC31 0 (RE2AC_TCC31-1 nil 3789916158 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length_singleton formula-decl nil more_list_props structures) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC32 0 (RE2AC_TCC32-1 "" 3789917543 ("" (skeep*) (("" (assert) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)")) (RE2AC_TCC29-1 nil 3631365124 ("" (then (skeep*) (assert) (spread (split 1) ((grind) (then (replace -4 1) (assert) (inst 1 "(:car(result`2):)") (grind)) (then (typepred "cache") (expand "compatible_pairs?") (skeep) (inst 1 "N") (assert) (replace -8 1) (assert) (expand "compatible_pairs_on?") (skeep) (skeep) (expand "nth" 1) (lift-if 1) (spread (split 1) ((then (flatten) (typepred "cache_get(cache)(re)") (assert) (skeep) (inst? :subst ("i" "i!1" "n" "n")) (assert) (expand "powvar?") (grind)) (then (flatten) (assert) (typepred "i") (spread (inst? :subst ("i" "i - 1" "n" "n")) ((then (expand "length" -1) (assert)) (then (expand "length" -1) (assert)))))))) (then (hide -5) (replace -4) (assert) (typepred "cache") (expand "idxs_bounded") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (replace -6) (typepred "cache_get(cache)(re)") (assert) (skeep) (inst? :subst ("i" "i!1")) (assert)) (then (expand "nth" 2) (assert) (inst? :subst ("i" "i-1"))))))))) nil nil) nil nil (RE2AC subtype "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)"))) (RE2AC_TCC33 0 (RE2AC_TCC30-1 nil 3631365124 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.cache1" "(list_adt[CacheData].cons?)"))) (RE2AC_TCC34 0 (RE2AC_TCC34-1 "" 3789917546 ("" (skeep*) (("" (typepred "res1") (("" (assert) nil nil)) nil)) nil) ((compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box))}")) (RE2AC_TCC31-2 "" 3631566874 ("" (then (skeep*) (typepred "res1") (assert) (flatten) (spread (split 4) ((then (expand "compatible_pairs?") (skeep -3) (inst 1 "N") (assert)) (then (replace -11 :dir RL) (replace -10 :dir RL) (propax)) (then (replace -11 :dir RL) (propax))))) nil nil) ((gt_realorder name-judgement "RealOrder" real_orders reals) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box))}")) (RE2AC_TCC31-1 nil 3631365124 ("" (skeep*) (("" (assert) (("" (hide -12) (("" (apply (then (label "result" -11) (label "ac2" -10) (label "cache2" -9) (label "newid2" -8) (label "res2" -7) (label "ac1" -6) (label "cache1" -5) (label "newid1" -4) (label "res1" -3) (label "cached" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten) (label "re2" -1) (label "cache2-form" -2) (label "N2" -3) (label "newid2-prop" -4) (label "cache2-idxs_bound" -5))) (("" (deftactic typepred_res1 nil (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten) (label "re1" -1) (label "cache1-form" -2) (label "N1" -3) (label "newid1-prop" -4) (label "cache1-idxs_bound" -5))) (("" (split 4) (("1" (grind) nil nil) ("2" (replaces "result") (("2" (assert) (("2" (typepred_res1) (("2" (typepred_res2) (("2" (skolem "cache2-form" "l2") (("2" (skolem "cache1-form" "l1") (("2" (replace "cache1-form" "cache2-form") (("2" (replace "cache2-form" 3) (("2" (inst 3 "cons((re, mult_ac_ac(ac1, ac2, newid2)), append(l2,l1))") (("1" (hide-all-but 3) (("1" (expand "append" 1 3) (("1" (use "append_assoc[[RealExpr, AffineCombination]]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "next_idx_2") (("2" (expand ">=") (("2" (expand "idxs_bounded") (("2" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (1 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (expand "max") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand ">=") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand ">=") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred_res2) (("3" (skolem "N2" "N2") (("3" (with-labels (flatten) (("N2 vars in box comp" "N2 compatible pairs"))) (("3" (name "updN2" "upd_noise(N2,
                                        newid2,
                                        mul_noise_value
                                        (ac1,
                                         ac2,
                                         first_noises(N2, newid2)))") (("1" (inst 2 "updN2") (("1" (split 2) (("1" (expand "vars_in_box_compatible?") (("1" (skeep) (("1" (inst "N2 vars in box comp" "i") (("1" (flatten) (("1" (case "get_noise_by_idx(i, updN2) = get_noise_by_idx(i, N2)") (("1" (split 1) (("1" (replace "N2 vars in box comp" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (expand_ol) (("2" (assert) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (use "gnbi_upd_2") (("2" (assert) (("2" (typepred_res1) (("2" (typepred "nextfreeidx") (("2" (expand "last_idx_in_box") (("2" (replaces -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "result") (("1" (assert) (("1" (expand "eval_ACExpr_Env" 1) (("1" (replaces "re") (("1" (assert) (("1" (use "containment_mul") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (typepred_res1) (("1" (expand "next_idx_2") (("1" (expand ">=") (("1" (expand "idxs_bounded") (("1" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (2 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (expand "max") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand ">=") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand ">=") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "eval_ac_noise(ac1, updN2) = eval_ac_noise(ac1, N2)") (("1" (replaces -1) (("1" (typepred_res1) (("1" (replaces "re1" :dir RL) (("1" (skolem "N1" "N1") (("1" (with-labels (flatten) (("N1 vars in box comp" "N1 compatible pairs"))) (("1" (case "FORALL (i: below(length(cache1))):
                                                                                                                        eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                         eval_ac_noise(nth(cache1, i)`2, N1)") (("1" (replace "ac1") (("1" (inst -1 "0") (("1" (expand "nth" -1) (("1" (replaces -1) (("1" (expand "compatible_pairs_on?" "N1 compatible pairs") (("1" (inst "N1 compatible pairs" "0") (("1" (expand "nth" "N1 compatible pairs") (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?" "N1 compatible pairs") (("2" (skeep) (("2" (inst "N1 compatible pairs" "i!1") (("2" (replace "N1 compatible pairs" 1) (("2" (skolem "cache2-form" "l2") (("2" (replace "cache2-form" "N2 compatible pairs") (("2" (inst "N2 compatible pairs" "length(l2)+i!1") (("1" (case "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (use "nth_append[[RealExpr, AffineCombination]]") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "cache2-form" 1) (("2" (use "length_append[[RealExpr, AffineCombination]]") (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replaces -1 1 :dir RL) (("2" (use "eval_upd_no_idxs_ac") (("2" (assert) (("2" (hide 1) (("2" (replace "ac1" -1) (("2" (typepred_res1) (("2" (expand "idxs_bounded" "cache1-idxs_bound") (("2" (expand "idxs_ac") (("2" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (expand "next_idx") (("1" (hide-all-but ("cache1-idxs_bound" -6 "newid2-prop")) (("1" (use "beyond_last_idx_notmember") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "eval_ac_noise(ac2, updN2) = eval_ac_noise(ac2, N2)") (("1" (replaces -1) (("1" (inst "N2 compatible pairs" "0") (("1" (expand "nth" "N2 compatible pairs") (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replaces -1 1 :dir RL) (("2" (use "eval_upd_no_idxs_ac") (("2" (assert) (("2" (hide 1) (("2" (expand "idxs_bounded" "cache2-idxs_bound") (("2" (expand "idxs_ac") (("2" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (expand "next_idx") (("1" (hide-all-but ("cache2-idxs_bound" -1)) (("1" (use "beyond_last_idx_notmember") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replaces -1 :dir RL) (("4" (use "first_noises_upd") (("4" (replaces -1) (("4" (use "gnbi_upd") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "j" "i-1") (("2" (typepred "i") (("2" (expand "length") (("2" (expand "nth" 2) (("2" (assert) (("2" (replace -2) (("2" (replace "result") (("2" (assert) (("2" (inst "N2 compatible pairs" "j") (("2" (case "eval_ac_noise(nth(cache2, j)`2, updN2) = eval_ac_noise(nth(cache2, j)`2, N2)") (("1" (assert) nil nil) ("2" (replaces -3 1 :dir RL) (("2" (use "eval_upd_no_idxs_ac") (("2" (assert) (("2" (hide 1) (("2" (expand "idxs_bounded" "cache2-idxs_bound") (("2" (expand "idxs_ac") (("2" (inst "cache2-idxs_bound" "j") (("2" (expand "next_idx") (("2" (hide-all-but ("cache2-idxs_bound" -1)) (("2" (use "beyond_last_idx_notmember") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "mul_noise_value_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replaces "result") (("4" (assert) (("4" (typepred_res2) (("4" (typepred_res1) (("4" (hide-all-but (3 -9 -4)) (("4" (expand ">=") (("4" (case "nextfreeidx <= newid2") (("1" (hide-all-but (-1 1)) (("1" (lemma "lt_plus_lt2") (("1" (inst -1 "newid2" "0" "1" "nextfreeidx") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (typepred "reals.<=") (("2" (expand "total_order?") (("2" (expand "partial_order?") (("2" (expand "preorder?") (("2" (expand "reflexive?") (("2" (expand "transitive?") (("2" (flatten) (("2" (inst -1 "nextfreeidx" "newid1" "newid2") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (replaces "result") (("5" (assert) (("5" (expand "idxs_bounded") (("5" (skeep) (("5" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (use "next_idx_mult_ac_ac") (("1" (expand ">=") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred_res2) (("2" (expand "idxs_bounded") (("2" (inst "cache2-idxs_bound" "i-1") (("1" (expand "nth" 3) (("1" (hide-all-but (3 "cache2-idxs_bound")) (("1" (expand ">=") (("1" (lemma "lt_plus_lt2") (("1" (inst -1 "newid2" "0" "1" "next_idx(pd(nth(cache2, i - 1)`2))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_ol? const-decl "bool" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (append_ol const-decl "ordered_list" ordered_list structures) (mult_ac_ac const-decl "AffineCombination" affine nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) (next_idx_2 const-decl "nat" affine nil) (nzBaseType type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (Interval type-eq-decl nil interval interval_arith) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (ordered_list? def-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (ordered_list type-eq-decl nil ordered_list structures) (car_ol const-decl "T" ordered_list structures) (upd_noise def-decl "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" affine nil) (mul_noise_value const-decl "real" affine nil) (first_noises const-decl "Noise" affine nil) (gnbi_upd_2 formula-decl nil affine nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (ac_proj_pd formula-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (eval_upd_no_idxs_ac formula-decl nil affine nil) (idxs_ac const-decl "list[nat]" affine nil) (beyond_last_idx_notmember formula-decl nil affine nil) (first_noises_upd formula-decl nil affine nil) (gnbi_upd formula-decl nil affine nil) (containment_mul formula-decl nil affine nil) (mul_noise_value_is_Epsilon judgement-tcc nil affine nil) (next_idx_mult_ac_ac formula-decl nil affine nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box))}"))) (RE2AC_TCC35 0 (RE2AC_TCC32-3 nil 3767016267 ("" (skeep*) (("" (typepred "res1") (("" (assert) (("" (flatten) (("" (split 4) (("1" (expand "compatible_pairs?") (("1" (skeep -3) (("1" (inst 1 "N") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -10 :dir RL) (("2" (replace -9 :dir RL) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.cache1" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.newid1)(cache)}")) (RE2AC_TCC32-2 nil 3632068503 ("" (termination-tcc) nil nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Env type-eq-decl nil affine_box nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (pow_var_compatible? const-decl "bool" affine_pow nil) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures)) nil (RE2AC subtype "affine_expr_Eval_fnd.cache1" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.newid1)(cache)}")) (RE2AC_TCC32-1 nil 3631365124 ("" (grind) nil nil) ((Interval type-eq-decl nil interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures)) nil (RE2AC subtype "affine_expr_Eval_fnd.cache1" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.newid1)(cache)}"))) (RE2AC_TCC36 0 (RE2AC_TCC33-2 nil 3767016325 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (restrict const-decl "R" restrict nil)) nil (RE2AC termination "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re2, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.newid1, affine_expr_Eval_fnd.cache1)" "nil")) (RE2AC_TCC33-1 nil 3631466640 ("" (subtype-tcc) nil nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Env type-eq-decl nil affine_box nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (next_idx const-decl "nat" affine nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (length_null formula-decl nil more_list_props structures) (length_singleton formula-decl nil more_list_props structures) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures)) nil (RE2AC termination "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re2, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.newid1, affine_expr_Eval_fnd.cache1)" "nil"))) (RE2AC_TCC37 0 (RE2AC_TCC37-1 nil 3789916158 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length_singleton formula-decl nil more_list_props structures) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC38 0 (RE2AC_TCC34-1 nil 3631466640 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (next_idx const-decl "nat" affine nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (length_singleton formula-decl nil more_list_props structures) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.res2" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)"))) (RE2AC_TCC39 0 (RE2AC_TCC35-2 nil 3631472540 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.cache2" "(list_adt[CacheData].cons?)")) (RE2AC_TCC35-1 nil 3631466640 ("" (subtype-tcc) nil nil) ((Interval type-eq-decl nil interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (next_idx const-decl "nat" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.cache2" "(list_adt[CacheData].cons?)"))) (RE2AC_TCC40 0 (RE2AC_TCC36-2 nil 3767016447 ("" (skeep*) (("" (expand "next_idx_2") (("" (typepred "res2") (("" (assert) (("" (flatten) (("" (replace -14 :dir RL) (("" (typepred "res1") (("" (assert) (("" (flatten) (("" (replaces -17) (("" (hide-all-but (6 -10 -5 -11)) (("" (expand "idxs_bounded") (("" (inst -1 "0") (("1" (inst? :subst ("i" "0")) (("1" (expand "nth") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (reveal 1) (("3" (grind) nil nil)) nil)) nil) ("2" (reveal 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((next_idx_2 const-decl "nat" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (cache2 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval_fnd nil) (int_plus_int_is_int application-judgement "int" integers nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nth def-decl "T" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (below type-eq-decl nil naturalnumbers nil) (res1 skolem-const-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
         (NOT null?(val(result)`2)) AND (car(val(result)`2)`1 = re1)
     AND (EXISTS (l: list[CacheData]): val(result)`2 = append(l, cache))
     AND (EXISTS (N: Noise):
            vars_in_box_compatible?(N)(box)(vs) AND
             compatible_pairs_on?(box, vs)(N)(val(result)`2))
     AND (val(result)`1 >= nextfreeidx)
     AND idxs_bounded(val(result)`1)(val(result)`2)}" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (re1 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (length def-decl "nat" list_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.newid2" "{newidx: naturalnumbers.nat | reals.>=(newidx, affine.next_idx_2(pd(affine_expr_Eval_fnd.ac1), pd(affine_expr_Eval_fnd.ac2)))}")) (RE2AC_TCC36-1 nil 3631466640 ("" (termination-tcc) nil nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Env type-eq-decl nil affine_box nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures)) shostak (RE2AC subtype "affine_expr_Eval_fnd.newid2" "{newidx: naturalnumbers.nat | reals.>=(newidx, affine.next_idx_2(pd(affine_expr_Eval_fnd.ac1), pd(affine_expr_Eval_fnd.ac2)))}"))) (RE2AC_TCC41 0 (RE2AC_TCC41-1 "" 3789917559 ("" (skeep*) (("" (grind) nil nil)) nil) ((ordered_list? def-decl "bool" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC37-3 nil 3632068879 ("" (then (skeep*) (grind)) nil nil) ((ordered_list? def-decl "bool" ordered_list structures)) nil (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC37-2 nil 3631550185 ("" (grind) nil nil) ((var_ac const-decl "AffineCombination" affine nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil)) nil (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC37-1 nil 3631466640 ("" (grind) nil nil) ((Interval type-eq-decl nil interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil)) shostak (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC42 0 (RE2AC_TCC42-1 "" 3789917564 ("" (skeep*) (("" (assert) (("" (hide 1) (("" (hide -6) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth def-decl "T" list_props nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (length def-decl "nat" list_props nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (/= const-decl "boolean" notequal nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_times_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (null_ol? const-decl "bool" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (append_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (mult_ac_ac const-decl "AffineCombination" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC38-2 nil 3631567697 ("" (then (skeep*) (assert) (expand "null_ol") (hide 1) (hide -6) (spread (split 1) ((grind) (then (replace -5 1) (assert) (inst 1 "(: (re, acRes,null)::CacheData :)") (grind)) (then (replace -5 1) (assert) (typepred "cache") (expand "compatible_pairs?") (skeep) (inst 1 "N") (assert) (expand "compatible_pairs_on?") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (spread (case "pow=0") ((then (replaces -1) (replaces -4) (replaces -6) (expand "pow_var_ac") (expand "eval_ACExpr_Env") (expand "eval_ac_noise") (assert) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (assert) (use "expt_x0") (assert)) (spread (case "pow=1") ((then (replaces -1) (replaces -4) (replaces -6) (expand "eval_ACExpr_Env" 2) (expand "pow_var_ac" 2) (lift-if 2) (spread (split 2) ((then (flatten) (replaces -6) (expand "eval_ac_noise") (assert) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (expand "nth_ac" 1) (expand "vars_in_box_compatible?") (inst -2 "idx") (flatten) (replaces -2 1 :dir RL) (expand "eval_ac_noise") (expand "nth_ac") (spread (case "pd(var_ac(nth(box, idx), idx)) = null") ((then (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (assert)) (grind)))) (then (flatten) (spread (split 2) ((then (flatten) (expand "vars_in_box_compatible?") (inst -2 "idx") (flatten) (replaces -2 1 :dir RL) (replaces -6) (expand "eval_ac_noise" 1) (assert) (expand "nth_ac") (use "eval_pd_noise_rec_pds_def") (expand_ol) (lift-if -1) (spread (split -1) ((grind) (then (flatten) (replaces -1) (spread (case "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") ((then (replaces -1) (assert) (use "expt_x1") (replaces -1) (use "expt_x1") (assert)) (then (hide 3) (spread (case "cdr(pd(var_ac(nth(box, idx), idx))) = null") ((then (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol)) (grind)))))))))) (then (flatten) (expand "vars_in_box_compatible?") (inst -1 "idx") (flatten) (replaces -1 2 :dir RL) (expand "eval_ac_noise") (assert) (replaces -5) (expand "nth_ac") (use "expt_x1") (replaces -1) (use "expt_x1") (replaces -1) (assert) (use "eval_pd_noise_rec_pds_def") (lift-if -1) (spread (split -1) ((grind) (then (flatten) (replaces -1) (expand_ol) (spread (case "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") ((then (replaces -1) (assert) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (assert) (use "expt_x0") (replaces -1) (grind)) (then (use "expt_x0") (replaces -1) (expand "nth" 1) (spread (typepred "car(pd
                                                                                                      (var_ac(IF idx = 0 THEN car(box)
                                                                                                              ELSE nth(cdr(box), idx - 1)
                                                                                                              ENDIF,
                                                                                                              idx)))`2") ((then (expand "/=") (grind)) (then (flatten) (typepred "idx") (grind)) (then (flatten) (typepred "idx") (grind)) (then (flatten) (grind)))))))) (spread (case "cdr(pd(var_ac(nth(box, idx), idx))) = null") ((then (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol)) (grind))))))))))))))) (spread (split -5) ((grind) (then (replaces -7 3) (replaces -5 3) (expand "pow_var_ac") (assert) (expand "eval_ACExpr_Env" 3) (expand "eval_ac_noise") (assert) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (assert) (replaces -5) (expand "nth_ac") (expand "vars_in_box_compatible?") (inst -2 "idx") (flatten) (replaces -2 3 :dir RL) (expand "eval_ac_noise") (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (lift-if 3) (spread (split 3) ((then (flatten) (assert)) (then (flatten) (grind)))))))))))) (then (expand "nth" 2) (assert) (inst -2 "i-1"))))) (then (replace -5 1) (assert) (typepred "cache") (expand "idxs_bounded") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (replaces -6) (use "next_idx_pow_var_ac") (assert) (replaces -1) (typepred "nextfreeidx") (replaces -6) (expand "last_idx_in_box") (expand "nth_ac") (expand "var_ac" 1) (lift-if 1) (spread (split 1) ((then (flatten) (assert) (expand "next_idx") (expand "last_idx") (expand "last_ol") (reveal 1) (grind)) (then (flatten) (assert) (grind))))) (then (expand "nth" 2) (assert) (inst -2 "i-1")))))))) nil nil) ((mult_ac_ac const-decl "AffineCombination" affine nil) (append_ol const-decl "ordered_list" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC38-1 nil 3631466640 ("" (skeep*) (("" (assert) (("" (hide -7) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow is cached" -4) (label "cached" -5) (label "result" -6) (label "idx" 1) (label "pow <= 1" 2))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 4) (("1" (typepred "cached") (("1" (assert) nil nil)) nil) ("2" (inst 1 "(: val(cached) :)") (("2" (grind) nil nil)) nil) ("3" (with-labels (typepred "cache") (("cache comp pairs" "cache idx bound"))) (("3" (expand "compatible_pairs?") (("3" (skeep) (("3" (inst 1 "N") (("3" (assert) (("3" (expand "compatible_pairs_on?") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (replaces -2 1 :dir RL) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst "cache comp pairs" "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (typepred "cache") (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (replaces -2 1 :dir RL) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC43 0 (RE2AC_TCC43-1 "" 3789917586 ("" (skeep*) (("" (assert) (("" (hide -12) (("" (apply (then (label "result" -11) (label "ac2" -10) (label "cache2" -9) (label "newid2" -8) (label "res2" -7) (label "ac1" -6) (label "cache1" -5) (label "newid1" -4) (label "res1" -3) (label "cached" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (with-labels (flatten) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound"))))) (("" (deftactic typepred_res1 nil (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (with-labels (flatten) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound"))))) (("" (split 4) (("1" (grind) nil nil) ("2" (replaces "result") (("2" (assert) (("2" (typepred_res1) (("2" (typepred_res2) (("2" (skolem "cache2-form" "l2") (("2" (skolem "cache1-form" "l1") (("2" (replace "cache1-form" "cache2-form") (("2" (replace "cache2-form" 3) (("2" (inst 3 "cons((re, mult_ac_ac(ac1, ac2, newid2), null)::CacheData, append(l2,l1))") (("1" (hide-all-but 3) (("1" (expand "append" 1 3) (("1" (use "append_assoc[CacheData]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (expand "next_idx_2") (("3" (expand ">=") (("3" (expand "idxs_bounded") (("3" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (1 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (expand "max") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand ">=") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand ">=") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred_res2) (("3" (skolem "N2" "N2") (("3" (with-labels (flatten) (("N2 vars in box comp" "N2 compatible pairs"))) (("3" (name "updN2" "upd_noise(N2,
                                                                                                   newid2,
                                                                                                   mul_noise_value
                                                                                                   (ac1,
                                                                                                    ac2,
                                                                                                    first_noises(N2, newid2)))") (("1" (inst 2 "updN2") (("1" (split 2) (("1" (expand "vars_in_box_compatible?") (("1" (skeep) (("1" (inst "N2 vars in box comp" "i") (("1" (flatten) (("1" (case "get_noise_by_idx(i, updN2) = get_noise_by_idx(i, N2)") (("1" (split 1) (("1" (replace "N2 vars in box comp" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (expand_ol) (("2" (assert) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (use "gnbi_upd_2") (("2" (assert) (("2" (typepred_res1) (("2" (typepred "nextfreeidx") (("2" (expand "last_idx_in_box") (("2" (replaces -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skeep) (("2" (case "i=0") (("1" (skeep) (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "result") (("1" (assert) (("1" (expand "powvar?") (("1" (replaces "re") (("1" (expand "eval_ACExpr_Env" 1) (("1" (expand "eval") (("1" (use "containment_mul") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (typepred_res1) (("1" (expand "next_idx_2") (("1" (expand ">=") (("1" (expand "idxs_bounded") (("1" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (2 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (expand "max") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand ">=") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand ">=") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "eval_ac_noise(ac1, updN2) = eval_ac_noise(ac1, N2)") (("1" (replaces -1) (("1" (typepred_res1) (("1" (replaces "re1" :dir RL) (("1" (skolem "N1" "N1") (("1" (with-labels (flatten) (("N1 vars in box comp" "N1 compatible pairs"))) (("1" (case "FORALL (i: below(length(cache1))):
                                                                                                                                                                                                                                                                                             eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                                                                                                                                              eval_ac_noise(nth(cache1, i)`2, N1)") (("1" (replace "ac1") (("1" (inst -1 "0") (("1" (expand "nth" -1) (("1" (replaces -1) (("1" (expand "compatible_pairs_on?" "N1 compatible pairs") (("1" (inst "N1 compatible pairs" "0") (("1" (inst "N1 compatible pairs" "n") (("1" (flatten) (("1" (expand "nth") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?" "N1 compatible pairs") (("2" (skeep) (("2" (inst "N1 compatible pairs" "i!1") (("2" (inst "N1 compatible pairs" "n") (("2" (skolem "cache2-form" "l2") (("2" (replace "cache2-form" "N2 compatible pairs") (("2" (inst "N2 compatible pairs" "length(l2)+i!1") (("1" (inst "N2 compatible pairs" "n") (("1" (case "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") (("1" (assert) (("1" (flatten) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (use "more_list_props[CacheData].nth_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace "cache2-form" 1) (("2" (use "length_append[[RealExpr, AffineCombination]]") (("2" (assert) (("2" (use "length_append[CacheData]") (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replaces -1 1 :dir RL) (("2" (use "eval_upd_no_idxs_ac") (("2" (assert) (("2" (hide 1) (("2" (replace "ac1" -1) (("2" (typepred_res1) (("2" (expand "idxs_bounded" "cache1-idxs_bound") (("2" (expand "idxs_ac") (("2" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (expand "next_idx") (("1" (hide-all-but ("cache1-idxs_bound" -6 "newid2-prop")) (("1" (use "beyond_last_idx_notmember") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "eval_ac_noise(ac2, updN2) = eval_ac_noise(ac2, N2)") (("1" (replaces -1) (("1" (inst "N2 compatible pairs" "0") (("1" (inst "N2 compatible pairs" "n") (("1" (expand "nth" "N2 compatible pairs") (("1" (assert) (("1" (expand "length") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replaces -1 1 :dir RL) (("2" (use "eval_upd_no_idxs_ac") (("2" (assert) (("2" (hide 1) (("2" (expand "idxs_bounded" "cache2-idxs_bound") (("2" (expand "idxs_ac") (("2" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (expand "next_idx") (("1" (hide-all-but ("cache2-idxs_bound" -1)) (("1" (use "beyond_last_idx_notmember") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replaces -1 :dir RL) (("4" (use "first_noises_upd") (("4" (replaces -1) (("4" (use "gnbi_upd") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "j" "i-1") (("2" (typepred "i") (("2" (expand "length" -1) (("2" (expand "nth" 2) (("2" (assert) (("2" (replace -2) (("2" (replace "result") (("2" (assert) (("2" (skeep) (("2" (inst "N2 compatible pairs" "j") (("2" (inst "N2 compatible pairs" "n") (("2" (flatten) (("2" (case "eval_ac_noise(nth(cache2, j)`2, updN2) = eval_ac_noise(nth(cache2, j)`2, N2)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (flatten) (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (case "get_noise_by_idx(nth(nth(cache2, j)`3, i!1), updN2) = get_noise_by_idx(nth(nth(cache2, j)`3, i!1), N2)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))),
                                                                                                                                                                                0)`1,
                                                                                                                                                                            updN2) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))),
                                                                                                                                                                                0)`1,
                                                                                                                                                                            N2)") (("1" (replaces -1) nil nil) ("2" (hide 3) (("2" (expand "updN2") (("2" (lemma "gnbi_upd_2") (("2" (inst? -1 :where 1) (("2" (assert) (("2" (typepred "res1") (("2" (assert) (("2" (flatten) (("2" (typepred "nextfreeidx") (("2" (hide-all-but (-1 "newid2-prop" -5 "newid1" "newid2" -7 -13)) (("2" (replaces "newid1") (("2" (replaces "newid2") (("2" (expand "nth" -3 1) (("2" (use "last_idx_box") (("2" (expand "next_idx") (("2" (use "olidx_car_last[nzBaseType]") (("2" (case "NOT null?(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))") (("1" (assert) (("1" (expand "last_idx") (("1" (expand ">=") (("1" (expand ">") (("1" (case "last_ol(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))`1 < nextfreeidx") (("1" (hide -3 -4) (("1" (case "car_ol(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))`1 < nextfreeidx") (("1" (hide -2 -3) (("1" (expand "car_ol") (("1" (replaces -3) (("1" (case "val(res1)`1 < nextfreeidx") (("1" (assert) nil nil) ("2" (hide-all-but (1 "newid2-prop" -1)) (("2" (case "val(res1)`1 = val(res2)`1") (("1" (replaces -1) nil nil) ("2" (case "val(res1)`1 < val(res2)`1") (("1" (hide-all-but (-1 -2 2)) (("1" (case "transitive?[real](<)") (("1" (expand "transitive?") (("1" (inst? -1 :where 1) (("1" (inst? -1 :where -2) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "updN2" 1) (("2" (hide 3) (("2" (use "gnbi_upd_2") (("2" (assert) (("2" (typepred "i!1") (("2" (expand "idxs_bounded") (("2" (inst "cache2-idxs_bound" "j") (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (flatten) (("2" (hide 1) (("2" (use "next_idx_pow_var_ac") (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -4 "cache2-idxs_bound") (("2" (replace -1 "cache2-idxs_bound") (("2" (hide-all-but ("cache2-idxs_bound" -5 -6)) (("2" (case "i!1 = opn(nth(cache2, j)`1) - 2") (("1" (hide -2) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand ">=") (("1" (use "both_sides_plus_le1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i!1 < opn(nth(cache2, j)`1) - 2") (("1" (hide (-2 1)) (("1" (replaces -2 :dir RL) (("1" (expand ">=") (("1" (lemma "nth_ol[nat,<]") (("1" (inst -1 "nth(cache2, j)`3" "opn(nth(cache2, j)`1) - 2" "i!1") (("1" (case "nth(nth(cache2, j)`3, opn(nth(cache2, j)`1) - 2) < nth(nth(cache2, j)`3, i!1)") (("1" (hide "cache2-idxs_bound") (("1" (hide -3) (("1" (name-replace "A" "nth(nth(cache2, j)`3, opn(nth(cache2, j)`1) - 2)") (("1" (name-replace "B" "nth(nth(cache2, j)`3, i!1)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -3 1 :dir RL) (("2" (use "eval_upd_no_idxs_ac") (("2" (assert) (("2" (hide 1) (("2" (expand "idxs_bounded" "cache2-idxs_bound") (("2" (expand "idxs_ac") (("2" (inst "cache2-idxs_bound" "j") (("2" (expand "next_idx") (("2" (hide-all-but ("cache2-idxs_bound" -1)) (("2" (use "beyond_last_idx_notmember") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "mul_noise_value_is_Epsilon") nil nil)) nil)) nil)) nil)) nil) ("4" (replaces "result") (("4" (assert) (("4" (typepred_res2) (("4" (typepred_res1) (("4" (hide-all-but (3 "newid2-prop" "newid1-prop")) (("4" (expand ">=") (("4" (case "nextfreeidx <= newid2") (("1" (hide-all-but (-1 1)) (("1" (lemma "lt_plus_lt2") (("1" (inst -1 "newid2" "0" "1" "nextfreeidx") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (typepred "reals.<=") (("2" (expand "total_order?") (("2" (expand "partial_order?") (("2" (expand "preorder?") (("2" (expand "reflexive?") (("2" (expand "transitive?") (("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (replaces "result") (("5" (assert) (("5" (expand "idxs_bounded") (("5" (skeep) (("5" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (use "next_idx_mult_ac_ac") (("1" (expand ">=") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred_res2) (("2" (expand "idxs_bounded") (("2" (inst "cache2-idxs_bound" "i-1") (("1" (expand "nth" 3) (("1" (hide-all-but (3 "cache2-idxs_bound")) (("1" (expand ">=") (("1" (lemma "lt_plus_lt2") (("1" (inst -1 "newid2" "0" "1" "next_idx(pd(nth(cache2, i - 1)`2))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (next_idx_mult_ac_ac formula-decl nil affine nil) (i skolem-const-decl "below(length(cons((re, mult_ac_ac(ac1, ac2, newid2), null), cache2)))" affine_expr_Eval_fnd nil) (re skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (lt_plus_lt2 formula-decl nil real_props nil) (preorder? const-decl "bool" orders nil) (antisymmetric? const-decl "bool" relations nil) (dichotomous? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (partial_order? const-decl "bool" orders nil) (total_order? const-decl "bool" orders nil) (realorder? const-decl "bool" real_orders reals) (mul_noise_value_is_Epsilon judgement-tcc nil affine nil) (containment_mul formula-decl nil affine nil) (Env type-eq-decl nil box interval_arith) (gnbi_upd formula-decl nil affine nil) (first_noises_upd formula-decl nil affine nil) (length_append formula-decl nil list_props nil) (nth_append formula-decl nil more_list_props structures) (i!1 skolem-const-decl "below(length(cache1))" affine_expr_Eval_fnd nil) (l2 skolem-const-decl "list[CacheData]" affine_expr_Eval_fnd nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (beyond_last_idx_notmember formula-decl nil affine nil) (idxs_ac const-decl "list[nat]" affine nil) (eval_upd_no_idxs_ac formula-decl nil affine nil) (eval def-decl "real" interval_expr interval_arith) (updN2 skolem-const-decl "{N_: Noise |
   (null_ol?(N2) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = newid2)) AND
    (NOT null_ol?(N2) IMPLIES
      null_ol?(N_) OR
       ((newid2 < car_ol(N2)`1 AND car_ol(N_)`1 = newid2) OR
         (newid2 > car_ol(N2)`1 AND car_ol(N_)`1 = car_ol(N2)`1) OR
          car_ol(N_)`1 >= min(car_ol(N2)`1, newid2)))}" affine_expr_Eval_fnd nil) (last_idx_box formula-decl nil affine_box nil) (olidx_car_last formula-decl nil indexed_list structures) (last_ol def-decl "T" ordered_list structures) (strict_order? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (transitive? const-decl "bool" relations nil) (cache_powvar_correct formula-decl nil affine_expr_Eval_fnd nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth_ol formula-decl nil ordered_list structures) (i!1 skolem-const-decl "below(opn(nth(cache2, j)`1) - 1)" affine_expr_Eval_fnd nil) (j skolem-const-decl "int" affine_expr_Eval_fnd nil) (both_sides_plus_le1 formula-decl nil real_props nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (get_noise_by_idx def-decl "Epsilon" affine nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (ac_proj_pd formula-decl nil affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (below type-eq-decl nil nat_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (lt_idx_strict_order formula-decl nil indexed_list structures) (gnbi_upd_2 formula-decl nil affine nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (first_noises const-decl "Noise" affine nil) (mul_noise_value const-decl "real" affine nil) (upd_noise def-decl "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" affine nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (car_ol const-decl "T" ordered_list structures) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (newid2 skolem-const-decl "nat" affine_expr_Eval_fnd nil) (nzBaseType type-eq-decl nil affine nil) (next_idx_2 const-decl "nat" affine nil) (ac1 skolem-const-decl "AffineCombination" affine_expr_Eval_fnd nil) (ac2 skolem-const-decl "AffineCombination" affine_expr_Eval_fnd nil) (null adt-constructor-decl "(null?)" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (append_assoc formula-decl nil list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (length def-decl "nat" list_props nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (cache1 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval_fnd nil) (below type-eq-decl nil naturalnumbers nil) (real_minus_real_is_real application-judgement "real" reals nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (int_plus_int_is_int application-judgement "int" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (cache2 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval_fnd nil) (nth def-decl "T" list_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_times_real_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (null_ol? const-decl "bool" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (append_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (mult_ac_ac const-decl "AffineCombination" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC39-3 nil 3767016536 ("" (skeep*) (("" (assert) (("" (hide -12) (("" (apply (then (label "result" -11) (label "ac2" -10) (label "cache2" -9) (label "newid2" -8) (label "res2" -7) (label "ac1" -6) (label "cache1" -5) (label "newid1" -4) (label "res1" -3) (label "cached" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (with-labels (flatten) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound"))))) (("" (deftactic typepred_res1 nil (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (with-labels (flatten) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound"))))) (("" (split 4) (("1" (grind) nil nil) ("2" (replaces "result") (("2" (assert) (("2" (typepred_res1) (("2" (typepred_res2) (("2" (skolem "cache2-form" "l2") (("2" (skolem "cache1-form" "l1") (("2" (replace "cache1-form" "cache2-form") (("2" (replace "cache2-form" 3) (("2" (inst 3 "cons((re, mult_ac_ac(ac1, ac2, newid2), null)::CacheData, append(l2,l1))") (("1" (hide-all-but 3) (("1" (expand "append" 1 3) (("1" (use "append_assoc[CacheData]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (expand "next_idx_2") (("3" (expand ">=") (("3" (expand "idxs_bounded") (("3" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (1 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (expand "max") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand ">=") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand ">=") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred_res2) (("3" (skolem "N2" "N2") (("3" (with-labels (flatten) (("N2 vars in box comp" "N2 compatible pairs"))) (("3" (name "updN2" "upd_noise(N2,
                                                                                                   newid2,
                                                                                                   mul_noise_value
                                                                                                   (ac1,
                                                                                                    ac2,
                                                                                                    first_noises(N2, newid2)))") (("1" (inst 2 "updN2") (("1" (split 2) (("1" (expand "vars_in_box_compatible?") (("1" (skeep) (("1" (inst "N2 vars in box comp" "i") (("1" (flatten) (("1" (case "get_noise_by_idx(i, updN2) = get_noise_by_idx(i, N2)") (("1" (split 1) (("1" (replace "N2 vars in box comp" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (expand_ol) (("2" (assert) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (expand_ol) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (use "gnbi_upd_2") (("2" (assert) (("2" (typepred_res1) (("2" (typepred "nextfreeidx") (("2" (expand "last_idx_in_box") (("2" (replaces -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skeep) (("2" (case "i=0") (("1" (skeep) (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "result") (("1" (assert) (("1" (expand "powvar?") (("1" (replaces "re") (("1" (expand "eval_ACExpr_Env" 1) (("1" (expand "eval") (("1" (use "containment_mul") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (typepred_res1) (("1" (expand "next_idx_2") (("1" (expand ">=") (("1" (expand "idxs_bounded") (("1" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (2 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (expand "max") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand ">=") (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand ">=") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "eval_ac_noise(ac1, updN2) = eval_ac_noise(ac1, N2)") (("1" (replaces -1) (("1" (typepred_res1) (("1" (replaces "re1" :dir RL) (("1" (skolem "N1" "N1") (("1" (with-labels (flatten) (("N1 vars in box comp" "N1 compatible pairs"))) (("1" (case "FORALL (i: below(length(cache1))):
                                                                                                                                                                                                                                                                                             eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                                                                                                                                              eval_ac_noise(nth(cache1, i)`2, N1)") (("1" (replace "ac1") (("1" (inst -1 "0") (("1" (expand "nth" -1) (("1" (replaces -1) (("1" (expand "compatible_pairs_on?" "N1 compatible pairs") (("1" (inst "N1 compatible pairs" "0") (("1" (inst "N1 compatible pairs" "n") (("1" (flatten) (("1" (expand "nth") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?" "N1 compatible pairs") (("2" (skeep) (("2" (inst "N1 compatible pairs" "i!1") (("2" (inst "N1 compatible pairs" "n") (("2" (skolem "cache2-form" "l2") (("2" (replace "cache2-form" "N2 compatible pairs") (("2" (inst "N2 compatible pairs" "length(l2)+i!1") (("1" (inst "N2 compatible pairs" "n") (("1" (case "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") (("1" (assert) (("1" (flatten) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (use "more_list_props[CacheData].nth_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace "cache2-form" 1) (("2" (use "length_append[[RealExpr, AffineCombination]]") (("2" (replaces -1) (("2" (assert) (("2" (use "length_append[CacheData]") (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replaces -1 1 :dir RL) (("2" (use "eval_upd_no_idxs_ac") (("2" (assert) (("2" (hide 1) (("2" (replace "ac1" -1) (("2" (typepred_res1) (("2" (expand "idxs_bounded" "cache1-idxs_bound") (("2" (expand "idxs_ac") (("2" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (expand "next_idx") (("1" (hide-all-but ("cache1-idxs_bound" -6 "newid2-prop")) (("1" (use "beyond_last_idx_notmember") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "eval_ac_noise(ac2, updN2) = eval_ac_noise(ac2, N2)") (("1" (replaces -1) (("1" (inst "N2 compatible pairs" "0") (("1" (inst "N2 compatible pairs" "n") (("1" (expand "nth" "N2 compatible pairs") (("1" (assert) (("1" (expand "length") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replaces -1 1 :dir RL) (("2" (use "eval_upd_no_idxs_ac") (("2" (assert) (("2" (hide 1) (("2" (expand "idxs_bounded" "cache2-idxs_bound") (("2" (expand "idxs_ac") (("2" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (expand "next_idx") (("1" (hide-all-but ("cache2-idxs_bound" -1)) (("1" (use "beyond_last_idx_notmember") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replaces -1 :dir RL) (("4" (use "first_noises_upd") (("4" (replaces -1) (("4" (use "gnbi_upd") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "j" "i-1") (("2" (typepred "i") (("2" (expand "length" -1) (("2" (expand "nth" 2) (("2" (assert) (("2" (replace -2) (("2" (replace "result") (("2" (assert) (("2" (skeep) (("2" (inst "N2 compatible pairs" "j") (("2" (inst "N2 compatible pairs" "n") (("2" (flatten) (("2" (case "eval_ac_noise(nth(cache2, j)`2, updN2) = eval_ac_noise(nth(cache2, j)`2, N2)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (flatten) (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (case "get_noise_by_idx(nth(nth(cache2, j)`3, i!1), updN2) = get_noise_by_idx(nth(nth(cache2, j)`3, i!1), N2)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))),
                                                                                                                                                                                0)`1,
                                                                                                                                                                            updN2) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))),
                                                                                                                                                                                0)`1,
                                                                                                                                                                            N2)") (("1" (replaces -1) nil nil) ("2" (hide 3) (("2" (expand "updN2") (("2" (lemma "gnbi_upd_2") (("2" (inst? -1 :where 1) (("2" (assert) (("2" (typepred "res1") (("2" (assert) (("2" (flatten) (("2" (typepred "nextfreeidx") (("2" (hide-all-but (-1 "newid2-prop" -5 "newid1" "newid2" -7 -13)) (("2" (replaces "newid1") (("2" (replaces "newid2") (("2" (expand "nth" -3 1) (("2" (use "last_idx_box") (("2" (expand "next_idx") (("2" (use "olidx_car_last[nzBaseType]") (("2" (case "NOT null?(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))") (("1" (assert) (("1" (expand "last_idx") (("1" (expand ">=") (("1" (expand ">") (("1" (case "last_ol(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))`1 < nextfreeidx") (("1" (hide -3 -4) (("1" (case "car_ol(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))`1 < nextfreeidx") (("1" (hide -2 -3) (("1" (expand "car_ol") (("1" (replaces -3) (("1" (case "val(res1)`1 < nextfreeidx") (("1" (assert) nil nil) ("2" (hide-all-but (1 "newid2-prop" -1)) (("2" (case "val(res1)`1 = val(res2)`1") (("1" (replaces -1) nil nil) ("2" (case "val(res1)`1 < val(res2)`1") (("1" (hide-all-but (-1 -2 2)) (("1" (case "transitive?[real](<)") (("1" (expand "transitive?") (("1" (inst? -1 :where 1) (("1" (inst? -1 :where -2) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "updN2" 1) (("2" (hide 3) (("2" (use "gnbi_upd_2") (("2" (assert) (("2" (typepred "i!1") (("2" (expand "idxs_bounded") (("2" (inst "cache2-idxs_bound" "j") (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (flatten) (("2" (hide 1) (("2" (use "next_idx_pow_var_ac") (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -4 "cache2-idxs_bound") (("2" (replace -1 "cache2-idxs_bound") (("2" (hide-all-but ("cache2-idxs_bound" -5 -6)) (("2" (case "i!1 = opn(nth(cache2, j)`1) - 2") (("1" (hide -2) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand ">=") (("1" (use "both_sides_plus_le1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i!1 < opn(nth(cache2, j)`1) - 2") (("1" (hide (-2 1)) (("1" (replaces -2 :dir RL) (("1" (expand ">=") (("1" (lemma "nth_ol[nat,<]") (("1" (inst -1 "nth(cache2, j)`3" "opn(nth(cache2, j)`1) - 2" "i!1") (("1" (case "nth(nth(cache2, j)`3, opn(nth(cache2, j)`1) - 2) < nth(nth(cache2, j)`3, i!1)") (("1" (hide "cache2-idxs_bound") (("1" (hide -3) (("1" (name-replace "A" "nth(nth(cache2, j)`3, opn(nth(cache2, j)`1) - 2)") (("1" (name-replace "B" "nth(nth(cache2, j)`3, i!1)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -3 1 :dir RL) (("2" (use "eval_upd_no_idxs_ac") (("2" (assert) (("2" (hide 1) (("2" (expand "idxs_bounded" "cache2-idxs_bound") (("2" (expand "idxs_ac") (("2" (inst "cache2-idxs_bound" "j") (("2" (expand "next_idx") (("2" (hide-all-but ("cache2-idxs_bound" -1)) (("2" (use "beyond_last_idx_notmember") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "mul_noise_value_is_Epsilon") nil nil)) nil)) nil)) nil)) nil) ("4" (replaces "result") (("4" (assert) (("4" (typepred_res2) (("4" (typepred_res1) (("4" (hide-all-but (3 "newid2-prop" "newid1-prop")) (("4" (expand ">=") (("4" (case "nextfreeidx <= newid2") (("1" (hide-all-but (-1 1)) (("1" (lemma "lt_plus_lt2") (("1" (inst -1 "newid2" "0" "1" "nextfreeidx") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (typepred "reals.<=") (("2" (expand "total_order?") (("2" (expand "partial_order?") (("2" (expand "preorder?") (("2" (expand "reflexive?") (("2" (expand "transitive?") (("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (replaces "result") (("5" (assert) (("5" (expand "idxs_bounded") (("5" (skeep) (("5" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (use "next_idx_mult_ac_ac") (("1" (expand ">=") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred_res2) (("2" (expand "idxs_bounded") (("2" (inst "cache2-idxs_bound" "i-1") (("1" (expand "nth" 3) (("1" (hide-all-but (3 "cache2-idxs_bound")) (("1" (expand ">=") (("1" (lemma "lt_plus_lt2") (("1" (inst -1 "newid2" "0" "1" "next_idx(pd(nth(cache2, i - 1)`2))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((next_idx_mult_ac_ac formula-decl nil affine nil) (realorder? const-decl "bool" real_orders reals) (mul_noise_value_is_Epsilon judgement-tcc nil affine nil) (containment_mul formula-decl nil affine nil) (Env type-eq-decl nil box interval_arith) (gnbi_upd formula-decl nil affine nil) (first_noises_upd formula-decl nil affine nil) (nth_append formula-decl nil more_list_props structures) (beyond_last_idx_notmember formula-decl nil affine nil) (idxs_ac const-decl "list[nat]" affine nil) (eval_upd_no_idxs_ac formula-decl nil affine nil) (eval def-decl "real" interval_expr interval_arith) (last_idx_box formula-decl nil affine_box nil) (olidx_car_last formula-decl nil indexed_list structures) (last_ol def-decl "T" ordered_list structures) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth_ol formula-decl nil ordered_list structures) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (get_noise_by_idx def-decl "Epsilon" affine nil) (ac_proj_pd formula-decl nil affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (lt_idx_strict_order formula-decl nil indexed_list structures) (gnbi_upd_2 formula-decl nil affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (first_noises const-decl "Noise" affine nil) (mul_noise_value const-decl "real" affine nil) (upd_noise def-decl "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" affine nil) (car_ol const-decl "T" ordered_list structures) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (nzBaseType type-eq-decl nil affine nil) (next_idx_2 const-decl "nat" affine nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (append_ol const-decl "ordered_list" ordered_list structures) (mult_ac_ac const-decl "AffineCombination" affine nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC39-2 nil 3632069106 ("" (grind) nil nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Env type-eq-decl nil affine_box nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (pow_var_compatible? const-decl "bool" affine_pow nil) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC39-1 nil 3631466640 ("" (grind) nil nil) ((Interval type-eq-decl nil interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_ol const-decl "ordered_list" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil)) shostak (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC44 0 (RE2AC_TCC44-1 nil 3789916158 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length_singleton formula-decl nil more_list_props structures) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC45 0 (RE2AC_TCC40-3 nil 3632069583 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_minus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "affine_expr_Eval_fnd.idx" "{i | reals.<(affine_box.i, list_props[Interval].length(affine_expr_Eval_fnd.box))}")) (RE2AC_TCC40-2 nil 3632069241 ("" (skeep*) (("" (assert) (("" (hide -12) (("" (apply (then (label "result" -11) (label "ac2" -10) (label "cache2" -9) (label "newid2" -8) (label "res2" -7) (label "ac1" -6) (label "cache1" -5) (label "newid1" -4) (label "res1" -3) (label "cached" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten) (label "re2" -1) (label "cache2-form" -2) (label "N2" -3) (label "newid2-prop" -4) (label "cache2-idxs_bound" -5) (label "cache2 correct" -6))) (("" (deftactic typepred_res1 nil (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten) (label "re1" -1) (label "cache1-form" -2) (label "N1" -3) (label "newid1-prop" -4) (label "cache1-idxs_bound" -5) (label "cache1 correct" -6))) (("" (split 4) (("1" (grind) nil) ("2" (replaces "result") (("2" (assert) (("2" (typepred_res1) (("2" (typepred_res2) (("2" (skolem "cache2-form" "l2") (("2" (skolem "cache1-form" "l1") (("2" (replace "cache1-form" "cache2-form") (("2" (replace "cache2-form" 3) (("2" (inst 3 "cons((re, mult_ac_ac(ac1, ac2, newid2), null)::CacheData, append(l2,l1))") (("1" (hide-all-but 3) (("1" (expand "append" 1 3) (("1" (use "append_assoc[CacheData]") (("1" (assert) nil))))))) ("2" (grind) nil) ("3" (expand "next_idx_2") (("3" (expand ">=") (("3" (expand "idxs_bounded") (("3" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (1 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (expand "max") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand ">=") (("1" (propax) nil))))) ("2" (flatten) (("2" (assert) (("2" (expand ">=") (("2" (grind) nil))))))))))))))))))) ("2" (grind) nil))))))) ("2" (hide-all-but (1 4)) (("2" (grind) nil))))))))))))))))))))))))))))) ("3" (typepred_res2) (("3" (skolem "N2" "N2") (("3" (with-labels (flatten) (("N2 vars in box comp" "N2 compatible pairs"))) (("3" (name "updN2" "upd_noise(N2,
                                                                   newid2,
                                                                   mul_noise_value
                                                                   (ac1,
                                                                    ac2,
                                                                    first_noises(N2, newid2)))") (("1" (inst 2 "updN2") (("1" (split 2) (("1" (expand "vars_in_box_compatible?") (("1" (skeep) (("1" (inst "N2 vars in box comp" "i") (("1" (flatten) (("1" (case "get_noise_by_idx(i, updN2) = get_noise_by_idx(i, N2)") (("1" (split 1) (("1" (replace "N2 vars in box comp" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (assert) nil))))))))))))))))))))))))))))))) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (expand_ol) (("2" (assert) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (expand_ol) (("2" (assert) nil))))))))))))))))))))))))) ("2" (flatten) (("2" (assert) nil))))) ("2" (typepred "i") (("2" (use "gnbi_upd_2") (("2" (assert) (("2" (typepred_res1) (("2" (typepred "nextfreeidx") (("2" (expand "last_idx_in_box") (("2" (replaces -7) (("2" (assert) nil))))))))))))))))))))))))) ("2" (expand "compatible_pairs_on?") (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "result") (("1" (assert) (("1" (expand "eval_ACExpr_Env" 1) (("1" (replaces "re") (("1" (assert) (("1" (use "containment_mul") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (typepred_res1) (("1" (expand "next_idx_2") (("1" (expand ">=") (("1" (expand "idxs_bounded") (("1" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (2 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (("1" (expand "max") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand ">=") (("1" (propax) nil))))) ("2" (flatten) (("2" (assert) (("2" (expand ">=") (("2" (grind) nil))))))))))))))))))) ("2" (grind) nil))))))) ("2" (grind) nil))))))))))) ("2" (case "eval_ac_noise(ac1, updN2) = eval_ac_noise(ac1, N2)") (("1" (replaces -1) (("1" (typepred_res1) (("1" (replaces "re1" :dir RL) (("1" (skolem "N1" "N1") (("1" (with-labels (flatten) (("N1 vars in box comp" "N1 compatible pairs"))) (("1" (case "FORALL (i: below(length(cache1))):
                                                                                                                                                                                 eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                                  eval_ac_noise(nth(cache1, i)`2, N1)") (("1" (replace "ac1") (("1" (inst -1 "0") (("1" (expand "nth" -1) (("1" (replaces -1) (("1" (expand "compatible_pairs_on?" "N1 compatible pairs") (("1" (inst "N1 compatible pairs" "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil))))) ("2" (expand "length") (("2" (assert) nil))))))))))) ("2" (expand "length") (("2" (assert) nil))))))) ("2" (expand "compatible_pairs_on?" "N1 compatible pairs") (("2" (skeep) (("2" (inst "N1 compatible pairs" "i!1") (("2" (skolem "cache2-form" "l2") (("2" (replace "cache2-form" "N2 compatible pairs") (("2" (inst "N2 compatible pairs" "length(l2)+i!1") (("1" (case "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") (("1" (assert) (("1" (flatten) (("1" (replaces -1) (("1" (assert) nil))))))) ("2" (hide-all-but 1) (("2" (use "nth_append[CacheData]") (("2" (assert) nil))))))) ("2" (replace "cache2-form" 1) (("2" (use "length_append[[RealExpr, AffineCombination]]") (("2" (replaces -1) (("2" (assert) (("2" (use "length_append[CacheData]") (("2" (replaces -1) (("2" (assert) nil))))))))))))))))))))))))))))))))))))) ("2" (hide 2) (("2" (replaces -1 1 :dir RL) (("2" (use "eval_upd_no_idxs_ac") (("2" (assert) (("2" (hide 1) (("2" (replace "ac1" -1) (("2" (typepred_res1) (("2" (expand "idxs_bounded" "cache1-idxs_bound") (("2" (expand "idxs_ac") (("2" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (expand "next_idx") (("1" (hide-all-but ("cache1-idxs_bound" -7 "newid2-prop")) (("1" (use "beyond_last_idx_notmember") (("1" (assert) nil))))))))) ("2" (grind) nil))))))))))))))))))))))) ("3" (case "eval_ac_noise(ac2, updN2) = eval_ac_noise(ac2, N2)") (("1" (replaces -1) (("1" (inst "N2 compatible pairs" "0") (("1" (expand "nth" "N2 compatible pairs") (("1" (assert) nil))) ("2" (expand "length") (("2" (assert) nil))))))) ("2" (hide 2) (("2" (replaces -1 1 :dir RL) (("2" (use "eval_upd_no_idxs_ac") (("2" (assert) (("2" (hide 1) (("2" (expand "idxs_bounded" "cache2-idxs_bound") (("2" (expand "idxs_ac") (("2" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (expand "next_idx") (("1" (hide-all-but ("cache2-idxs_bound" -1)) (("1" (use "beyond_last_idx_notmember") (("1" (assert) nil))))))))) ("2" (grind) nil))))))))))))))))))) ("4" (replaces -1 :dir RL) (("4" (use "first_noises_upd") (("4" (replaces -1) (("4" (use "gnbi_upd") nil))))))))))))))))))))))))))))) ("2" (name "j" "i-1") (("2" (typepred "i") (("2" (expand "length" -1) (("2" (expand "nth" 2) (("2" (assert) (("2" (replace -2) (("2" (replace "result") (("2" (assert) (("2" (inst "N2 compatible pairs" "j") (("2" (flatten) (("2" (case "eval_ac_noise(nth(cache2, j)`2, updN2) = eval_ac_noise(nth(cache2, j)`2, N2)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (flatten) (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (case "get_noise_by_idx(nth(nth(cache2, j)`3, i!1), updN2) = get_noise_by_idx(nth(nth(cache2, j)`3, i!1), N2)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache2, j)`1))),
                                                                  0)`1,
                                                              updN2) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache2, j)`1))),
                                                                  0)`1,
                                                              N2)") (("1" (replaces -1) nil) ("2" (hide 3) (("2" (expand "updN2") (("2" (lemma "gnbi_upd_2") (("2" (inst? -1 :where 1) (("2" (assert) (("2" (typepred "res1") (("2" (assert) (("2" (flatten) (("2" (typepred "nextfreeidx") (("2" (hide-all-but (-1 "newid2-prop" -5 "newid1" "newid2" -8 -13)) (("2" (replaces "newid1") (("2" (replaces "newid2") (("2" (expand "nth" -3 1) (("2" (use "last_idx_box") (("2" (expand "next_idx") (("2" (use "olidx_car_last[nzBaseType]") (("2" (case "NOT null?(pd(nth_ac(box, varidx(nth(cache2, j)`1))))") (("1" (assert) (("1" (expand "last_idx") (("1" (expand ">=") (("1" (expand ">") (("1" (case "last_ol(pd(nth_ac(box, varidx(nth(cache2, j)`1))))`1 < nextfreeidx") (("1" (hide -3 -4) (("1" (case "car_ol(pd(nth_ac(box, varidx(nth(cache2, j)`1))))`1 < nextfreeidx") (("1" (hide -2 -3) (("1" (expand "car_ol") (("1" (replaces -3) (("1" (case "val(res1)`1 < nextfreeidx") (("1" (assert) nil) ("2" (hide-all-but (1 -4 -1)) (("2" (case "val(res1)`1 = val(res2)`1") (("1" (replaces -1) nil) ("2" (case "val(res1)`1 < val(res2)`1") (("1" (hide-all-but (-1 -2 2)) (("1" (case "transitive?[real](<)") (("1" (expand "transitive?") (("1" (inst? -1 :where 1) (("1" (inst? -1 :where -2) (("1" (assert) nil))))))) ("2" (grind) nil))))) ("2" (assert) nil))))))))))))))) ("2" (assert) nil))))) ("2" (assert) nil))))))))))) ("2" (reveal -14) (("2" (hide-all-but (-1 -2)) (("2" (expand "length") (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))))) ("2" (expand "updN2" 1) (("2" (hide 3) (("2" (use "gnbi_upd_2") (("2" (assert) (("2" (typepred "i!1") (("2" (expand "idxs_bounded") (("2" (inst "cache2-idxs_bound" "j") (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (flatten) (("2" (hide 1) (("2" (use "next_idx_pow_var_ac") (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (grind) nil))) ("2" (flatten) (("2" (replace -4 "cache2-idxs_bound") (("2" (replace -1 "cache2-idxs_bound") (("2" (hide-all-but ("cache2-idxs_bound" -5 -6)) (("2" (use "nth_ol[nat,<]") (("2" (replaces -3) (("2" (expand ">=") (("2" (hide -2) (("2" (case "nth(nth(cache2, j)`3, opn(nth(cache2, j)`1) - 2) < newid2") (("1" (hide -3) (("1" (name-replace "A" "nth(nth(cache2, j)`3, opn(nth(cache2, j)`1) - 2)") (("1" (use "tri_unique_lt1") (("1" (assert) nil))))))) ("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (replaces -3 1 :dir RL) (("2" (use "eval_upd_no_idxs_ac") (("2" (assert) (("2" (hide 1) (("2" (expand "idxs_bounded" "cache2-idxs_bound") (("2" (expand "idxs_ac") (("2" (inst "cache2-idxs_bound" "j") (("2" (expand "next_idx") (("2" (hide-all-but ("cache2-idxs_bound" -1)) (("2" (use "beyond_last_idx_notmember") (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (use "mul_noise_value_is_Epsilon") (("2" (flatten) (("2" (assert) nil))))))))))))) ("4" (replaces "result") (("4" (assert) (("4" (typepred_res2) (("4" (typepred_res1) (("4" (hide-all-but (3 "newid2-prop" "newid1-prop")) (("4" (expand ">=") (("4" (case "nextfreeidx <= newid2") (("1" (hide-all-but (-1 1)) (("1" (lemma "lt_plus_lt2") (("1" (inst -1 "newid2" "0" "1" "nextfreeidx") (("1" (assert) nil))))))) ("2" (hide 2) (("2" (assert) (("2" (typepred "reals.<=") (("2" (expand "total_order?") (("2" (expand "partial_order?") (("2" (expand "preorder?") (("2" (expand "reflexive?") (("2" (expand "transitive?") (("2" (flatten) (("2" (inst -1 "nextfreeidx" "newid1" "newid2") (("2" (split -1) (("1" (propax) nil) ("2" (propax) nil) ("3" (propax) nil))))))))))))))))))))))))))))))))))))) ("5" (replaces "result") (("5" (assert) (("5" (expand "idxs_bounded") (("5" (skeep) (("5" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (use "next_idx_mult_ac_ac") (("1" (expand ">=") (("1" (propax) nil))))))))) ("2" (typepred_res2) (("2" (expand "idxs_bounded") (("2" (inst "cache2-idxs_bound" "i-1") (("1" (expand "nth" 3) (("1" (hide-all-but (3 "cache2-idxs_bound")) (("1" (expand ">=") (("1" (lemma "lt_plus_lt2") (("1" (inst -1 "newid2" "0" "1" "next_idx(pd(nth(cache2, i - 1)`2))") (("1" (assert) nil))))))))))) ("2" (typepred "i") (("2" (grind) nil))))))))))))))))))) ("6" (replaces "result") (("6" (assert) (("6" (expand "correct_cache?" 1) (("6" (typepred_res2) (("6" (assert) (("6" (expand "CacheData_correct?") (("6" (propax) nil)))))))))))))))))))))))))) nil) nil nil (RE2AC subtype "affine_expr_Eval_fnd.idx" "{i | reals.<(affine_box.i, list_props[Interval].length(affine_expr_Eval_fnd.box))}")) (RE2AC_TCC40-1 nil 3631466640 ("" (grind)) ((var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (ordered_list? def-decl "bool" ordered_list structures)) nil (RE2AC subtype "affine_expr_Eval_fnd.idx" "{i | reals.<(affine_box.i, list_props[Interval].length(affine_expr_Eval_fnd.box))}"))) (RE2AC_TCC46 0 (RE2AC_TCC46-1 "" 3789917590 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow is cached" -4) (label "cached" -5) (label "result" -6) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (grind) nil nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (length def-decl "nat" list_props nil) (represents_var? const-decl "bool" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC41-1 nil 3631466640 ("" (then (skeep*) (assert) (hide -7) (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow is cached" -4) (label "cached" -5) (label "result" -6) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (replaces "re") (replaces "result") (assert) (spread (split 4) ((then (inst 1 "(: (POWVAR(idx, pow), val(cached)`2, val(cached)`3) :)") (grind)) (then (with-labels (typepred "cache") (("cache comp pairs" "cache idx bound"))) (expand "compatible_pairs?") (skeep) (inst 1 "N") (assert) (expand "compatible_pairs_on?") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (typepred "cached") (assert) (flatten) (skeep) (replaces -3 1 :dir RL) (inst?) (replaces "cache comp pairs") (spread (case "nth(cache, i!1)`1 = POWVAR(idx, pow)") ((assert) (then (hide 2) (reveal -3 "re") (replaces "re") (assert) (replaces -1) (hide-all-but (1 "pow is cached" -1)) (typepred "val(cached)`1") (apply-extensionality 1))))) (spread (inst "cache comp pairs" "i-1") ((then (expand "nth" 2) (assert)) (then (typepred "i") (grind))))))) (then (typepred "cache") (expand "idxs_bounded") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (typepred "cached") (assert) (flatten) (skeep) (replaces -3 1 :dir RL) (inst?)) (then (expand "nth" 2) (assert) (inst?)))))))) nil nil) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (represents_var? const-decl "bool" affine nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals)) shostak (RE2AC subtype "affine_expr_Eval_fnd.varac" "(affine.represents_var?)"))) (RE2AC_TCC47 0 (RE2AC_TCC47-1 "" 3789917591 ("" (skeep*) (("" (assert) (("" (hide 1) (("" (grind) nil nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (null_ol const-decl "ordered_list" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (length def-decl "nat" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].null_ol" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}")) (RE2AC_TCC42-2 nil 3631569740 ("" (then (skeep*) (assert) (hide 1) (hide -6) (grind)) nil nil) ((empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_ol const-decl "ordered_list" ordered_list structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].null_ol" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}")) (RE2AC_TCC42-1 nil 3631466640 ("" (subtype-tcc) nil nil) ((Interval type-eq-decl nil interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (next_idx const-decl "nat" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (idxs_ac const-decl "list[nat]" affine nil)) shostak (RE2AC subtype "ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].null_ol" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}"))) (RE2AC_TCC48 0 (RE2AC_TCC48-1 "" 3789917592 ("" (skeep*) (("" (assert) (("" (apply (then (label "result" -11) (label "ac2" -10) (label "cache2" -9) (label "newid2" -8) (label "res2" -7) (label "ac1" -6) (label "cache1" -5) (label "newid1" -4) (label "res1" -3) (label "cached" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (with-labels (flatten) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound"))))) (("" (deftactic typepred_res1 nil (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (with-labels (flatten) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound"))))) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (= const-decl "[T, T -> boolean]" equalities nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (ordered_list? def-decl "bool" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth def-decl "T" list_props nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (null_ol const-decl "ordered_list" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC43-1 nil 3631466640 ("" (then (skeep*) (assert) (hide -12) (apply (then (label "result" -11) (label "ac2" -10) (label "cache2" -9) (label "newid2" -8) (label "res2" -7) (label "ac1" -6) (label "cache1" -5) (label "newid1" -4) (label "res1" -3) (label "cached" -2) (label "re" -1))) (deftactic typepred_res2 nil (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (with-labels (flatten) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound"))))) (deftactic typepred_res1 nil (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (with-labels (flatten) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound"))))) (spread (split 4) ((grind) (then (replaces "result") (assert) (typepred_res1) (typepred_res2) (skolem "cache2-form" "l2") (skolem "cache1-form" "l1") (replace "cache1-form" "cache2-form") (replace "cache2-form" 3) (spread (inst 3 "cons((re, mult_ac_ac(ac1, ac2, newid2), null)::CacheData, append(l2,l1))") ((then (hide-all-but 3) (expand "append" 1 3) (use "append_assoc[CacheData]") (assert)) (grind) (then (expand "next_idx_2") (expand ">=") (expand "idxs_bounded") (spread (inst "cache1-idxs_bound" "0") ((then (expand "nth" "cache1-idxs_bound") (replace "ac1" :dir RL) (spread (inst "cache2-idxs_bound" "0") ((then (expand "nth" "cache2-idxs_bound") (replace "ac2" :dir RL) (hide-all-but (1 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (expand "max") (lift-if 1) (spread (split 1) ((then (flatten) (expand ">=") (propax)) (then (flatten) (assert) (expand ">=") (grind))))) (grind)))) (then (hide-all-but (1 4)) (grind)))))))) (then (typepred_res2) (skolem "N2" "N2") (with-labels (flatten) (("N2 vars in box comp" "N2 compatible pairs"))) (spread (name "updN2" "upd_noise(N2,
                                                                                       newid2,
                                                                                       mul_noise_value
                                                                                       (ac1,
                                                                                        ac2,
                                                                                        first_noises(N2, newid2)))") ((then (inst 2 "updN2") (spread (split 2) ((then (expand "vars_in_box_compatible?") (skeep) (inst "N2 vars in box comp" "i") (flatten) (spread (case "get_noise_by_idx(i, updN2) = get_noise_by_idx(i, N2)") ((spread (split 1) ((then (replace "N2 vars in box comp" 1 :dir RL) (expand "var_ac" 1) (lift-if 1) (spread (split 1) ((then (flatten) (expand "eval_ac_noise" 2) (assert) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (assert) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol) (assert)) (then (flatten) (expand "eval_ac_noise" 1) (use "eval_pd_noise_rec_pds_def") (expand_ol) (assert) (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol) (assert))))) (then (flatten) (assert)))) (then (typepred "i") (use "gnbi_upd_2") (assert) (typepred_res1) (typepred "nextfreeidx") (expand "last_idx_in_box") (replaces -7) (assert))))) (then (expand "compatible_pairs_on?") (skeep) (spread (case "i=0") ((then (skeep) (replaces -1) (expand "nth" 1) (replace "result") (assert) (expand "powvar?") (replaces "re") (expand "eval_ACExpr_Env" 1) (expand "eval") (use "containment_mul") (assert) (hide 2) (spread (split 1) ((then (typepred_res1) (expand "next_idx_2") (expand ">=") (expand "idxs_bounded") (spread (inst "cache1-idxs_bound" "0") ((then (expand "nth" "cache1-idxs_bound") (replace "ac1" :dir RL) (spread (inst "cache2-idxs_bound" "0") ((then (expand "nth" "cache2-idxs_bound") (replace "ac2" :dir RL) (hide-all-but (2 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound")) (expand "max") (lift-if 1) (spread (split 1) ((then (flatten) (expand ">=") (propax)) (then (flatten) (assert) (expand ">=") (grind))))) (grind)))) (grind)))) (spread (case "eval_ac_noise(ac1, updN2) = eval_ac_noise(ac1, N2)") ((then (replaces -1) (typepred_res1) (replaces "re1" :dir RL) (skolem "N1" "N1") (with-labels (flatten) (("N1 vars in box comp" "N1 compatible pairs"))) (spread (case "FORALL (i: below(length(cache1))):
                                                                                                                                                                                                                                                                   eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                                                                                                                    eval_ac_noise(nth(cache1, i)`2, N1)") ((then (replace "ac1") (spread (inst -1 "0") ((then (expand "nth" -1) (replaces -1) (expand "compatible_pairs_on?" "N1 compatible pairs") (spread (inst "N1 compatible pairs" "0") ((then (inst "N1 compatible pairs" "n") (flatten) (expand "nth") (grind)) (then (expand "length") (assert))))) (then (expand "length") (assert))))) (then (expand "compatible_pairs_on?" "N1 compatible pairs") (skeep) (inst "N1 compatible pairs" "i!1") (inst "N1 compatible pairs" "n") (skolem "cache2-form" "l2") (replace "cache2-form" "N2 compatible pairs") (spread (inst "N2 compatible pairs" "length(l2)+i!1") ((then (inst "N2 compatible pairs" "n") (spread (case "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") ((then (assert) (flatten) (replaces -1) (assert)) (then (hide-all-but 1) (use "more_list_props[CacheData].nth_append") (assert))))) (then (replace "cache2-form" 1) (use "length_append[[RealExpr, AffineCombination]]") (replaces -1) (assert) (use "length_append[CacheData]") (replaces -1) (assert)))))))) (then (hide 2) (replaces -1 1 :dir RL) (use "eval_upd_no_idxs_ac") (assert) (hide 1) (replace "ac1" -1) (typepred_res1) (expand "idxs_bounded" "cache1-idxs_bound") (expand "idxs_ac") (spread (inst "cache1-idxs_bound" "0") ((then (expand "nth" "cache1-idxs_bound") (expand "next_idx") (hide-all-but ("cache1-idxs_bound" -6 "newid2-prop")) (use "beyond_last_idx_notmember") (assert)) (grind)))))) (spread (case "eval_ac_noise(ac2, updN2) = eval_ac_noise(ac2, N2)") ((then (replaces -1) (spread (inst "N2 compatible pairs" "0") ((then (inst "N2 compatible pairs" "n") (expand "nth" "N2 compatible pairs") (assert) (expand "length") (grind)) (then (expand "length") (assert))))) (then (hide 2) (replaces -1 1 :dir RL) (use "eval_upd_no_idxs_ac") (assert) (hide 1) (expand "idxs_bounded" "cache2-idxs_bound") (expand "idxs_ac") (spread (inst "cache2-idxs_bound" "0") ((then (expand "nth" "cache2-idxs_bound") (expand "next_idx") (hide-all-but ("cache2-idxs_bound" -1)) (use "beyond_last_idx_notmember") (assert)) (grind)))))) (then (replaces -1 :dir RL) (use "first_noises_upd") (replaces -1) (use "gnbi_upd"))))) (then (name "j" "i-1") (typepred "i") (expand "length" -1) (expand "nth" 2) (assert) (replace -2) (replace "result") (assert) (skeep) (inst "N2 compatible pairs" "j") (inst "N2 compatible pairs" "n") (flatten) (spread (case "eval_ac_noise(nth(cache2, j)`2, updN2) = eval_ac_noise(nth(cache2, j)`2, N2)") ((then (assert) (flatten) (assert) (expand "pow_var_compatible?") (flatten) (assert) (skeep) (inst?) (spread (case "get_noise_by_idx(nth(nth(cache2, j)`3, i!1), updN2) = get_noise_by_idx(nth(nth(cache2, j)`3, i!1), N2)") ((then (replaces -1) (spread (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))),
                                                                                                                                                     0)`1,
                                                                                                                                                 updN2) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))),
                                                                                                                                                     0)`1,
                                                                                                                                                 N2)") ((replaces -1) (then (hide 3) (expand "updN2") (lemma "gnbi_upd_2") (inst? -1 :where 1) (assert) (typepred "res1") (assert) (flatten) (typepred "nextfreeidx") (hide-all-but (-1 "newid2-prop" -5 "newid1" "newid2" -7 -13)) (replaces "newid1") (replaces "newid2") (expand "nth" -3 1) (use "last_idx_box") (expand "next_idx") (use "olidx_car_last[nzBaseType]") (spread (case "NOT null?(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))") ((then (assert) (expand "last_idx") (expand ">=") (expand ">") (spread (case "last_ol(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))`1 < nextfreeidx") ((then (hide -3 -4) (spread (case "car_ol(pd(nth_ac(box, varidx_powvar(nth(cache2, j)`1))))`1 < nextfreeidx") ((then (hide -2 -3) (expand "car_ol") (replaces -3) (spread (case "val(res1)`1 < nextfreeidx") ((assert) (then (hide-all-but (1 "newid2-prop" -1)) (spread (case "val(res1)`1 = val(res2)`1") ((replaces -1) (spread (case "val(res1)`1 < val(res2)`1") ((then (hide-all-but (-1 -2 2)) (spread (case "transitive?[real](<)") ((then (expand "transitive?") (inst? -1 :where 1) (inst? -1 :where -2) (assert)) (grind)))) (assert))))))))) (assert)))) (assert)))) (then (expand "length") (assert)))))))) (then (expand "updN2" 1) (hide 3) (use "gnbi_upd_2") (assert) (typepred "i!1") (expand "idxs_bounded") (inst "cache2-idxs_bound" "j") (use "cache_powvar_correct") (expand "CacheData_correct?") (flatten) (hide 1) (use "next_idx_pow_var_ac") (lift-if -1) (spread (split -1) ((then (flatten) (grind)) (then (flatten) (spread (split -1) ((grind) (then (flatten) (replace -4 "cache2-idxs_bound") (replace -1 "cache2-idxs_bound") (hide-all-but ("cache2-idxs_bound" -5 -6)) (spread (case "i!1 = opn(nth(cache2, j)`1) - 2") ((then (hide -2) (replaces -1) (replaces -1) (expand ">=") (use "both_sides_plus_le1") (assert)) (spread (case "i!1 < opn(nth(cache2, j)`1) - 2") ((then (hide (-2 1)) (replaces -2 :dir RL) (expand ">=") (lemma "nth_ol[nat,<]") (inst -1 "nth(cache2, j)`3" "opn(nth(cache2, j)`1) - 2" "i!1") (spread (case "nth(nth(cache2, j)`3, opn(nth(cache2, j)`1) - 2) < nth(nth(cache2, j)`3, i!1)") ((then (hide "cache2-idxs_bound") (hide -3) (name-replace "A" "nth(nth(cache2, j)`3, opn(nth(cache2, j)`1) - 2)") (name-replace "B" "nth(nth(cache2, j)`3, i!1)") (grind)) (grind)))) (assert))))))))))))))) (then (replaces -3 1 :dir RL) (use "eval_upd_no_idxs_ac") (assert) (hide 1) (expand "idxs_bounded" "cache2-idxs_bound") (expand "idxs_ac") (inst "cache2-idxs_bound" "j") (expand "next_idx") (hide-all-but ("cache2-idxs_bound" -1)) (use "beyond_last_idx_notmember") (assert))))))))))) (then (use "mul_noise_value_is_Epsilon") (flatten) (assert))))) (then (replaces "result") (assert) (typepred_res2) (typepred_res1) (hide-all-but (3 "newid2-prop" "newid1-prop")) (expand ">=") (spread (case "nextfreeidx <= newid2") ((then (hide-all-but (-1 1)) (lemma "lt_plus_lt2") (inst -1 "newid2" "0" "1" "nextfreeidx") (assert)) (then (hide 2) (assert) (typepred "reals.<=") (expand "total_order?") (expand "partial_order?") (expand "preorder?") (expand "reflexive?") (expand "transitive?") (flatten) (grind))))) (then (replaces "result") (assert) (expand "idxs_bounded") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (use "next_idx_mult_ac_ac") (expand ">=") (propax)) (then (typepred_res2) (expand "idxs_bounded") (spread (inst "cache2-idxs_bound" "i-1") ((then (expand "nth" 3) (hide-all-but (3 "cache2-idxs_bound")) (expand ">=") (lemma "lt_plus_lt2") (inst -1 "newid2" "0" "1" "next_idx(pd(nth(cache2, i - 1)`2))") (assert)) (then (typepred "i") (grind))))))))))) nil nil) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_ol const-decl "ordered_list" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (ordered_list? def-decl "bool" ordered_list structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals)) shostak (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC49 0 (RE2AC_TCC44-2 nil 3767017620 ("" (skeep*) (("" (replaces -7) (("" (assert) (("" (expand "correct_cache?") (("" (expand "CacheData_correct?") (("" (flatten) (("" (split 2) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (length def-decl "nat" list_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (powvar? const-decl "bool" affine_expr nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth def-decl "T" list_props nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (null_ol const-decl "ordered_list" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (varidx_powvar const-decl "nat" affine_expr nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC44-1 nil 3631466640 ("" (then (skeep*) (assert) (expand "null_ol") (hide 1) (hide -6) (spread (split 1) ((grind) (then (replace -5 1) (assert) (inst 1 "(: (re, acRes,null)::CacheData :)") (grind)) (then (replace -5 1) (assert) (typepred "cache") (expand "compatible_pairs?") (skeep) (inst 1 "N") (assert) (expand "compatible_pairs_on?") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (spread (case "pow=0") ((then (replaces -1) (replaces -5) (replaces -7) (expand "pow_var_ac") (expand "eval_ACExpr_Env" 1) (expand "eval_ac_noise") (assert) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (assert) (use "expt_x0") (assert) (expand "pow_var_compatible?" 1) (grind)) (spread (case "pow=1") ((then (replaces -1) (replaces -5) (replaces -7) (expand "eval_ACExpr_Env" 2) (expand "pow_var_ac" 2) (lift-if 2) (spread (split 2) ((then (flatten) (replaces -7) (expand "eval_ac_noise") (assert) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (expand "nth_ac" 1) (expand "vars_in_box_compatible?") (inst -2 "idx") (flatten) (replaces -2 1 :dir RL) (expand "eval_ac_noise") (expand "nth_ac") (spread (case "pd(var_ac(nth(box, idx), idx)) = null") ((then (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1) (assert) (expand "pow_var_compatible?") (grind)) (then (expand "ordered_list?") (propax))))) (then (hide-all-but (-1 1)) (expand "length") (assert))))) (then (flatten) (spread (split 2) ((then (flatten) (expand "vars_in_box_compatible?") (inst -2 "idx") (flatten) (replaces -2 1 :dir RL) (replaces -7) (expand "eval_ac_noise" 1) (assert) (expand "nth_ac") (use "eval_pd_noise_rec_pds_def") (expand_ol) (lift-if -1) (spread (split -1) ((grind) (then (flatten) (replaces -1) (spread (case "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") ((then (replaces -1) (assert) (use "expt_x1") (replaces -1) (lemma "expt_x1") (inst? -1 :where 2) (assert) (expand "pow_var_compatible?") (grind)) (then (hide 3) (spread (case "cdr(pd(var_ac(nth(box, idx), idx))) = null") ((then (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol)) (grind)))) (then (typepred "pd(var_ac(nth[Interval](box, idx), idx))") (expand "ordered_list?" -1) (assert) (expand "ordered_list?") (propax)) (then (expand "length") (assert)))))))) (then (flatten) (expand "vars_in_box_compatible?") (inst -1 "idx") (flatten) (replaces -1 2 :dir RL) (expand "eval_ac_noise") (assert) (replaces -6) (expand "nth_ac") (use "expt_x1") (replaces -1) (use "expt_x1") (replaces -1) (assert) (use "eval_pd_noise_rec_pds_def") (lift-if -1) (spread (split -1) ((grind) (then (flatten) (replaces -1) (expand_ol) (spread (case "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") ((then (replaces -1) (assert) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1) (assert) (use "expt_x0") (replaces -1) (grind)) (then (expand "ordered_list?") (propax))))) (then (use "expt_x0") (replaces -1) (expand "nth" 1) (spread (typepred "car(pd
                                                                                                                          (var_ac(IF idx = 0 THEN car(box)
                                                                                                                                  ELSE nth(cdr(box), idx - 1)
                                                                                                                                  ENDIF,
                                                                                                                                  idx)))`2") ((then (expand "/=") (grind)) (then (flatten) (typepred "idx") (grind)) (then (flatten) (typepred "idx") (grind)) (then (flatten) (grind))))) (then (use "expt_x0") (replaces -1) (expand "nth" 1) (spread (typepred "car(pd
                                                                                                                                              (var_ac(IF idx = 0 THEN car(box)
                                                                                                                                                      ELSE nth(cdr(box), idx - 1)
                                                                                                                                                      ENDIF,
                                                                                                                                                      idx)))`2") ((then (expand "/=") (grind)) (then (flatten) (typepred "idx") (grind)) (then (flatten) (typepred "idx") (grind)) (then (flatten) (grind)))))))) (spread (case "cdr(pd(var_ac(nth(box, idx), idx))) = null") ((then (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol)) (grind))) (then (typepred "pd(var_ac(nth[Interval](box, idx), idx))") (expand "ordered_list?" -1) (assert) (expand "ordered_list?") (propax)) (then (expand "length") (assert)))))))))))))) (spread (split -6) ((grind) (then (replaces -8 3) (replaces -6 3) (expand "pow_var_ac") (assert) (expand "eval_ACExpr_Env" 3) (expand "eval_ac_noise") (assert) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (assert) (replaces -6) (expand "nth_ac") (expand "vars_in_box_compatible?") (inst -2 "idx") (flatten) (replaces -2 3 :dir RL) (expand "eval_ac_noise") (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (lift-if 3) (spread (split 3) ((then (flatten) (assert) (expand "pow_var_compatible?") (propax)) (then (flatten) (grind)))))))))))) (then (expand "nth" 2) (assert) (inst -2 "i-1") (typepred "i") (grind))))) (then (replace -5 1) (assert) (typepred "cache") (expand "idxs_bounded") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (replaces -7) (use "next_idx_pow_var_ac") (assert) (replaces -1) (typepred "nextfreeidx") (replaces -7) (expand "last_idx_in_box") (expand "nth_ac") (expand "var_ac" 1) (lift-if 1) (spread (split 1) ((then (flatten) (assert) (expand "next_idx") (expand "last_idx") (expand "last_ol") (reveal 1) (grind)) (then (flatten) (assert) (grind))))) (then (expand "nth" 2) (assert) (inst -2 "i-1"))))) (then (replaces -5) (assert) (expand "correct_cache?") (expand "CacheData_correct?") (replaces -1) (reveal 1) (assert) (spread (split -1) ((then (expand "length" 2 1) (flatten) (assert)) (then (flatten) (assert)))))))) nil nil) ((ge_realorder name-judgement "RealOrder" real_orders reals)) shostak (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC50 0 (RE2AC_TCC50-2 "" 3803766472 ("" (skeep*) (("" (assert) (("" (expand "null_ol") (("" (hide 1) (("" (hide -6) (("" (split 1) (("1" (grind) nil nil) ("2" (assert) (("2" (inst 1 "(: (re, acRes,null)::CacheData :)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("3" (assert) (("3" (typepred "cache") (("3" (expand "compatible_pairs?") (("3" (skeep) (("3" (inst 1 "N") (("3" (assert) (("3" (expand "compatible_pairs_on?") (("3" (skeep* 1) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (case "pow=0") (("1" (replace -11) (("1" (assert) (("1" (replace -6) (("1" (expand "powvar?" 1) (("1" (expand "varidx_powvar" 1) (("1" (reveal -2) (("1" (replaces -2) (("1" (replaces -1) (("1" (expand "pow_var_ac") (("1" (expand "eval_ACExpr_Env" 1) (("1" (expand "eval") (("1" (expand "eval_ac_noise") (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (use "expt_x0") (("1" (assert) (("1" (expand "pow_var_compatible?" 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "pow=1") (("1" (replace -11) (("1" (assert) (("1" (reveal -2) (("1" (replaces -2) (("1" (replaces -6) (("1" (replaces -1) (("1" (expand "eval_ACExpr_Env" 2) (("1" (expand "eval") (("1" (expand "pow_var_ac" 2) (("1" (lift-if 2) (("1" (split 2) (("1" (expand "eval" 1) (("1" (replace -6 1 :dir RL) (("1" (expand "powvar?" 1) (("1" (expand "varidx_powvar" 1) (("1" (replace -6 1 :dir RL) (("1" (flatten) (("1" (replaces -8) (("1" (expand "eval_ac_noise" 1) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (expand "nth_ac" 1) (("1" (with-labels (expand "vars_in_box_compatible?") (("vars in box"))) (("1" (inst "vars in box" "idx") (("1" (with-labels (flatten "vars in box") (("eval varac is vs" "when sing interval"))) (("1" (replaces "eval varac is vs" 1 :dir RL) (("1" (expand "eval_ac_noise" 1) (("1" (expand "nth_ac" -1) (("1" (case "pd(var_ac(nth(box, idx), idx)) = null") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "powvar?" 1) (("2" (expand "varidx_powvar" 1) (("2" (expand "eval") (("2" (replace -6 1 :dir RL) (("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (with-labels (expand "vars_in_box_compatible?") (("vars in box"))) (("1" (inst "vars in box" "idx") (("1" (with-labels (flatten "vars in box") (("eval varac is vs" "when sing interval"))) (("1" (replaces "eval varac is vs" 1 :dir RL) (("1" (replaces -8) (("1" (expand "eval_ac_noise" 1) (("1" (assert) (("1" (expand "nth_ac" -1) (("1" (expand "nth_ac" (1 -1)) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (lift-if -1) (("1" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replaces -1) (("2" (case "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") (("1" (replaces -1) (("1" (assert) (("1" (use "expt_x1") (("1" (replaces -1) (("1" (lemma "expt_x1") (("1" (inst? -1 :where 2) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (case "cdr(pd(var_ac(nth(box, idx), idx))) = null") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("3" (typepred "pd(var_ac(nth[Interval](box, idx), idx))") (("3" (expand "ordered_list?" -1) (("3" (assert) nil nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (with-labels (expand "vars_in_box_compatible?") (("vars in box"))) (("2" (inst "vars in box" "idx") (("2" (with-labels (flatten "vars in box") (("eval varac is vs" "when sing interval"))) (("2" (replaces "eval varac is vs" 2 :dir RL) (("2" (expand "eval_ac_noise" 2) (("2" (assert) (("2" (replaces -7) (("2" (expand "nth_ac" 1) (("2" (use "expt_x1") (("2" (replaces -1) (("2" (use "expt_x1") (("2" (replaces -1) (("2" (assert) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (lift-if -1) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replaces -1) (("2" (expand_ol) (("2" (case "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") (("1" (replaces -1) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (use "expt_x0") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ordered_list?") (("2" (propax) nil nil)) nil) ("3" (use "expt_x0") (("3" (replaces -1) (("3" (expand "nth" 1) (("3" (typepred "car(pd
                                                                                                                                                                                                                                        (var_ac(IF idx = 0 THEN car(box)
                                                                                                                                                                                                                                                ELSE nth(cdr(box), idx - 1)
                                                                                                                                                                                                                                                ENDIF,
                                                                                                                                                                                                                                                idx)))`2") (("1" (expand "/=") (("1" (grind) nil nil)) nil) ("2" (typepred "idx") (("2" (grind) nil nil)) nil) ("3" (flatten) (("3" (typepred "idx") (("3" (grind) nil nil)) nil)) nil) ("4" (flatten) (("4" (grind) nil nil)) nil) ("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "cdr(pd(var_ac(nth(box, idx), idx))) = null") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("3" (typepred "pd(var_ac(nth[Interval](box, idx), idx))") (("3" (expand "ordered_list?" -1) (("3" (assert) nil nil)) nil)) nil) ("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -9) (("1" (grind) nil nil) ("2" (reveal -2) (("2" (replace -11) (("2" (assert) (("2" (replace -1) (("2" (replace -7) (("2" (expand "powvar?" 3) (("2" (expand "varidx_powvar" 3) (("2" (expand "pow_var_ac") (("2" (assert) (("2" (expand "eval_ACExpr_Env" 3) (("2" (expand "eval" 3) (("2" (expand "eval" 3) (("2" (replace -9 3 :dir RL) (("2" (expand "eval_ac_noise") (("2" (assert) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (expand_ol) (("2" (replaces -1) (("2" (assert) (("2" (replaces -10) (("2" (expand "nth_ac") (("2" (with-labels (expand "vars_in_box_compatible?") (("vars in box"))) (("2" (inst "vars in box" "idx") (("2" (with-labels (flatten "vars in box") (("eval varac is vs" "when sing interval"))) (("2" (replaces "eval varac is vs" 3 :dir RL) (("2" (expand "eval_ac_noise" 3) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (expand_ol) (("2" (replaces -1) (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -10 :hide? t) (("2" (expand "nth" 2) (("2" (assert) (("2" (inst -3 "i-1") (("1" (inst -3 "n") nil nil) ("2" (typepred "i") (("2" (hide-all-but (-1 1 2)) (("2" (reveal -11) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -6 1) (("4" (assert) (("4" (typepred "cache") (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (reveal -2) (("1" (replaces -1) (("1" (use "next_idx_pow_var_ac") (("1" (assert) (("1" (replaces -1) (("1" (typepred "nextfreeidx") (("1" (replaces -8) (("1" (expand "last_idx_in_box") (("1" (expand "nth_ac") (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "next_idx") (("2" (expand "last_idx") (("2" (expand "last_ol") (("2" (reveal 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst? :subst ("i" "i-1")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC50-1 "" 3789917649 ("" (skeep*) (("" (assert) (("" (expand "null_ol") (("" (hide 1) (("" (hide -6) (("" (split 1) (("1" (grind) nil nil) ("2" (assert) (("2" (inst 1 "(: (re, acRes,null)::CacheData :)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("3" (assert) (("3" (typepred "cache") (("3" (expand "compatible_pairs?") (("3" (skeep) (("3" (inst 1 "N") (("3" (assert) (("3" (expand "compatible_pairs_on?") (("3" (skeep* 1) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (case "pow=0") (("1" (replace -11) (("1" (assert) (("1" (replace -7) (("1" (expand "powvar?" 1) (("1" (expand "varidx_powvar" 1) (("1" (reveal -2) (("1" (replaces -2) (("1" (replaces -1) (("1" (expand "pow_var_ac") (("1" (expand "eval_ACExpr_Env" 1) (("1" (expand "eval") (("1" (expand "eval_ac_noise") (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (use "expt_x0") (("1" (assert) (("1" (expand "pow_var_compatible?" 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "pow=1") (("1" (replace -11) (("1" (assert) (("1" (reveal -2) (("1" (replaces -2) (("1" (replaces -7) (("1" (replaces -1) (("1" (expand "eval_ACExpr_Env" 2) (("1" (expand "eval") (("1" (expand "pow_var_ac" 2) (("1" (lift-if 2) (("1" (split 2) (("1" (expand "eval" 1) (("1" (replace -6 1 :dir RL) (("1" (expand "powvar?" 1) (("1" (expand "varidx_powvar" 1) (("1" (replace -6 1 :dir RL) (("1" (flatten) (("1" (replaces -8) (("1" (expand "eval_ac_noise" 1) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (expand "nth_ac" 1) (("1" (with-labels (expand "vars_in_box_compatible?") (("vars in box"))) (("1" (inst "vars in box" "idx") (("1" (with-labels (flatten "vars in box") (("eval varac is vs" "when sing interval"))) (("1" (replaces "eval varac is vs" 1 :dir RL) (("1" (expand "eval_ac_noise" 1) (("1" (expand "nth_ac" -1) (("1" (case "pd(var_ac(nth(box, idx), idx)) = null") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "powvar?" 1) (("2" (expand "varidx_powvar" 1) (("2" (expand "eval") (("2" (replace -6 1 :dir RL) (("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (with-labels (expand "vars_in_box_compatible?") (("vars in box"))) (("1" (inst "vars in box" "idx") (("1" (with-labels (flatten "vars in box") (("eval varac is vs" "when sing interval"))) (("1" (replaces "eval varac is vs" 1 :dir RL) (("1" (replaces -8) (("1" (expand "eval_ac_noise" 1) (("1" (assert) (("1" (expand "nth_ac" -1) (("1" (expand "nth_ac" (1 -1)) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (lift-if -1) (("1" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replaces -1) (("2" (case "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") (("1" (replaces -1) (("1" (assert) (("1" (use "expt_x1") (("1" (replaces -1) (("1" (lemma "expt_x1") (("1" (inst? -1 :where 2) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (case "cdr(pd(var_ac(nth(box, idx), idx))) = null") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("3" (typepred "pd(var_ac(nth[Interval](box, idx), idx))") (("3" (expand "ordered_list?" -1) (("3" (assert) nil nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (with-labels (expand "vars_in_box_compatible?") (("vars in box"))) (("2" (inst "vars in box" "idx") (("2" (with-labels (flatten "vars in box") (("eval varac is vs" "when sing interval"))) (("2" (replaces "eval varac is vs" 2 :dir RL) (("2" (expand "eval_ac_noise" 2) (("2" (assert) (("2" (replaces -7) (("2" (expand "nth_ac" 1) (("2" (use "expt_x1") (("2" (replaces -1) (("2" (use "expt_x1") (("2" (replaces -1) (("2" (assert) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (lift-if -1) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replaces -1) (("2" (expand_ol) (("2" (case "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") (("1" (replaces -1) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (use "expt_x0") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ordered_list?") (("2" (propax) nil nil)) nil) ("3" (use "expt_x0") (("3" (replaces -1) (("3" (expand "nth" 1) (("3" (typepred "car(pd
                                                                                                                                                                                                                    (var_ac(IF idx = 0 THEN car(box)
                                                                                                                                                                                                                            ELSE nth(cdr(box), idx - 1)
                                                                                                                                                                                                                            ENDIF,
                                                                                                                                                                                                                            idx)))`2") (("1" (expand "/=") (("1" (grind) nil nil)) nil) ("2" (typepred "idx") (("2" (grind) nil nil)) nil) ("3" (flatten) (("3" (typepred "idx") (("3" (grind) nil nil)) nil)) nil) ("4" (flatten) (("4" (grind) nil nil)) nil) ("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "cdr(pd(var_ac(nth(box, idx), idx))) = null") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("3" (typepred "pd(var_ac(nth[Interval](box, idx), idx))") (("3" (expand "ordered_list?" -1) (("3" (assert) nil nil)) nil)) nil) ("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -8) (("1" (grind) nil nil) ("2" (reveal -2) (("2" (replace -11) (("2" (assert) (("2" (replace -1) (("2" (replace -8) (("2" (expand "powvar?" 3) (("2" (expand "varidx_powvar" 3) (("2" (expand "pow_var_ac") (("2" (assert) (("2" (expand "eval_ACExpr_Env" 3) (("2" (expand "eval" 3) (("2" (expand "eval" 3) (("2" (replace -9 3 :dir RL) (("2" (expand "eval_ac_noise") (("2" (assert) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (expand_ol) (("2" (replaces -1) (("2" (assert) (("2" (replaces -10) (("2" (expand "nth_ac") (("2" (with-labels (expand "vars_in_box_compatible?") (("vars in box"))) (("2" (inst "vars in box" "idx") (("2" (with-labels (flatten "vars in box") (("eval varac is vs" "when sing interval"))) (("2" (replaces "eval varac is vs" 3 :dir RL) (("2" (expand "eval_ac_noise" 3) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (expand_ol) (("2" (replaces -1) (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -10 :hide? t) (("2" (expand "nth" 2) (("2" (assert) (("2" (inst -3 "i-1") (("1" (inst -3 "n") nil nil) ("2" (typepred "i") (("2" (hide-all-but (-1 1 2)) (("2" (reveal -11) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -6 1) (("4" (assert) (("4" (typepred "cache") (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (reveal -2) (("1" (replaces -1) (("1" (use "next_idx_pow_var_ac") (("1" (assert) (("1" (replaces -1) (("1" (typepred "nextfreeidx") (("1" (replaces -9) (("1" (expand "last_idx_in_box") (("1" (expand "nth_ac") (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "next_idx") (("2" (expand "last_idx") (("2" (expand "last_ol") (("2" (reveal 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst? :subst ("i" "i-1")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (append def-decl "list[T]" list_props nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (NOT const-decl "[bool -> bool]" booleans nil) (i skolem-const-decl "below(length(result`2))" affine_expr_Eval_fnd nil) (result skolem-const-decl "[{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}, (cons?)]" affine_expr_Eval_fnd nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (eval_ac_noise const-decl "real" affine nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (real_times_real_is_real application-judgement "real" reals nil) (expt_x0 formula-decl nil exponentiation nil) (Env type-eq-decl nil box interval_arith) (pow_var_compatible? const-decl "bool" affine_pow nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ac_proj_pd formula-decl nil affine nil) (ac_proj_cv formula-decl nil affine nil) (eval def-decl "real" interval_expr interval_arith) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (varidx_powvar const-decl "nat" affine_expr nil) (below type-eq-decl nil nat_types nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (re1 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (expt_x1 formula-decl nil exponentiation nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (eval_pd_noise def-decl "real" affine nil) (idx skolem-const-decl "nat" affine_expr_Eval_fnd nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (int_minus_int_is_int application-judgement "int" integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (int_plus_int_is_int application-judgement "int" integers nil) (last_ol def-decl "T" ordered_list structures) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (represents_var? const-decl "bool" affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (null_ol const-decl "ordered_list" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC45-2 nil 3767017293 ("" (skeep*) (("" (assert) (("" (expand "null_ol") (("" (hide 1) (("" (hide -6) (("" (split 1) (("1" (grind) nil nil) ("2" (assert) (("2" (inst 1 "(: (re, acRes,null)::CacheData :)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("3" (assert) (("3" (typepred "cache") (("3" (expand "compatible_pairs?") (("3" (skeep) (("3" (inst 1 "N") (("3" (assert) (("3" (expand "compatible_pairs_on?") (("3" (skeep* 1) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (case "pow=0") (("1" (replace -11) (("1" (assert) (("1" (replace -7) (("1" (expand "powvar?" 1) (("1" (expand "varidx_powvar" 1) (("1" (reveal -2) (("1" (replaces -2) (("1" (replaces -7) (("1" (replaces -1) (("1" (expand "pow_var_ac") (("1" (expand "eval_ACExpr_Env" 1) (("1" (expand "eval") (("1" (expand "eval_ac_noise") (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (use "expt_x0") (("1" (assert) (("1" (expand "pow_var_compatible?" 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "pow=1") (("1" (replace -11) (("1" (assert) (("1" (reveal -2) (("1" (replaces -2) (("1" (replaces -7) (("1" (replaces -1) (("1" (expand "eval_ACExpr_Env" 2) (("1" (expand "eval") (("1" (expand "pow_var_ac" 2) (("1" (lift-if 2) (("1" (split 2) (("1" (expand "eval" 1) (("1" (replace -6 1 :dir RL) (("1" (expand "powvar?" 1) (("1" (expand "varidx_powvar" 1) (("1" (replace -6 1 :dir RL) (("1" (flatten) (("1" (replaces -8) (("1" (expand "eval_ac_noise" 1) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (expand "nth_ac" 1) (("1" (with-labels (expand "vars_in_box_compatible?") (("vars in box"))) (("1" (inst "vars in box" "idx") (("1" (with-labels (flatten "vars in box") (("eval varac is vs" "when sing interval"))) (("1" (replaces "eval varac is vs" 1 :dir RL) (("1" (expand "eval_ac_noise" 1) (("1" (expand "nth_ac" -1) (("1" (case "pd(var_ac(nth(box, idx), idx)) = null") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "powvar?" 1) (("2" (expand "varidx_powvar" 1) (("2" (expand "eval") (("2" (replace -6 1 :dir RL) (("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (with-labels (expand "vars_in_box_compatible?") (("vars in box"))) (("1" (inst "vars in box" "idx") (("1" (with-labels (flatten "vars in box") (("eval varac is vs" "when sing interval"))) (("1" (replaces "eval varac is vs" 1 :dir RL) (("1" (replaces -8) (("1" (expand "eval_ac_noise" 1) (("1" (assert) (("1" (expand "nth_ac" -1) (("1" (expand "nth_ac" (1 -1)) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (lift-if -1) (("1" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replaces -1) (("2" (case "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") (("1" (replaces -1) (("1" (assert) (("1" (use "expt_x1") (("1" (replaces -1) (("1" (lemma "expt_x1") (("1" (inst? -1 :where 2) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (case "cdr(pd(var_ac(nth(box, idx), idx))) = null") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("3" (typepred "pd(var_ac(nth[Interval](box, idx), idx))") (("3" (expand "ordered_list?" -1) (("3" (assert) nil nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (with-labels (expand "vars_in_box_compatible?") (("vars in box"))) (("2" (inst "vars in box" "idx") (("2" (with-labels (flatten "vars in box") (("eval varac is vs" "when sing interval"))) (("2" (replaces "eval varac is vs" 2 :dir RL) (("2" (expand "eval_ac_noise" 2) (("2" (assert) (("2" (replaces -7) (("2" (expand "nth_ac" 1) (("2" (use "expt_x1") (("2" (replaces -1) (("2" (use "expt_x1") (("2" (replaces -1) (("2" (assert) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (lift-if -1) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replaces -1) (("2" (expand_ol) (("2" (case "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") (("1" (replaces -1) (("1" (assert) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (use "expt_x0") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ordered_list?") (("2" (propax) nil nil)) nil) ("3" (use "expt_x0") (("3" (replaces -1) (("3" (expand "nth" 1) (("3" (typepred "car(pd
                                                                                                                                                                                                                    (var_ac(IF idx = 0 THEN car(box)
                                                                                                                                                                                                                            ELSE nth(cdr(box), idx - 1)
                                                                                                                                                                                                                            ENDIF,
                                                                                                                                                                                                                            idx)))`2") (("1" (expand "/=") (("1" (grind) nil nil)) nil) ("2" (typepred "idx") (("2" (grind) nil nil)) nil) ("3" (flatten) (("3" (typepred "idx") (("3" (grind) nil nil)) nil)) nil) ("4" (flatten) (("4" (grind) nil nil)) nil) ("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "cdr(pd(var_ac(nth(box, idx), idx))) = null") (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("3" (typepred "pd(var_ac(nth[Interval](box, idx), idx))") (("3" (expand "ordered_list?" -1) (("3" (assert) nil nil)) nil)) nil) ("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -8) (("1" (grind) nil nil) ("2" (reveal -2) (("2" (replaces -1 3) (("2" (replaces -8 3) (("2" (replace -11) (("2" (assert) (("2" (replace -1) (("2" (replace -8) (("2" (expand "powvar?" 3) (("2" (expand "varidx_powvar" 3) (("2" (expand "pow_var_ac") (("2" (assert) (("2" (expand "eval_ACExpr_Env" 3) (("2" (expand "eval" 3) (("2" (expand "eval" 3) (("2" (replace -9 3 :dir RL) (("2" (expand "eval_ac_noise") (("2" (assert) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (expand_ol) (("2" (replaces -1) (("2" (assert) (("2" (replaces -10) (("2" (expand "nth_ac") (("2" (with-labels (expand "vars_in_box_compatible?") (("vars in box"))) (("2" (inst "vars in box" "idx") (("2" (with-labels (flatten "vars in box") (("eval varac is vs" "when sing interval"))) (("2" (replaces "eval varac is vs" 3 :dir RL) (("2" (expand "eval_ac_noise" 3) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (expand_ol) (("2" (replaces -1) (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -10 :hide? t) (("2" (expand "nth" 2) (("2" (assert) (("2" (inst -3 "i-1") (("1" (inst -3 "n") nil nil) ("2" (typepred "i") (("2" (hide-all-but (-1 1 2)) (("2" (reveal -11) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -6 1) (("4" (assert) (("4" (typepred "cache") (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (reveal -2) (("1" (replaces -1) (("1" (use "next_idx_pow_var_ac") (("1" (assert) (("1" (replaces -1) (("1" (typepred "nextfreeidx") (("1" (replaces -9) (("1" (expand "last_idx_in_box") (("1" (expand "nth_ac") (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "next_idx") (("2" (expand "last_idx") (("2" (expand "last_ol") (("2" (reveal 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst? :subst ("i" "i-1")) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (ordered_list? def-decl "bool" ordered_list structures) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (eval_ac_noise const-decl "real" affine nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (nzBaseType type-eq-decl nil affine nil) (Env type-eq-decl nil box interval_arith) (pow_var_compatible? const-decl "bool" affine_pow nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (car_ol const-decl "T" ordered_list structures) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ac_proj_pd formula-decl nil affine nil) (ac_proj_cv formula-decl nil affine nil) (eval def-decl "real" interval_expr interval_arith) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (varidx_powvar const-decl "nat" affine_expr nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (get_noise_by_idx def-decl "Epsilon" affine nil) (eval_pd_noise def-decl "real" affine nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (last_ol def-decl "T" ordered_list structures) (represents_var? const-decl "bool" affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (null_ol const-decl "ordered_list" ordered_list structures)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC45-1 nil 3631466640 ("" (then (skeep*) (grind)) nil nil) ((ge_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals)) shostak (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC51 0 (RE2AC_TCC46-2 nil 3632070867 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (length_singleton formula-decl nil more_list_props structures) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (powvar? const-decl "bool" affine_expr nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.re" "(affine_expr.powvar?)")) (RE2AC_TCC46-1 nil 3631466640 ("" (skeep*) (("" (use "cache_powvar_correct_result") (("" (assert) (("" (replace -6 -1 :dir RL) (("" (expand "CacheData_correct?") (("" (typepred "cached") (("" (assert) (("" (flatten) (("" (assert) (("" (flatten) (("" (split -5) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replaces -8) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (Interval type-eq-decl nil interval interval_arith) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (idxs_pd def-decl "list[nat]" affine nil) (idxs_ac const-decl "list[nat]" affine nil) (null_ol? const-decl "bool" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.re" "(affine_expr.powvar?)"))) (RE2AC_TCC52 0 (RE2AC_TCC52-1 "" 3789917654 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow is cached" -4) (label "cached" -5) (label "result" -6) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "result") (("" (typepred "cache") (("" (typepred "cached") (("" (assert) (("" (flatten) (("" (use "cache_powvar_correct_result") (("" (assert) (("" (expand "CacheData_correct?") (("" (flatten) (("" (split -2) (("1" (flatten) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (varidx_powvar const-decl "nat" affine_expr nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1" "(IntervalExpr_adt.pow?)")) (RE2AC_TCC47-3 nil 3767017240 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow is cached" -4) (label "cached" -5) (label "result" -6) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "re") (("" (replaces "result") (("" (typepred "cache") (("" (typepred "cached") (("" (assert) (("" (flatten) (("" (use "cache_powvar_correct_result") (("" (assert) (("" (expand "CacheData_correct?") (("" (flatten) (("" (split -2) (("1" (flatten) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (varidx_powvar const-decl "nat" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (gt_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (RE2AC subtype "Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1" "(IntervalExpr_adt.pow?)")) (RE2AC_TCC47-2 nil 3637339644 ("" (then (skeep*) (assert) (hide -7) (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow is cached" -4) (label "cached" -5) (label "result" -6) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (replaces "re") (replaces "result") (assert) (spread (split 4) ((then (inst 1 "(: (POWVAR(idx, pow), val(cached)`2, val(cached)`3) :)") (grind)) (then (with-labels (typepred "cache") (("cache comp pairs" "cache idx bound" "cache correct" "UNKNOWN"))) (expand "compatible_pairs?") (skeep) (inst 1 "N") (assert) (expand "compatible_pairs_on?") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (typepred "cached") (assert) (flatten) (skeep) (replaces -3 1 :dir RL) (inst?) (replaces "cache comp pairs") (spread (case "nth(cache, i!1)`1 = POWVAR(idx, pow)") ((then (assert) (flatten) (assert) (replaces "pow is cached") (replaces -1) (assert)) (then (hide 2) (reveal -3 "re") (replaces "re") (assert) (replaces -1) (reveal -2) (replaces -1) (typepred "cached") (assert) (flatten) (reveal "re") (replace "re" -2) (assert) (replaces -2 1 :dir RL) (replaces "pow is cached" 1 :dir RL) (apply-extensionality))))) (spread (inst "cache comp pairs" "i-1") ((then (expand "nth" 2) (assert)) (then (typepred "i") (grind))))))) (then (typepred "cache") (expand "idxs_bounded") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (typepred "cached") (assert) (flatten) (skeep) (replaces -3 1 :dir RL) (inst?)) (then (expand "nth" 2) (assert) (inst?))))) (then (typepred "cache") (expand "correct_cache?" 1) (expand "CacheData_correct?") (typepred "cached") (assert) (flatten) (use "cache_powvar_correct_result") (assert) (replace "cached" -1 :dir RL) (expand "CacheData_correct?") (flatten) (spread (split -2) ((then (flatten) (assert) (reveal "re") (grind)) (then (reveal "re") (grind)))))))) nil nil) ((empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_ol const-decl "ordered_list" ordered_list structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1" "(IntervalExpr_adt.pow?)")) (RE2AC_TCC47-1 nil 3631466640 ("" (skeep*) (("" (assert) (("" (hide -10) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow < cached pow" -4) (label "cached" -5) (label "idxs" -6) (label "pownoises" -7) (label "acRes" -8) (label "result" -9) (label "idx" 1) (label "pow <= 1" 2) (label "no single value" 3) (label "no cv 0" 4))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 5) (("1" (inst 1 "(: (POWVAR(idx, pow), acRes, pownoises) :)") (("1" (grind) nil nil)) nil) ("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bound" "cache correct" "UNKNOWN"))) (("2" (expand "compatible_pairs?" "cache compatible pairs") (("2" (skeep) (("2" (inst 1 "N") (("2" (assert) (("2" (expand "compatible_pairs_on?" 1) (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "compatible_pairs_on?") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (skeep "cached cache idx") (("1" (inst "cache compatible pairs" "i!1") (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert) ("cached is correct" "UNKNOWN")) (("1" (replace "cached" "cached is correct" :dir RL) (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (flatten -8) (("1" (replace "cached`2 is powvarac" -8) (("1" (replace "acRes" 1) (("1" (replace "varac" 1) (("1" (replace "cached cache idx" "cached`1 varidx" :dir RL) (("1" (replace "cached`1 varidx" "cached is correct") (("1" (reveal "re") (("1" (replace "re" "cached is correct") (("1" (assert) (("1" (replace "cached cache idx" "pownoises" :dir RL) (("1" (replace "pownoises" "cached is correct" :dir RL) (("1" (case "nth(cache, i!1)`1 = POWVAR(idx, opn(nth(cache, i!1)`1))") (("1" (replaces -1) (("1" (expand "eval_ACExpr_Env") (("1" (use "powvarac_ind_on_pow") (("1" (assert) (("1" (inst -1 "pow") (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (skeep) (("1" (inst "cached is correct" "i!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "cached`1 is powvar" "cached`1 varidx" "re" "cached cache idx")) (("2" (replaces "cached cache idx" :dir RL) (("2" (replaces "re") (("2" (assert) (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (replace "varac" "no single value") (("2" (reveal "re") (("2" (hide-all-but ("no single value" "cached cond ok" "re")) (("2" (replaces "re") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?" "cache compatible pairs") (("2" (inst "cache compatible pairs" "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "idxs_bounded") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replaces "acRes") (("1" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bound" "cache correct" "UNKNOWN"))) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (skeep "cached cache idx") (("1" (inst "cache idxs bound" "i!1") (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert) ("cached is correct" "UNKNOWN")) (("1" (replace "cached" "cached is correct" :dir RL) (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (replace "cached`2 is powvarac" "cache idxs bound") (("1" (replace "cached cache idx" "pownoises" :dir RL) (("1" (replace "pownoises" "cache idxs bound" :dir RL) (("1" (replace "cached cache idx" "cached`1 varidx" :dir RL) (("1" (replace "cached`1 varidx" "cache idxs bound") (("1" (reveal "re") (("1" (replace "re" "cache idxs bound") (("1" (assert) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (lift-if "cache idxs bound") (("2" (split "cache idxs bound") (("1" (flatten) nil nil) ("2" (flatten) (("2" (hide-all-but (3 "cache idxs bound" "pow < cached pow" "cached cache idx")) (("2" (replaces "cached cache idx" :dir RL) (("2" (expand ">") (("2" (expand ">=") (("2" (use "nth_ol[nat,<]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (replace "varac" "no single value") (("2" (reveal "re") (("2" (hide-all-but ("no single value" "cached cond ok" "re")) (("2" (replaces "re") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bound" "cache correct" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bound") (("2" (inst "cache idxs bound" "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "correct_cache?" 1) (("4" (expand "CacheData_correct?") (("4" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bound" "cache correct" "UNKNOWN"))) (("4" (typepred "cached") (("4" (assert) (("4" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("4" (skeep "cached cache idx") (("4" (use "cache_powvar_correct_result") (("4" (with-labels (assert) ("cached is correct" "UNKNOWN")) (("4" (replace "cached" "cached is correct" :dir RL) (("4" (expand "CacheData_correct?") (("4" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("4" (split "cached cond ok") (("1" (replace "pownoises" "cached cond ok" :dir RL) (("1" (replace "cached`1 varidx" "cached cond ok") (("1" (reveal "re") (("1" (replace "re" "cached cond ok") (("1" (assert) (("1" (flatten "cached cond ok") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (replace "varac" "no single value") (("2" (reveal "re") (("2" (hide-all-but ("no single value" "cached cond ok" "re")) (("2" (replaces "re") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (RE2AC subtype "Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1" "(IntervalExpr_adt.pow?)"))) (RE2AC_TCC53 0 (RE2AC_TCC48-2 nil 3767017154 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "pow is cached" -6) (label "cached" -7) (label "result" -8) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (typepred "cache") (("" (expand "correct_cache?" 4) (("" (expand "CacheData_correct?") (("" (expand "powvar?" 4) (("" (expand "varidx_powvar" 4) (("" (typepred "cached") (("" (assert) (("" (flatten) (("" (use "cache_powvar_correct_result") (("" (assert) (("" (replace "cached" -1 :dir RL) (("" (expand "CacheData_correct?") (("" (expand "varidx_powvar" -1) (("" (flatten) (("" (split -2) (("1" (flatten) (("1" (assert) (("1" (reveal "re") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal "re") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (varidx_powvar const-decl "nat" affine_expr nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (pow skolem-const-decl "nat" affine_expr_Eval_fnd nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (last_ol def-decl "T" ordered_list structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (powvar? const-decl "bool" affine_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC48-1 nil 3631466640 ("" (then (skeep*) (grind)) nil nil) ((empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_ol const-decl "ordered_list" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (ordered_list? def-decl "bool" ordered_list structures) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals)) shostak (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC54 0 (RE2AC_TCC54-2 "" 3803766707 ("" (skeep*) (("" (assert) (("" (hide -9) (("" (apply (then (label "re" -1) (label "varac" -4) (label "cached some" -6) (label "pow is cached" -7) (label "cached" -5) (label "result" -8) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 4) (("1" (inst 1 "(: (re, val(cached)`2, val(cached)`3) :)") (("1" (grind) nil nil)) nil) ("2" (with-labels (typepred "cache") (("cache comp pairs" "cache idx bound" "cache correct" "UNKNOWN"))) (("2" (expand "compatible_pairs?") (("2" (skeep) (("2" (inst 1 "N") (("2" (assert) (("2" (expand "compatible_pairs_on?") (("2" (skeep*) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (replaces -3 1 :dir RL) (("1" (inst?) (("1" (inst "cache idx bound" "n") (("1" (case "nth(cache, i!1)`1 = POW(re1, pow)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (reveal -3 "re") (("2" (replaces "re") (("2" (expand "varidx_powvar" -3) (("2" (reveal -2) (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (reveal "re") (("2" (replace "re" -2) (("2" (assert) (("2" (hide-all-but (-2 1 -12 -5)) (("2" (expand "varidx_powvar") (("2" (apply-extensionality) (("1" (use "IntervalExpr_VARIDX_extensionality") (("1" (assert) nil nil)) nil) ("2" (reveal -3) (("2" (expand "powvar?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst "cache idx bound" "i-1") (("1" (inst "cache idx bound" "n") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "cache") (("3" (expand "idxs_bounded") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (replaces -3 1 :dir RL) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC54-1 "" 3789917666 ("" (skeep*) (("" (assert) (("" (hide -9) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "pow is cached" -6) (label "cached" -7) (label "result" -8) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 4) (("1" (inst 1 "(: (re, val(cached)`2, val(cached)`3) :)") (("1" (grind) nil nil)) nil) ("2" (with-labels (typepred "cache") (("cache comp pairs" "cache idx bound" "cache correct" "UNKNOWN"))) (("2" (expand "compatible_pairs?") (("2" (skeep) (("2" (inst 1 "N") (("2" (assert) (("2" (expand "compatible_pairs_on?") (("2" (skeep*) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (replaces -3 1 :dir RL) (("1" (inst?) (("1" (inst "cache idx bound" "n") (("1" (case "nth(cache, i!1)`1 = POW(re1, pow)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (reveal -3 "re") (("2" (replaces "re") (("2" (expand "varidx_powvar" -3) (("2" (reveal -2) (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (reveal "re") (("2" (replace "re" -2) (("2" (assert) (("2" (hide-all-but (-2 1 -12 -5)) (("2" (expand "varidx_powvar") (("2" (apply-extensionality) (("1" (use "IntervalExpr_VARIDX_extensionality") (("1" (assert) nil nil)) nil) ("2" (reveal -3) (("2" (expand "powvar?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst "cache idx bound" "i-1") (("1" (inst "cache idx bound" "n") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "cache") (("3" (expand "idxs_bounded") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (replaces -3 1 :dir RL) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (append def-decl "list[T]" list_props nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (length def-decl "nat" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (powvar? const-decl "bool" affine_expr nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IntervalExpr_POW_extensionality formula-decl nil IntervalExpr_adt interval_arith) (i!1 skolem-const-decl "below(length(cache))" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (op shared-adt-accessor-decl "[{x: IntervalExpr |
         bincludes?(x) OR fun?(x) OR pow?(x) OR sq?(x) OR neg?(x)
     OR abs?(x)} ->
   RealExpr]" IntervalExpr_adt interval_arith) (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr_VARIDX_extensionality formula-decl nil IntervalExpr_adt interval_arith) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (i skolem-const-decl "below(length(cons((POW(re1, pow), val(cached)`2, val(cached)`3), cache)))" affine_expr_Eval_fnd nil) (cached skolem-const-decl "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" affine_expr_Eval_fnd nil) (re skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (pow skolem-const-decl "nat" affine_expr_Eval_fnd nil) (re1 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC49-2 nil 3767017107 ("" (skeep*) (("" (assert) (("" (hide -9) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "pow is cached" -6) (label "cached" -7) (label "result" -8) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 4) (("1" (inst 1 "(: (re, val(cached)`2, val(cached)`3) :)") (("1" (grind) nil nil)) nil) ("2" (with-labels (typepred "cache") (("cache comp pairs" "cache idx bound" "cache correct" "UNKNOWN"))) (("2" (expand "compatible_pairs?") (("2" (skeep) (("2" (inst 1 "N") (("2" (assert) (("2" (expand "compatible_pairs_on?") (("2" (skeep*) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (replaces -3 1 :dir RL) (("1" (inst?) (("1" (inst "cache idx bound" "n") (("1" (replaces "cache comp pairs") (("1" (case "nth(cache, i!1)`1 = POW(re1, pow)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replaces "pow is cached") (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (reveal -3 "re") (("2" (replaces "re") (("2" (expand "varidx_powvar" -3) (("2" (reveal -2) (("2" (replaces -1) (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (reveal "re") (("2" (replace "re" -2) (("2" (assert) (("2" (hide-all-but (-2 1 -12 -5)) (("2" (expand "varidx_powvar") (("2" (apply-extensionality) (("1" (use "IntervalExpr_VARIDX_extensionality") (("1" (assert) nil nil)) nil) ("2" (reveal -3) (("2" (expand "powvar?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst "cache idx bound" "i-1") (("1" (inst "cache idx bound" "n") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "cache") (("3" (expand "idxs_bounded") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (replaces -3 1 :dir RL) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (lt_realorder name-judgement "RealOrder" real_orders reals) (IntervalExpr_POW_extensionality formula-decl nil IntervalExpr_adt interval_arith) (op shared-adt-accessor-decl "[{x: IntervalExpr |
         bincludes?(x) OR fun?(x) OR pow?(x) OR sq?(x) OR neg?(x)
     OR abs?(x)} ->
   RealExpr]" IntervalExpr_adt interval_arith) (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr_VARIDX_extensionality formula-decl nil IntervalExpr_adt interval_arith)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC49-1 nil 3631466640 ("" (then (skeep*) (replaces -7) (assert) (expand "correct_cache?") (expand "CacheData_correct?") (flatten) (spread (split 2) ((grind) (grind) (grind)))) nil nil) ((le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (varidx_powvar const-decl "nat" affine_expr nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_ol const-decl "ordered_list" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (powvar? const-decl "bool" affine_expr nil) (gt_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC55 0 (RE2AC_TCC55-1 "" 3789917667 ("" (skeep*) (("" (assert) (("" (hide 1) (("" (hide -6) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_ol? const-decl "bool" ordered_list structures) (idxs_ac const-decl "list[nat]" affine nil) (represents_var? const-decl "bool" affine nil) (length def-decl "nat" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC50-3 nil 3637342891 ("" (then (skeep*) (assert) (expand "null_ol") (hide 1) (hide -6) (spread (split 1) ((grind) (then (assert) (spread (inst 1 "(: (re, acRes,null)::CacheData :)") ((grind) (grind)))) (then (assert) (typepred "cache") (expand "compatible_pairs?") (skeep) (inst 1 "N") (assert) (expand "compatible_pairs_on?") (skeep* 1) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (spread (case "pow=0") ((then (replace -11) (assert) (replace -7) (expand "powvar?" 1) (expand "varidx_powvar" 1) (reveal -2) (replaces -2) (replaces -7) (replaces -1) (expand "pow_var_ac") (expand "eval_ACExpr_Env" 1) (expand "eval") (expand "eval_ac_noise") (assert) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (assert) (use "expt_x0") (assert) (expand "pow_var_compatible?" 1) (grind)) (spread (case "pow=1") ((then (replace -11) (assert) (reveal -2) (replaces -2) (replaces -7) (replaces -1) (expand "eval_ACExpr_Env" 2) (expand "eval") (expand "pow_var_ac" 2) (lift-if 2) (spread (split 2) ((then (expand "eval" 1) (replace -6 1 :dir RL) (expand "powvar?" 1) (expand "varidx_powvar" 1) (replace -6 1 :dir RL) (flatten) (replaces -8) (expand "eval_ac_noise" 1) (assert) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (expand "nth_ac" 1) (with-labels (expand "vars_in_box_compatible?") (("vars in box"))) (inst "vars in box" "idx") (with-labels (flatten "vars in box") (("eval varac is vs" "when sing interval"))) (replaces "eval varac is vs" 1 :dir RL) (expand "eval_ac_noise" 1) (expand "nth_ac" -1) (spread (case "pd(var_ac(nth(box, idx), idx)) = null") ((then (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (assert) (expand "pow_var_compatible?") (grind)) (then (hide-all-but (-1 1)) (expand "length") (assert))))) (then (expand "powvar?" 1) (expand "varidx_powvar" 1) (expand "eval") (replace -6 1 :dir RL) (flatten) (spread (split 2) ((then (flatten) (with-labels (expand "vars_in_box_compatible?") (("vars in box"))) (inst "vars in box" "idx") (with-labels (flatten "vars in box") (("eval varac is vs" "when sing interval"))) (replaces "eval varac is vs" 1 :dir RL) (replaces -8) (expand "eval_ac_noise" 1) (assert) (expand "nth_ac" -1) (expand "nth_ac" (1 -1)) (use "eval_pd_noise_rec_pds_def") (expand_ol) (lift-if -1) (spread (split -1) ((grind) (then (flatten) (replaces -1) (spread (case "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") ((then (replaces -1) (assert) (use "expt_x1") (replaces -1) (lemma "expt_x1") (inst? -1 :where 2) (assert) (expand "pow_var_compatible?") (grind)) (then (hide 3) (spread (case "cdr(pd(var_ac(nth(box, idx), idx))) = null") ((then (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol)) (grind)))) (then (typepred "pd(var_ac(nth[Interval](box, idx), idx))") (expand "ordered_list?" -1) (assert)) (assert))))))) (then (flatten) (with-labels (expand "vars_in_box_compatible?") (("vars in box"))) (inst "vars in box" "idx") (with-labels (flatten "vars in box") (("eval varac is vs" "when sing interval"))) (replaces "eval varac is vs" 2 :dir RL) (expand "eval_ac_noise" 2) (assert) (replaces -7) (expand "nth_ac" 1) (use "expt_x1") (replaces -1) (use "expt_x1") (replaces -1) (assert) (use "eval_pd_noise_rec_pds_def") (lift-if -1) (spread (split -1) ((grind) (then (flatten) (replaces -1) (expand_ol) (spread (case "eval_pd_noise(cdr(pd(var_ac(nth(box, idx), idx))), N) = 0") ((then (replaces -1) (assert) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (assert) (use "expt_x0") (replaces -1) (grind)) (then (expand "ordered_list?") (propax)) (then (use "expt_x0") (replaces -1) (expand "nth" 1) (spread (typepred "car(pd
                                                                                                                                                                                      (var_ac(IF idx = 0 THEN car(box)
                                                                                                                                                                                              ELSE nth(cdr(box), idx - 1)
                                                                                                                                                                                              ENDIF,
                                                                                                                                                                                              idx)))`2") ((then (expand "/=") (grind)) (then (typepred "idx") (grind)) (then (flatten) (typepred "idx") (grind)) (then (flatten) (grind)) (grind))))))) (spread (case "cdr(pd(var_ac(nth(box, idx), idx))) = null") ((then (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol)) (grind))) (then (typepred "pd(var_ac(nth[Interval](box, idx), idx))") (expand "ordered_list?" -1) (assert)) (then (expand "length") (assert)))))))))))))) (spread (split -8) ((grind) (then (reveal -2) (replaces -1 3) (replaces -8 3) (replace -11) (assert) (replace -1) (replace -8) (expand "powvar?" 3) (expand "varidx_powvar" 3) (expand "pow_var_ac") (assert) (expand "eval_ACExpr_Env" 3) (expand "eval" 3) (expand "eval" 3) (replace -9 3 :dir RL) (expand "eval_ac_noise") (assert) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (assert) (replaces -10) (expand "nth_ac") (with-labels (expand "vars_in_box_compatible?") (("vars in box"))) (inst "vars in box" "idx") (with-labels (flatten "vars in box") (("eval varac is vs" "when sing interval"))) (replaces "eval varac is vs" 3 :dir RL) (expand "eval_ac_noise" 3) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (lift-if 3) (spread (split 3) ((then (flatten) (assert) (expand "pow_var_compatible?") (propax)) (then (flatten) (grind)))))))))))) (then (replace -10 :hide? t) (expand "nth" 2) (assert) (spread (inst -3 "i-1") ((inst -3 "n") (then (typepred "i") (hide-all-but (-1 1 2)) (reveal -11) (grind)))))))) (then (replace -6 1) (assert) (typepred "cache") (expand "idxs_bounded") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (reveal -2) (replaces -1) (use "next_idx_pow_var_ac") (assert) (replaces -1) (typepred "nextfreeidx") (replaces -9) (expand "last_idx_in_box") (expand "nth_ac") (expand "var_ac" 1) (lift-if 1) (spread (split 1) ((then (flatten) (assert)) (then (expand "next_idx") (expand "last_idx") (expand "last_ol") (reveal 1) (grind))))) (then (expand "nth" 2) (assert) (inst? :subst ("i" "i-1"))))))))) nil nil) ((represents_var? const-decl "bool" affine nil) (idxs_ac const-decl "list[nat]" affine nil) (null_ol? const-decl "bool" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC50-2 nil 3632073429 ("" (skeep*) (("" (assert) (("" (hide -7) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow is cached" -4) (label "cached" -5) (label "result" -6) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 4) (("1" (inst 1 "(: (POWVAR(idx, pow), val(cached)`2, val(cached)`3) :)") (("1" (grind) nil nil)) nil) ("2" (with-labels (typepred "cache") (("cache comp pairs" "cache idx bound" "cache correct" "UNKNOWN"))) (("2" (expand "compatible_pairs?") (("2" (skeep) (("2" (inst 1 "N") (("2" (assert) (("2" (expand "compatible_pairs_on?") (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (replaces -3 1 :dir RL) (("1" (inst?) (("1" (replaces "cache comp pairs") (("1" (case "nth(cache, i!1)`1 = POWVAR(idx, pow)") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replaces "pow is cached") (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (reveal -3 "re") (("2" (replaces "re") (("2" (assert) (("2" (replaces -1) (("2" (reveal -2) (("2" (replaces -1) (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (reveal "re") (("2" (replace "re" -2) (("2" (assert) (("2" (replaces -2 1 :dir RL) (("2" (replaces "pow is cached" 1 :dir RL) (("2" (apply-extensionality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst? :subst ("i" "i-1")) (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil) ("3" (typepred "i") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "cache") (("3" (expand "idxs_bounded") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (replaces -3 1 :dir RL) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC50-1 nil 3631466640 ("" (skeep*) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "cached" -4) (label "idxs" -5) (label "pownoises" -6) (label "newoff" -7) (label "nwidxs" -8) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (with-labels (split "not in cache 1") (("pow gt opn cached`1"))) (("" (with-labels (split "not in cache 2") (("pow gt opn cached`1"))) (("1" (expand "/=") (("1" (propax) nil nil)) nil) ("2" (replaces "nwidxs" 7) (("2" (split 7) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (assert) (("1" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (name "nwidxs2" "append_ol[nat,<](pownoises, nats(nextfreeidx, newoff - 1))") (("1" (typepred "nwidxs2") (("1" (expand "append_ol") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "appendable_ol?") (("2" (postpone) nil nil)) nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Interval type-eq-decl nil interval interval_arith) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.varac" "(affine.represents_var?)"))) (RE2AC_TCC56 0 (RE2AC_TCC51-3 nil 3767017036 ("" (skeep*) (("" (use "cache_powvar_correct_result") (("" (assert) (("" (replace -8 -1 :dir RL) (("" (expand "CacheData_correct?") (("" (typepred "cached") (("" (assert) (("" (flatten) (("" (assert) (("" (flatten) (("" (split -5) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replaces -9) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (powvar? const-decl "bool" affine_expr nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (idxs_ac const-decl "list[nat]" affine nil) (null_ol? const-decl "bool" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (idxs_pd def-decl "list[nat]" affine nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.pownoises" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}")) (RE2AC_TCC51-2 nil 3637343285 ("" (then (skeep*) (expand "powvar?") (typepred "re") (grind)) nil nil) ((RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (powvar? const-decl "bool" affine_expr nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.pownoises" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}")) (RE2AC_TCC51-1 nil 3631466640 ("" (skeep*) (("" (grind) nil nil)) nil) ((var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_ol? const-decl "bool" ordered_list structures) (idxs_ac const-decl "list[nat]" affine nil) (represents_var? const-decl "bool" affine nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.pownoises" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}"))) (RE2AC_TCC57 0 (RE2AC_TCC57-1 "" 3789917754 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow is cached" -4) (label "cached" -5) (label "result" -6) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "re") (("" (typepred "cache") (("" (typepred "cached") (("" (assert) (("" (flatten) (("" (use "cache_powvar_correct_result") (("" (assert) (("" (expand "CacheData_correct?") (("" (flatten) (("" (split -2) (("1" (flatten) (("1" (assert) (("1" (reveal "re") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal "re") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (idxs_pd def-decl "list[nat]" affine nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (pow skolem-const-decl "nat" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial reals) (cdr_ol const-decl "ordered_list" ordered_list structures) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (idxs_ac const-decl "list[nat]" affine nil) (last_ol def-decl "T" ordered_list structures) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC52-3 nil 3632073759 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "pow is cached" -4) (label "cached" -5) (label "result" -6) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (("" (replaces "re") (("" (replaces "result") (("" (typepred "cache") (("" (typepred "cached") (("" (assert) (("" (flatten) (("" (use "cache_powvar_correct_result") (("" (assert) (("" (expand "CacheData_correct?") (("" (flatten) (("" (split -2) (("1" (flatten) (("1" (assert) (("1" (reveal "re") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (reveal "re") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((gt_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (varidx_powvar const-decl "nat" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (idxs_pd def-decl "list[nat]" affine nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial reals) (cdr_ol const-decl "ordered_list" ordered_list structures) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (idxs_ac const-decl "list[nat]" affine nil) (last_ol def-decl "T" ordered_list structures) (lt_realorder name-judgement "RealOrder" real_orders reals) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC52-2 nil 3631553433 ("" (skeep*) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "cached" -4) (label "idxs" -5) (label "pownoises" -6) (label "newoff" -7) (label "nwidxs" -8) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (with-labels (split "not in cache 1") (("pow gt opn cached`1"))) (("" (with-labels (split "not in cache 2") (("pow gt opn cached`1"))) (("1" (expand "/=") (("1" (propax) nil nil)) nil) ("2" (replaces "nwidxs" 7) (("2" (split 7) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (assert) (("1" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (split "cached correct") (("1" (flatten) (("1" (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (typepred "nwidxs2") (("1" (expand "append_ol") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "appendable_ol?") (("2" (flatten) (("2" (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (replaces -1 3) (("1" (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (replaces -1 3) (("1" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("1" (expand "idxs_bounded" "cache idxs bounded") (("1" (skeep "cached cache idx") (("1" (replace "pownoises" 1) (("1" (replace "cached cache idx" 1 :dir RL) (("1" (inst "cache idxs bounded" "i") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (replace "cached`2 is powvarac" "cache idxs bounded") (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if "cache idxs bounded") (("1" (split "cache idxs bounded") (("1" (grind) nil nil) ("2" (flatten) (("2" (expand ">=") (("2" (replace "pownoises" 4) (("2" (replace "cached cache idx" 4 :dir RL) (("2" (hide-all-but ("cache idxs bounded" 4)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 "cached correct" "pow gt opn cached`1")) (("2" (replaces -2 1) (("2" (expand "nats" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (expand "first_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "last_take_nth[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("3" (use "take_ol[nat,<]") (("3" (assert) nil nil)) nil) ("4" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replaces -4 2) (("1" (use "length_take[nat]") (("1" (replaces -1 2) (("1" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (expand "min" 2) (("1" (lift-if 2) (("1" (case "length(pownoises) = opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (assert) (("2" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (flatten) (("2" (replace "pownoises" 2) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (assert) (("2" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (replace "cached`1 varidx" "cached cond ok") (("2" (split "cached cond ok") (("1" (flatten) (("1" (replaces "varac" 2) (("1" (replace "re" "cached cond ok") (("1" (assert) (("1" (case "car[nat]
                         (append(take[nat](val(cached)`3, opn(val(cached)`1) - 2 + 1),
                                 nats(nextfreeidx, newoff - 1))) = car(val(cached)`3)") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "take" 1) (("2" (expand "append" 1) (("2" (propax) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replace -4 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (flatten) (("2" (expand "nats" 2) (("2" (replace "newoff" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (replace "varac" 1) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (replace "varac" 2) (("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((take_ol formula-decl nil ordered_list structures) (last_ol def-decl "T" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (idxs_ac const-decl "list[nat]" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (last_idx const-decl "int" indexed_list structures) (var_ac const-decl "AffineCombination" affine nil) (last_take_nth formula-decl nil ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Interval type-eq-decl nil interval interval_arith) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (last_idx_box formula-decl nil affine_box nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC52-1 nil 3631466640 ("" (skeep*) (("" (replaces -7) (("" (replaces -4) (("" (assert) nil nil)) nil)) nil)) nil) nil shostak (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC58 0 (RE2AC_TCC58-1 "" 3803766872 ("" (skeep*) (("" (assert) (("" (hide -12) (("" (apply (then (label "re" -1) (label "varac" -4) (label "cached some" -6) (label "pow < cached pow" -7) (label "cached" -5) (label "idxs" -8) (label "pownoises" -9) (label "acRes" -10) (label "result" -11) (label "idx" 1) (label "pow <= 1" 2) (label "no single value" 3) (label "no cv 0" 5))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 5) (("1" (inst 1 "(: (POW(re1, pow), acRes, pownoises) :)") (("1" (grind) nil nil)) nil) ("2" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("2" (expand "compatible_pairs?" "cache compatible pairs") (("2" (with-labels (skeep "cache compatible pairs") (("vars in box" "compatible on"))) (("2" (inst 1 "N") (("2" (assert) (("2" (expand "compatible_pairs_on?" 1) (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "powvar?" 1) (("1" (expand "varidx_powvar" 1) (("1" (expand "compatible_pairs_on?") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (skeep "cached cache idx") (("1" (inst "compatible on" "i!1") (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert -1) ("cached is correct" "UNKNOWN")) (("1" (replace "cached" "cached is correct" :dir RL) (("1" (expand "CacheData_correct?") (("1" (with-labels (assert (-1 "cached`1 is powvar")) ("cached is correct" "UNKNOWN")) (("1" (with-labels (flatten "cached is correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (skeep) (("1" (inst "compatible on" "n") (("1" (with-labels (flatten "compatible on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("1" (replace "cached`2 is powvarac" "eval cache") (("1" (replace "acRes" 1) (("1" (replace "varac" 1) (("1" (replace "cached cache idx" "cached`1 varidx" :dir RL) (("1" (reveal "re") (("1" (assert) (("1" (replace "cached cache idx" "pownoises" :dir RL) (("1" (replace "pownoises" "eval cache" :dir RL) (("1" (case "nth(cache, i!1)`1 = POW(re1, opn(nth(cache, i!1)`1))") (("1" (replaces -1) (("1" (expand "eval_ACExpr_Env") (("1" (expand "eval") (("1" (lemma "containment_pow_var_ac") (("1" (split 1) (("1" (use "containment_pow_var_ac") (("1" (assert) (("1" (split 1) (("1" (expand "eval") (("1" (replace -16 :dir RL) (("1" (expand "vars_in_box_compatible?") (("1" (inst? "vars in box") (("1" (flatten) (("1" (expand "nth_ac") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "pownoises") (("2" (hide -2) (("2" (split "cached cond ok") (("1" (typepred "cached") (("1" (split -1) (("1" (flatten) (("1" (replace -2 :hide? t) (("1" (replace "re" "cached cond ok") (("1" (assert) (("1" (hide-all-but ("cached cond ok" -4 "cached cache idx")) (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (expand ">=") (("1" (use "notmember_ol_nat") (("1" (assert) (("1" (split 1) (("1" (grind) nil nil) ("2" (lift-if "cached cond ok") (("2" (split "cached cond ok") (("1" (flatten) (("1" (expand "varidx_powvar") (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (expand "car_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "pow_var_compatible?") (("3" (skeep) (("3" (expand "varidx_powvar") (("3" (inst "cache if powvar" "i!2") (("3" (replace "pownoises" "cache if powvar" :dir RL) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "pow_var_compatible?") (("2" (skeep) (("2" (expand "varidx_powvar") (("2" (inst "cache if powvar" "i!2") (("2" (replace "pownoises" "cache if powvar" :dir RL) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "cached`1 is powvar" "cached`1 varidx" "re" "cached cache idx" -13 -14)) (("2" (replaces "cached cache idx" :dir RL) (("2" (replaces "re") (("2" (assert) (("2" (apply-extensionality) (("2" (expand "varidx_powvar") (("2" (use "IntervalExpr_VARIDX_extensionality") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (replace "varac" "no single value") (("2" (reveal "re") (("2" (hide-all-but ("no single value" "cached cond ok" "re")) (("2" (replaces "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?" "compatible on") (("2" (inst "compatible on" "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "idxs_bounded") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replaces "acRes") (("1" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (skeep "cached cache idx") (("1" (inst "cache idxs bound" "i!1") (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert (-1 "cache correct")) ("cached is correct" "UNKNOWN")) (("1" (replace "cached" "cached is correct" :dir RL) (("1" (expand "CacheData_correct?") (("1" (assert ("cached is correct" "cached`1 is powvar")) (("1" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (replace "cached`2 is powvarac" "cache idxs bound") (("1" (replace "cached cache idx" "pownoises" :dir RL) (("1" (replace "pownoises" "cache idxs bound" :dir RL) (("1" (replace "cached cache idx" "cached`1 varidx" :dir RL) (("1" (replace "cached`1 varidx" "cache idxs bound") (("1" (reveal "re") (("1" (replace "re" "cache idxs bound") (("1" (assert) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (lift-if "cache idxs bound") (("2" (split "cache idxs bound") (("1" (grind) nil nil) ("2" (with-labels (flatten "cache idxs bound") (("already knonwn" "already knonwn" "cache idxs bound" "UNKNOWN"))) (("2" (split "cache idxs bound") (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (with-labels (flatten "cache idxs bound") (("opn not 1" "cache idxs bound" "UNKNOWN"))) (("2" (assert) (("2" (hide-all-but (4 "cache idxs bound" "pow < cached pow" "cached cache idx")) (("2" (replaces "cached cache idx" :dir RL) (("2" (expand ">") (("2" (expand ">=") (("2" (use "nth_ol[nat,<]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (replace "varac" "no single value") (("2" (reveal "re") (("2" (hide-all-but ("no single value" "cached cond ok" "re")) (("2" (replaces "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bound") (("2" (inst "cache idxs bound" "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC53-3 nil 3767017678 ("" (skeep*) (("" (assert) (("" (hide -12) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "pow < cached pow" -6) (label "cached" -7) (label "idxs" -8) (label "pownoises" -9) (label "acRes" -10) (label "result" -11) (label "idx" 1) (label "pow <= 1" 2) (label "no single value" 3) (label "no cv 0" 4))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 5) (("1" (inst 1 "(: (POW(re1, pow), acRes, pownoises) :)") (("1" (grind) nil nil)) nil) ("2" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("2" (expand "compatible_pairs?" "cache compatible pairs") (("2" (with-labels (skeep "cache compatible pairs") (("vars in box" "compatible on"))) (("2" (inst 1 "N") (("2" (assert) (("2" (expand "compatible_pairs_on?" 1) (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "powvar?" 1) (("1" (expand "varidx_powvar" 1) (("1" (expand "compatible_pairs_on?") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (skeep "cached cache idx") (("1" (inst "compatible on" "i!1") (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert -1) ("cached is correct" "UNKNOWN")) (("1" (replace "cached" "cached is correct" :dir RL) (("1" (expand "CacheData_correct?") (("1" (with-labels (assert (-1 "cached`1 is powvar")) ("cached is correct" "UNKNOWN")) (("1" (with-labels (flatten "cached is correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (skeep) (("1" (inst "compatible on" "n") (("1" (with-labels (flatten "compatible on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("1" (replace "cached`2 is powvarac" "eval cache") (("1" (replace "acRes" 1) (("1" (replace "varac" 1) (("1" (replace "cached cache idx" "cached`1 varidx" :dir RL) (("1" (reveal "re") (("1" (assert) (("1" (replace "cached cache idx" "pownoises" :dir RL) (("1" (replace "pownoises" "eval cache" :dir RL) (("1" (case "nth(cache, i!1)`1 = POW(re1, opn(nth(cache, i!1)`1))") (("1" (replaces -1) (("1" (expand "eval_ACExpr_Env") (("1" (expand "eval") (("1" (lemma "containment_pow_var_ac") (("1" (split 1) (("1" (use "containment_pow_var_ac") (("1" (assert) (("1" (split 1) (("1" (expand "eval") (("1" (replace -16 :dir RL) (("1" (expand "vars_in_box_compatible?") (("1" (inst? "vars in box") (("1" (flatten) (("1" (expand "nth_ac") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "pownoises") (("2" (hide -2) (("2" (split "cached cond ok") (("1" (typepred "cached") (("1" (split -1) (("1" (flatten) (("1" (replace -2 :hide? t) (("1" (replace "re" "cached cond ok") (("1" (assert) (("1" (hide-all-but ("cached cond ok" -4 "cached cache idx")) (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (expand ">=") (("1" (use "notmember_ol_nat") (("1" (assert) (("1" (split 1) (("1" (grind) nil nil) ("2" (lift-if "cached cond ok") (("2" (split "cached cond ok") (("1" (flatten) (("1" (expand "varidx_powvar") (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (expand "car_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "pow_var_compatible?") (("3" (skeep) (("3" (expand "varidx_powvar") (("3" (inst "cache if powvar" "i!2") (("3" (replace "pownoises" "cache if powvar" :dir RL) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "pow_var_compatible?") (("2" (skeep) (("2" (expand "varidx_powvar") (("2" (inst "cache if powvar" "i!2") (("2" (replace "pownoises" "cache if powvar" :dir RL) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "cached`1 is powvar" "cached`1 varidx" "re" "cached cache idx" -13 -14)) (("2" (replaces "cached cache idx" :dir RL) (("2" (replaces "re") (("2" (assert) (("2" (apply-extensionality) (("2" (expand "varidx_powvar") (("2" (use "IntervalExpr_VARIDX_extensionality") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (replace "varac" "no single value") (("2" (reveal "re") (("2" (hide-all-but ("no single value" "cached cond ok" "re")) (("2" (replaces "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?" "compatible on") (("2" (inst "compatible on" "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "idxs_bounded") (("3" (skeep) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replaces "acRes") (("1" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (skeep "cached cache idx") (("1" (inst "cache idxs bound" "i!1") (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert (-1 "cache correct")) ("cached is correct" "UNKNOWN")) (("1" (replace "cached" "cached is correct" :dir RL) (("1" (expand "CacheData_correct?") (("1" (assert ("cached is correct" "cached`1 is powvar")) (("1" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (replace "cached`2 is powvarac" "cache idxs bound") (("1" (replace "cached cache idx" "pownoises" :dir RL) (("1" (replace "pownoises" "cache idxs bound" :dir RL) (("1" (replace "cached cache idx" "cached`1 varidx" :dir RL) (("1" (replace "cached`1 varidx" "cache idxs bound") (("1" (reveal "re") (("1" (replace "re" "cache idxs bound") (("1" (assert) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (lift-if "cache idxs bound") (("2" (split "cache idxs bound") (("1" (grind) nil nil) ("2" (with-labels (flatten "cache idxs bound") (("already knonwn" "already knonwn" "cache idxs bound" "UNKNOWN"))) (("2" (split "cache idxs bound") (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (with-labels (flatten "cache idxs bound") (("opn not 1" "cache idxs bound" "UNKNOWN"))) (("2" (assert) (("2" (hide-all-but (4 "cache idxs bound" "pow < cached pow" "cached cache idx")) (("2" (replaces "cached cache idx" :dir RL) (("2" (expand ">") (("2" (expand ">=") (("2" (use "nth_ol[nat,<]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (replace "varac" "no single value") (("2" (reveal "re") (("2" (hide-all-but ("no single value" "cached cond ok" "re")) (("2" (replaces "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bound") (("2" (inst "cache idxs bound" "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (append def-decl "list[T]" list_props nil) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (below type-eq-decl nil nat_types nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (containment_pow_var_ac formula-decl nil affine_pow nil) (Env type-eq-decl nil box interval_arith) (represents_var? const-decl "bool" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (nzBaseType type-eq-decl nil affine nil) (next_idx const-decl "nat" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (int_plus_int_is_int application-judgement "int" integers nil) (olidx_car_last formula-decl nil indexed_list structures) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (car_ol const-decl "T" ordered_list structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (member def-decl "bool" list_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (notmember_ol_nat formula-decl nil affine_pow nil) (last_idx const-decl "int" indexed_list structures) (pow_var_compatible? const-decl "bool" affine_pow nil) (eval def-decl "real" interval_expr interval_arith) (op shared-adt-accessor-decl "[{x: IntervalExpr |
         bincludes?(x) OR fun?(x) OR pow?(x) OR sq?(x) OR neg?(x)
     OR abs?(x)} ->
   RealExpr]" IntervalExpr_adt interval_arith) (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr_VARIDX_extensionality formula-decl nil IntervalExpr_adt interval_arith) (IntervalExpr_POW_extensionality formula-decl nil IntervalExpr_adt interval_arith) (int_minus_int_is_int application-judgement "int" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (powvar? const-decl "bool" affine_expr nil) (re1 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (pow skolem-const-decl "nat" affine_expr_Eval_fnd nil) (acRes skolem-const-decl "AffineCombination" affine_expr_Eval_fnd nil) (pownoises skolem-const-decl "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(cons((POW(re1, pow), acRes, pownoises), cache)))" affine_expr_Eval_fnd nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (nth_ol formula-decl nil ordered_list structures) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (idxs_ac const-decl "list[nat]" affine nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (last_ol def-decl "T" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC53-2 nil 3631546337 ("" (then (skeep*) (assert) (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "pow is cached" -6) (label "cached" -7) (label "result" -8) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (replaces "re") (replaces "result") (assert) (typepred "cache") (expand "correct_cache?" 4) (expand "CacheData_correct?") (expand "powvar?" 4) (expand "varidx_powvar" 4) (typepred "cached") (assert) (flatten) (use "cache_powvar_correct_result") (assert) (replace "cached" -1 :dir RL) (expand "CacheData_correct?") (expand "varidx_powvar" -1) (flatten) (spread (split -2) ((then (flatten) (assert) (reveal "re") (grind)) (then (reveal "re") (grind))))) nil nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (varidx_powvar const-decl "nat" affine_expr nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (lt_realorder name-judgement "RealOrder" real_orders reals) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (pow_var_compatible? const-decl "bool" affine_pow nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (last_ol def-decl "T" ordered_list structures) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC53-1 nil 3631466640 ("" (skeep*) (("" (grind) nil nil)) nil) ((pow_var_ac const-decl "AffineCombination" affine_pow nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil)) shostak (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC59 0 (RE2AC_TCC59-1 "" 3789917764 ("" (skeep*) (("" (assert) nil nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "(number_fields.+)((number_fields.-)(IntervalExpr_adt.opn(Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1), 2), 1)" "nat")) (RE2AC_TCC54-4 nil 3632074082 ("" (then (skeep*) (assert) (hide -9) (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "pow is cached" -6) (label "cached" -7) (label "result" -8) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single" 3))) (replaces "re") (replaces "result") (assert) (spread (split 4) ((then (inst 1 "(: (re, val(cached)`2, val(cached)`3) :)") (grind)) (then (with-labels (typepred "cache") (("cache comp pairs" "cache idx bound" "cache correct" "UNKNOWN"))) (expand "compatible_pairs?") (skeep) (inst 1 "N") (assert) (expand "compatible_pairs_on?") (skeep*) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (typepred "cached") (assert) (flatten) (skeep) (replaces -3 1 :dir RL) (inst?) (inst "cache idx bound" "n") (replaces "cache comp pairs") (spread (case "nth(cache, i!1)`1 = POW(re1, pow)") ((then (assert) (flatten) (assert) (replaces "pow is cached") (replaces -1) (assert)) (then (hide 2) (reveal -3 "re") (replaces "re") (expand "varidx_powvar" -3) (reveal -2) (replaces -1) (typepred "cached") (assert) (flatten) (reveal "re") (replace "re" -2) (assert) (hide-all-but (-2 1 -12 -5)) (expand "varidx_powvar") (spread (apply-extensionality) ((then (use "IntervalExpr_VARIDX_extensionality") (assert)) (then (reveal -3) (expand "powvar?") (propax)))))))) (spread (inst "cache idx bound" "i-1") ((then (inst "cache idx bound" "n") (expand "nth" 2) (assert)) (then (typepred "i") (grind))))))) (then (typepred "cache") (expand "idxs_bounded") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (typepred "cached") (assert) (flatten) (skeep) (replaces -3 1 :dir RL) (inst?)) (then (expand "nth" 2) (assert) (inst?)))))))) nil nil) ((ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil)) nil (RE2AC subtype "(number_fields.+)((number_fields.-)(IntervalExpr_adt.opn(Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1), 2), 1)" "nat")) (RE2AC_TCC54-3 nil 3632063087 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "cached" -4) (label "idxs" -5) (label "pownoises" -6) (label "newoff" -7) (label "nwidxs" -8) (label "acRes" -9) (label "result" -10) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (hide -11) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(:(re, acRes, nwidxs):)") (("1" (expand "append" 1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (lift-if "nwidxs") (("2" (split nwidxs) (("1" (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (with-labels (typepred "cache") (("cache comp pairs" "cache idxs bound" "cache correct" "UNKNOWN"))) (("1" (expand "compatible_pairs?") (("1" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("1" (inst 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (skolem 1 "k") (("1" (inst "N vars in box" "k") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1 2) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace "single intervals in box" 1 :dir RL :hide? t) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skolem 1 "k") (("2" (split 1) (("1" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env" 1) (("1" (replaces "acRes") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("1" (skolem "cached cache idx" "i") (("1" (inst "cache comp pairs on" "i") (("1" (with-labels (flatten) (("cache eval" "cache if powvar" "UNKNOWN"))) (("1" (replace "cached cache idx") (("1" (expand "eval_ACExpr_Env" "cache eval") (("1" (assert) (("1" (use "cache_powvar_correct") (("1" (replace "cached cache idx") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("1" (replace "cached as AC" "cache eval") (("1" (replace "re") (("1" (assert) (("1" (replace "cached idx re") (("1" (replace "varac" 1) (("1" (lemma "powvarac_ext_on_pow") (("1" (inst -1 "N" "opn(val(cached)`1)" "nth_ac(box, idx)" "vs(idx)" "val(cached)`3" "nextfreeidx") (("1" (assert) (("1" (inst -1 "pow") (("1" (replace "nwidxs" 1) (("1" (replace "pownoises" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache comp pairs on" "k-1") (("2" (with-labels (flatten "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (("2" (replace "cache eval" 2 :dir RL) (("2" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 3) (("1" (skeep) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (inst?) (("1" (expand "idxs_ac") (("1" (use "beyond_last_idx_notmember") (("1" (assert) (("1" (expand "next_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "k=0") (("1" (replaces -1) (("1" (flatten) (("1" (expand "nth" (-1 -2)) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached in cache"))) (("1" (skolem "cached in cache" "j") (("1" (inst "cache comp pairs on" "j") (("1" (with-labels (flatten "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("1" (assert) (("1" (lemma "powvar_comp_noise_extension") (("1" (inst -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "nextfreeidx" "pownoises") (("1" (assert) (("1" (replace "varac" -1) (("1" (replaces "cached in cache" :dir RL) (("1" (replace "pownoises" -1) (("1" (replace "cached idx re" "cached N compatible") (("1" (replace "re" "cached N compatible") (("1" (assert) (("1" (replace "re" 1) (("1" (assert) (("1" (replace "re" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "varac" 1) (("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (replaces "re" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst "cache comp pairs on" "k-1") (("1" (expand "nth" 2) (("1" (assert) (("1" (flatten) (("1" (expand "nth" (-1 -2)) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (flatten) (("1" (skolem 2 "i") (("1" (assert) (("1" (inst "cache comp pairs on" "i") (("1" (case "get_noise_by_idx(nth(nth(cache, k - 1)`3, i),
                                                                 upd_noise_burst(N,
                                                                                 nats(nextfreeidx, newoff - 1),
                                                                                 LAMBDA
                                                                                 (i: nat):
                                                                                 (get_noise_by_idx
                                                                                  (car(pd(varac))`1, N)
                                                                                  ^
                                                                                  (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                                                                          0)`1,
                                                                      upd_noise_burst(N,
                                                                                      nats(nextfreeidx, newoff - 1),
                                                                                      LAMBDA
                                                                                      (i: nat):
                                                                                      (get_noise_by_idx
                                                                                       (car(pd(varac))`1, N)
                                                                                       ^
                                                                                       (2 + i))))
                                                      ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                                                                          0)`1,
                                                                      N)
                                                      ^ (2 + i)") (("1" (replaces -1) nil nil) ("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "nth_ac" -2) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (name-replace "somevidx" "varidx(nth(cache, k - 1)`1)") (("1" (use "last_idx_box") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (expand_ol) (("1" (expand "nth" -4 1) (("1" (assert) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-1 -7)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (typepred "i") (("1" (hide-all-but (-1 -2 "cache_k-1`3 length")) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 "cache idxs bound") (("2" (typepred "i") (("2" (hide-all-but (-1 -6 "cache idxs bound")) (("2" (expand ">=") (("2" (use "nth_ol[nat,<]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (assert) (("3" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "k") (("2" (hide-all-but (-1 1 2)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (flatten "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (("2" (with-labels (typepred "cache") (("cache comp pairs" "cache idxs bound" "correct cache" "UNKNOWN"))) (("2" (expand "compatible_pairs?") (("2" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (inst 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (split 2) (("1" (expand "vars_in_box_compatible?") (("1" (skolem 1 "k") (("1" (inst "N vars in box" "k") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces "single intervals in box" 1 :dir RL) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skolem 1 "k") (("2" (split 1) (("1" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env" 1) (("1" (replaces "acRes") (("1" (lemma "containment_pow_var_ac") (("1" (inst -1 "upd_noise_burst(N,
                                                                nats(nextfreeidx, newoff - 1),
                                                                LAMBDA
                                                                (i: nat):
                                                                (get_noise_by_idx(car(pd(varac))`1, N)
                                                                 ^
                                                                 (2 + i)))" "vs(varidx(re))" "varac" "pow" "nwidxs") (("1" (replace "re" 1) (("1" (assert) (("1" (replace "re" -1) (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (inst "N vars in box" "idx") (("1" (replace "varac" 1) (("1" (expand "nth_ac" 1) (("1" (with-labels (flatten "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (("1" (replace "box eval" 1 :dir RL) (("1" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 2) (("1" (skolem 1 "j") (("1" (flatten) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (reveal "varac") (("2" (replaces "varac") (("2" (expand "nth_ac") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value" "varac")) (("3" (replaces "varac") (("3" (expand "nth_ac") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replaces "nwidxs" -1) (("2" (use "member_nats") (("2" (assert) (("2" (flatten) (("2" (replaces "varac") (("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "pow_var_compatible_noise") (("1" (assert) nil nil) ("2" (replaces "varac") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value" "varac")) (("2" (replaces "varac") (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value" "varac")) (("3" (replaces "varac") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache comp pairs on" "k-1") (("2" (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (replaces "eval cache" 2 :dir RL) (("2" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 3) (("1" (skolem 1 "i") (("1" (flatten) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (lemma "beyond_last_idx_notmember") (("1" (inst -1 "i" "pd(nth(cache, k - 1)`2)") (("1" (assert) (("1" (expand "idxs_ac") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value" "varac")) (("2" (replaces "varac") (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value" "varac")) (("3" (replaces "varac") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "re" 1) (("1" (assert) (("1" (use "pow_var_compatible_noise") (("1" (replaces "nwidxs") (("1" (replaces "varac") nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (flatten) (("2" (inst "cache comp pairs on" "k-1") (("2" (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (assert) (("2" (expand "pow_var_compatible?") (("2" (flatten) (("2" (assert) (("2" (skolem 2 "j") (("2" (inst "cache if powvar" "j") (("2" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                                                                  0)`1,
                                                              upd_noise_burst(N,
                                                                              nats(nextfreeidx, newoff - 1),
                                                                              LAMBDA
                                                                              (i: nat):
                                                                              (get_noise_by_idx
                                                                               (car(pd(varac))`1, N)
                                                                               ^
                                                                               (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                                                                  0)`1,
                                                              N)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                 upd_noise_burst(N,
                                                                                 nats(nextfreeidx, newoff - 1),
                                                                                 LAMBDA
                                                                                 (i: nat):
                                                                                 (get_noise_by_idx
                                                                                  (car(pd(varac))`1, N)
                                                                                  ^
                                                                                  (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                 N)") (("1" (replaces -1) nil nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst?) (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (replaces -1 "cache idxs bound") (("2" (typepred "j") (("2" (hide-all-but (-1 -5 "cache idxs bound")) (("2" (use "nth_ol[nat,<]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "nth_ac" -2) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (name-replace "somevidx" "varidx(nth(cache, k - 1)`1)") (("1" (use "last_idx_box") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (expand_ol) (("1" (expand "nth" -4 1) (("1" (assert) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-1 -8)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "newoff" 1) (("3" (expand ">=") (("3" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (1 -1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("4" (replace "newoff" 1) (("4" (expand "idxs_bounded" 1) (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "acRes" 1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (replace "varac" 1) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 -2 -3 1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "nwidxs" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (case "pow - 1 = opn(val(cached)`1)") (("1" (replace -1 1 :dir RL) (("1" (assert) (("1" (case "nth(append(take[nat](pownoises, pow - 2),
                                                     nats(nextfreeidx, newoff - 1)),
                                              pow - 2) = nextfreeidx") (("1" (assert) nil nil) ("2" (hide 2) (("2" (use "nth_append[nat]") (("1" (replaces -1 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "length(pownoises) = pow - 2") (("1" (replaces -1 2) (("1" (grind) nil nil)) nil) ("2" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("2" (replaces -1 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "nth_append[nat]") (("1" (replaces -1 2) (("1" (case "nth(nats(nextfreeidx, newoff - 1),
                                                 pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (case "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 1) (("1" (replaces "newoff" 1) (("1" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (inst? -5) (("1" (replace -5 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil) ("2" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "newoff" 2) (("2" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (inst? -5) (("2" (replaces -5 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache idxs bounded" "i-1") (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 2 "cache idxs bounded")) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "correct_cache?") (("5" (expand "CacheData_correct?") (("5" (replace "re" 1) (("5" (assert) (("5" (lift-if "nwidxs") (("5" (split "nwidxs") (("1" (flatten) (("1" (replace -2 1) (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replaces -4 2) (("1" (case "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replace "pownoises") (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (flatten) (("2" (case "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                           nats(nextfreeidx, newoff - 1))) = car(pownoises)") (("1" (replaces -1 2) (("1" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (split "cached correct") (("1" (flatten) (("1" (split -2) (("1" (replace -4 "cached correct") (("1" (replace "re" "cached correct") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "take" -1) (("1" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (hide -1) (("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "take" 2) (("2" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "pownoises" 1) (("3" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("3" (use "cache_powvar_correct_result") (("3" (with-labels (assert) (("cached correct"))) (("3" (replace "cached" "cached correct" :dir RL) (("3" (expand "CacheData_correct?" "cached correct") (("3" (typepred "cached") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (split "cached correct") (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 2) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replace -4 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (flatten) (("2" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (inst -5 "0") (("1" (expand "nth") (("1" (replace -5 3) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -4 1) (("2" (replace "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((containment_pow_var_ac formula-decl nil affine_pow nil) (pow_var_compatible_noise formula-decl nil affine_pow nil) (idxs_pd def-decl "list[nat]" affine nil) (last_ol def-decl "T" ordered_list structures) (SingInterval? const-decl "bool" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (nzBaseType type-eq-decl nil affine nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (idxs_ac const-decl "list[nat]" affine nil) (beyond_last_idx_notmember formula-decl nil affine nil) (eval_updb_no_idxs formula-decl nil affine nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (last_idx_box formula-decl nil affine_box nil) (represents_var? const-decl "bool" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (next_idx const-decl "nat" affine nil) (olidx_car_last formula-decl nil indexed_list structures) (last_idx const-decl "int" indexed_list structures) (nth_ol formula-decl nil ordered_list structures) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (powvar_comp_noise_extension formula-decl nil affine_pow nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (ac_proj_pd formula-decl nil affine nil) (gnbi_updb_2 formula-decl nil affine nil) (member_nats formula-decl nil affine_pow nil) (power_Epsilon_is_Epsilon formula-decl nil affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (Interval type-eq-decl nil interval interval_arith) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures)) nil (RE2AC subtype "(number_fields.+)((number_fields.-)(IntervalExpr_adt.opn(Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1), 2), 1)" "nat")) (RE2AC_TCC54-2 nil 3631477806 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "cached" -4) (label "idxs" -5) (label "pownoises" -6) (label "newoff" -7) (label "nwidxs" -8) (label "acRes" -9) (label "result" -10) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (hide -11) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(:(re, acRes, nwidxs):)") (("1" (expand "append" 1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (lift-if "nwidxs") (("2" (split nwidxs) (("1" (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (with-labels (typepred "cache") (("cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("1" (expand "compatible_pairs?") (("1" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("1" (inst 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (skolem 1 "k") (("1" (inst "N vars in box" "k") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces "single intervals in box" 1 :dir RL) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skolem 1 "k") (("2" (split 1) (("1" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env" 1) (("1" (replaces "acRes") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("1" (skolem "cached cache idx" "i") (("1" (inst "cache comp pairs on" "i") (("1" (with-labels (flatten) (("cache eval" "cache if powvar" "UNKNOWN"))) (("1" (replace "cached cache idx") (("1" (expand "eval_ACExpr_Env" "cache eval") (("1" (assert) (("1" (use "cache_powvar_correct") (("1" (replace "cached cache idx") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("1" (replace "cached as AC" "cache eval") (("1" (replace "re") (("1" (assert) (("1" (replace "cached idx re") (("1" (replace "varac" 1) (("1" (lemma "powvarac_ext_on_pow") (("1" (inst -1 "N" "opn(val(cached)`1)" "nth_ac(box, idx)" "vs(idx)" "val(cached)`3" "nextfreeidx") (("1" (assert) (("1" (inst -1 "pow") (("1" (replace "nwidxs" 1) (("1" (replace "pownoises" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache comp pairs on" "k-1") (("2" (with-labels (flatten "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (("2" (replace "cache eval" 2 :dir RL) (("2" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 3) (("1" (skeep) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (inst?) (("1" (expand "idxs_ac") (("1" (use "beyond_last_idx_notmember") (("1" (assert) (("1" (expand "next_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "k=0") (("1" (replaces -1) (("1" (flatten) (("1" (expand "nth" -1) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached in cache"))) (("1" (skolem "cached in cache" "j") (("1" (inst "cache comp pairs on" "j") (("1" (with-labels (flatten "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("1" (assert) (("1" (lemma "powvar_comp_noise_extension") (("1" (inst -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "nextfreeidx" "pownoises") (("1" (assert) (("1" (replace "varac" -1) (("1" (replaces "cached in cache" :dir RL) (("1" (replace "pownoises" -1) (("1" (replace "cached idx re" "cached N compatible") (("1" (replace "re" "cached N compatible") (("1" (assert) (("1" (replace "re" 1) (("1" (assert) (("1" (replace "re" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "varac" 1) (("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (replaces "re" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst "cache comp pairs on" "k-1") (("1" (expand "nth" 2) (("1" (assert) (("1" (flatten) (("1" (expand "nth" -1) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (flatten) (("1" (skolem 2 "i") (("1" (assert) (("1" (inst "cache comp pairs on" "i") (("1" (case "get_noise_by_idx(nth(nth(cache, k - 1)`3, i),
                       upd_noise_burst(N,
                                       nats(nextfreeidx, newoff - 1),
                                       LAMBDA
                                       (i: nat):
                                       (get_noise_by_idx
                                        (car(pd(varac))`1, N)
                                        ^
                                        (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                            0)`1,
                        upd_noise_burst(N,
                                        nats(nextfreeidx, newoff - 1),
                                        LAMBDA
                                        (i: nat):
                                        (get_noise_by_idx
                                         (car(pd(varac))`1, N)
                                         ^
                                         (2 + i))))
        ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                            0)`1,
                        N)
        ^ (2 + i)") (("1" (replaces -1) nil nil) ("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "nth_ac" -2) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (name-replace "somevidx" "varidx(nth(cache, k - 1)`1)") (("1" (use "last_idx_box") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (expand_ol) (("1" (expand "nth" -4 1) (("1" (assert) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-1 -6)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (flatten) (("1" (replace -4 "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (typepred "i") (("1" (hide-all-but (-1 -2 -5)) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 "cache idxs bound") (("2" (typepred "i") (("2" (hide-all-but (-1 -7 "cache idxs bound")) (("2" (expand ">=") (("2" (use "nth_ol[nat,<]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (assert) (("3" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "k") (("2" (hide-all-but (-1 1 2)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (flatten "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (("2" (with-labels (typepred "cache") (("cache comp pairs" "cache idxs bound" "correct cache" "UNKNOWN"))) (("2" (expand "compatible_pairs?") (("2" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (inst 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (split 2) (("1" (expand "vars_in_box_compatible?") (("1" (skolem 1 "k") (("1" (inst "N vars in box" "k") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces "single intervals in box" 1 :dir RL) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skolem 1 "k") (("2" (split 1) (("1" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env" 1) (("1" (replaces "acRes") (("1" (lemma "containment_pow_var_ac") (("1" (inst -1 "upd_noise_burst(N,
                                    nats(nextfreeidx, newoff - 1),
                                    LAMBDA
                                    (i: nat):
                                    (get_noise_by_idx(car(pd(varac))`1, N)
                                     ^
                                     (2 + i)))" "vs(varidx(re))" "varac" "pow" "nwidxs") (("1" (replace "re" 1) (("1" (assert) (("1" (replace "re" -1) (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (inst "N vars in box" "idx") (("1" (replace "varac" 1) (("1" (expand "nth_ac" 1) (("1" (with-labels (flatten "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (("1" (replace "box eval" 1 :dir RL) (("1" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 2) (("1" (skolem 1 "j") (("1" (flatten) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (reveal "varac") (("2" (replaces "varac") (("2" (expand "nth_ac") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value" "varac")) (("3" (replaces "varac") (("3" (expand "nth_ac") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replaces "nwidxs" -1) (("2" (use "member_nats") (("2" (assert) (("2" (flatten) (("2" (replaces "varac") (("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "pow_var_compatible_noise") (("1" (assert) nil nil) ("2" (replaces "varac") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value" "varac")) (("2" (replaces "varac") (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value" "varac")) (("3" (replaces "varac") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache comp pairs on" "k-1") (("2" (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (replaces "eval cache" 2 :dir RL) (("2" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 3) (("1" (skolem 1 "i") (("1" (flatten) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (lemma "beyond_last_idx_notmember") (("1" (inst -1 "i" "pd(nth(cache, k - 1)`2)") (("1" (assert) (("1" (expand "idxs_ac") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value" "varac")) (("2" (replaces "varac") (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value" "varac")) (("3" (replaces "varac") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "re" 1) (("1" (assert) (("1" (use "pow_var_compatible_noise") (("1" (replaces "nwidxs") (("1" (replaces "varac") nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (flatten) (("2" (inst "cache comp pairs on" "k-1") (("2" (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (assert) (("2" (expand "pow_var_compatible?") (("2" (flatten) (("2" (assert) (("2" (skolem 2 "j") (("2" (inst "cache if powvar" "j") (("2" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                            0)`1,
                        upd_noise_burst(N,
                                        nats(nextfreeidx, newoff - 1),
                                        LAMBDA
                                        (i: nat):
                                        (get_noise_by_idx
                                         (car(pd(varac))`1, N)
                                         ^
                                         (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                            0)`1,
                        N)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                       upd_noise_burst(N,
                                       nats(nextfreeidx, newoff - 1),
                                       LAMBDA
                                       (i: nat):
                                       (get_noise_by_idx
                                        (car(pd(varac))`1, N)
                                        ^
                                        (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                       N)") (("1" (replaces -1) nil nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst?) (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (flatten) (("1" (replace -4 "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (replaces -1 "cache idxs bound") (("2" (typepred "j") (("2" (hide-all-but (-1 -6 "cache idxs bound")) (("2" (use "nth_ol[nat,<]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "nth_ac" -2) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (name-replace "somevidx" "varidx(nth(cache, k - 1)`1)") (("1" (use "last_idx_box") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (expand_ol) (("1" (expand "nth" -4 1) (("1" (assert) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-1 -7)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "newoff" 1) (("3" (expand ">=") (("3" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (1 -1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("4" (replace "newoff" 1) (("4" (expand "idxs_bounded" 1) (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "acRes" 1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (replace "varac" 1) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 -2 -3 1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "nwidxs" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (case "pow - 1 = opn(val(cached)`1)") (("1" (replace -1 1 :dir RL) (("1" (assert) (("1" (case "nth(append(take[nat](pownoises, pow - 2),
                   nats(nextfreeidx, newoff - 1)),
            pow - 2) = nextfreeidx") (("1" (assert) nil nil) ("2" (hide 2) (("2" (use "nth_append[nat]") (("1" (replaces -1 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "length(pownoises) = pow - 2") (("1" (replaces -1 2) (("1" (grind) nil nil)) nil) ("2" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("2" (replaces -1 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "nth_append[nat]") (("1" (replaces -1 2) (("1" (case "nth(nats(nextfreeidx, newoff - 1),
           pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (case "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 1) (("1" (replaces "newoff" 1) (("1" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (inst? -5) (("1" (replace -5 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil) ("2" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "newoff" 2) (("2" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (inst? -5) (("2" (replaces -5 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache idxs bounded" "i-1") (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 2 "cache idxs bounded")) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "correct_cache?") (("5" (expand "CacheData_correct?") (("5" (replace "re" 1) (("5" (assert) (("5" (lift-if "nwidxs") (("5" (split "nwidxs") (("1" (flatten) (("1" (replace -2 1) (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replaces -4 2) (("1" (case "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replace "pownoises") (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (flatten) (("2" (case "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                 nats(nextfreeidx, newoff - 1))) = car(pownoises)") (("1" (replaces -1 2) (("1" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (split "cached correct") (("1" (flatten) (("1" (split -2) (("1" (replace -4 "cached correct") (("1" (replace "re" "cached correct") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "take" -1) (("1" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (hide -1) (("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "take" 2) (("2" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "pownoises" 1) (("3" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("3" (use "cache_powvar_correct_result") (("3" (with-labels (assert) (("cached correct"))) (("3" (replace "cached" "cached correct" :dir RL) (("3" (expand "CacheData_correct?" "cached correct") (("3" (typepred "cached") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (split "cached correct") (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 2) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replace -4 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (flatten) (("2" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (inst -5 "0") (("1" (expand "nth") (("1" (replace -5 3) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -4 1) (("2" (replace "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ordered_list type-eq-decl nil ordered_list structures) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (Interval type-eq-decl nil interval interval_arith) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (power_Epsilon_is_Epsilon formula-decl nil affine_pow nil) (member_nats formula-decl nil affine_pow nil) (gnbi_updb_2 formula-decl nil affine nil) (ac_proj_pd formula-decl nil affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (powvar_comp_noise_extension formula-decl nil affine_pow nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (nth_ol formula-decl nil ordered_list structures) (last_idx const-decl "int" indexed_list structures) (olidx_car_last formula-decl nil indexed_list structures) (next_idx const-decl "nat" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (represents_var? const-decl "bool" affine nil) (last_idx_box formula-decl nil affine_box nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (eval_updb_no_idxs formula-decl nil affine nil) (beyond_last_idx_notmember formula-decl nil affine nil) (idxs_ac const-decl "list[nat]" affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (nzBaseType type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial reals) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (SingInterval? const-decl "bool" affine nil) (last_ol def-decl "T" ordered_list structures) (idxs_pd def-decl "list[nat]" affine nil) (pow_var_compatible_noise formula-decl nil affine_pow nil) (containment_pow_var_ac formula-decl nil affine_pow nil)) nil (RE2AC subtype "(number_fields.+)((number_fields.-)(IntervalExpr_adt.opn(Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1), 2), 1)" "nat")) (RE2AC_TCC54-1 nil 3631466640 ("" (cases-tcc) nil nil) ((Interval type-eq-decl nil interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (next_idx const-decl "nat" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil)) shostak (RE2AC subtype "(number_fields.+)((number_fields.-)(IntervalExpr_adt.opn(Maybe[CacheData].val(affine_expr_Eval_fnd.cached)`1), 2), 1)" "nat"))) (RE2AC_TCC60 0 (RE2AC_TCC60-1 "" 3789917765 ("" (skeep*) (("" (use "cache_powvar_correct_result") (("" (assert) nil nil)) nil)) nil) ((cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (powvar? const-decl "bool" affine_expr nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}")) (RE2AC_TCC55-2 nil 3637345872 ("" (then (skeep*) (use "cache_powvar_correct_result") (assert) (replace -6 -1 :dir RL) (expand "CacheData_correct?") (typepred "cached") (assert) (flatten) (assert) (flatten) (spread (split -5) ((then (flatten) (assert) (flatten) (assert) (replaces -8) (grind)) (grind)))) nil nil) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (powvar? const-decl "bool" affine_expr nil)) nil (RE2AC subtype "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}")) (RE2AC_TCC55-1 nil 3631554556 ("" (subtype-tcc) nil nil) ((Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Env type-eq-decl nil affine_box nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (next_idx const-decl "nat" affine nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (idxs_ac const-decl "list[nat]" affine nil)) nil (RE2AC subtype "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}"))) (RE2AC_TCC61 0 (RE2AC_TCC61-1 "" 3789917766 ("" (skeep*) (("" (use "cache_powvar_correct_result") (("" (assert) nil nil)) nil)) nil) ((cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (powvar? const-decl "bool" affine_expr nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}")) (RE2AC_TCC56-1 nil 3631622080 ("" (then (skeep*) (use "cache_powvar_correct_result") (assert) (replace -8 -1 :dir RL) (expand "CacheData_correct?") (typepred "cached") (assert) (flatten) (assert) (flatten) (spread (split -5) ((then (flatten) (assert) (flatten) (assert) (replaces -9) (grind)) (grind)))) nil nil) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (powvar? const-decl "bool" affine_expr nil)) shostak (RE2AC subtype "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}"))) (RE2AC_TCC62 0 (RE2AC_TCC57-3 nil 3767017849 ("" (skeep*) (("" (expand "nth_ac") (("" (replaces -4) (("" (hide-all-but 7) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((nth_ac const-decl "AffineCombination" affine_box nil) (represents_var? const-decl "bool" affine nil) (length def-decl "nat" list_props nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC57-2 nil 3631793678 ("" (then (skeep*) (assert) (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "pow < cached pow" -6) (label "cached" -7) (label "idxs" -8) (label "pownoises" -9) (label "acRes" -10) (label "result" -11) (label "idx" 1) (label "pow <= 1" 2) (label "no single value" 3) (label "no cv 0" 4))) (hide 5) (replaces "re") (replaces "result") (assert) (expand "correct_cache?" 5) (expand "CacheData_correct?") (expand "powvar?" 5) (expand "varidx_powvar" 5) (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bound" "cache correct" "UNKNOWN"))) (typepred "cached") (assert) (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (skeep "cached cache idx") (use "cache_powvar_correct_result") (with-labels (assert) ("cached is correct" "UNKNOWN")) (replace "cached" "cached is correct" :dir RL) (expand "CacheData_correct?") (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (spread (split "cached cond ok") ((then (replace "pownoises" "cached cond ok" :dir RL) (replace "cached`1 varidx" "cached cond ok") (reveal "re") (replace "re" "cached cond ok") (assert) (flatten "cached cond ok") (assert) (grind)) (then (replace "cached`1 varidx" "cached cond ok") (replace "varac" "no single value") (reveal "re") (hide-all-but ("no single value" "cached cond ok" "re")) (replaces "re") (assert) (grind))))) nil nil) ((varidx_powvar const-decl "nat" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (lt_realorder name-judgement "RealOrder" real_orders reals) (idxs_ac const-decl "list[nat]" affine nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (powvar? const-decl "bool" affine_expr nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC57-1 nil 3631622080 ("" (subtype-tcc) nil nil) ((Interval type-eq-decl nil interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.varac" "(affine.represents_var?)"))) (RE2AC_TCC63 0 (RE2AC_TCC63-1 "" 3803767122 ("" (skeep*) (("" (apply (then (label "re" -1) (label "varac" -4) (label "cached some" -6) (label "cached" -5) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 6) (label "not in cache 2" 5) (label "not in cache 1" 4))) (("" (with-labels (split "not in cache 1") (("pow gt opn cached`1"))) (("" (with-labels (split "not in cache 2") (("pow gt opn cached`1"))) (("1" (expand "/=") (("1" (propax) nil nil)) nil) ("2" (replaces "nwidxs" 7) (("2" (split 7) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (assert) (("1" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (split "cached correct") (("1" (flatten) (("1" (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (typepred "nwidxs2") (("1" (expand "append_ol") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "appendable_ol?") (("2" (flatten) (("2" (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (replaces -1 3) (("1" (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (replace -1 3 :hide? t) (("1" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("1" (skeep "cached cache idx") (("1" (hide 4) (("1" (replace "pownoises" 1) (("1" (replace "cached cache idx" 1 :dir RL) (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (expand "idxs_bounded") (("1" (expand "nth_ac") (("1" (replace "pownoises") (("1" (inst "cache correct" "i") (("1" (replace "cached`2 is powvarac") (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 "cached correct" "pow gt opn cached`1")) (("2" (replaces -2 1) (("2" (expand "nats" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (expand "first_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "last_take_nth[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("3" (use "take_ol[nat,<]") (("3" (assert) nil nil)) nil) ("4" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replaces -4 2) (("1" (use "length_take[nat]") (("1" (replaces -1 2) (("1" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (expand "min" 2) (("1" (lift-if 2) (("1" (case "length(pownoises) = opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (assert) (("2" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (flatten) (("2" (replace "pownoises" 2) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (assert) (("2" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (replace "cached`1 varidx" "cached cond ok") (("2" (split "cached cond ok") (("1" (flatten) (("1" (replaces "varac" 2) (("1" (replace "re" "cached cond ok") (("1" (assert) (("1" (case "car[nat]
                                                                                                                                            (append(take[nat](val(cached)`3, opn(val(cached)`1) - 2 + 1),
                                                                                                                                                    nats(nextfreeidx, newoff - 1))) = car(val(cached)`3)") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "take" 1) (("2" (expand "append" 1) (("2" (propax) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replace -4 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (flatten) (("2" (expand "nats" 2) (("2" (replace "newoff" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (replace "varac" 1) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (replace "varac" 2) (("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (RE2AC subtype "affine_expr_Eval_fnd.nwidxs" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}")) (RE2AC_TCC58-2 nil 3767017892 ("" (skeep*) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (with-labels (split "not in cache 1") (("pow gt opn cached`1"))) (("" (with-labels (split "not in cache 2") (("pow gt opn cached`1"))) (("1" (expand "/=") (("1" (propax) nil nil)) nil) ("2" (replaces "nwidxs" 7) (("2" (split 7) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (assert) (("1" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (split "cached correct") (("1" (flatten) (("1" (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (typepred "nwidxs2") (("1" (expand "append_ol") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "appendable_ol?") (("2" (flatten) (("2" (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (replaces -1 3) (("1" (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (replace -1 3 :hide? t) (("1" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("1" (skeep "cached cache idx") (("1" (hide 4) (("1" (replace "pownoises" 1) (("1" (replace "cached cache idx" 1 :dir RL) (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (expand "idxs_bounded") (("1" (expand "nth_ac") (("1" (replace "pownoises") (("1" (inst "cache correct" "i") (("1" (replace "cached`2 is powvarac") (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 "cached correct" "pow gt opn cached`1")) (("2" (replaces -2 1) (("2" (expand "nats" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (expand "first_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "last_take_nth[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("3" (use "take_ol[nat,<]") (("3" (assert) nil nil)) nil) ("4" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replaces -4 2) (("1" (use "length_take[nat]") (("1" (replaces -1 2) (("1" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (expand "min" 2) (("1" (lift-if 2) (("1" (case "length(pownoises) = opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (assert) (("2" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (flatten) (("2" (replace "pownoises" 2) (("2" (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("2" (assert) (("2" (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("2" (replace "cached`1 varidx" "cached cond ok") (("2" (split "cached cond ok") (("1" (flatten) (("1" (replaces "varac" 2) (("1" (replace "re" "cached cond ok") (("1" (assert) (("1" (case "car[nat]
                                                                                                                           (append(take[nat](val(cached)`3, opn(val(cached)`1) - 2 + 1),
                                                                                                                                   nats(nextfreeidx, newoff - 1))) = car(val(cached)`3)") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "take" 1) (("2" (expand "append" 1) (("2" (propax) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replace -4 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (flatten) (("2" (expand "nats" 2) (("2" (replace "newoff" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (replace "varac" 1) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (replace "varac" 2) (("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((/= const-decl "boolean" notequal nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (int_plus_int_is_int application-judgement "int" integers nil) (take_ol formula-decl nil ordered_list structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last_ol def-decl "T" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (idxs_pd def-decl "list[nat]" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (Noise type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (idxs_ac const-decl "list[nat]" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (next_idx const-decl "nat" affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (var_ac const-decl "AffineCombination" affine nil) (represents_var? const-decl "bool" affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (nth_ac const-decl "AffineCombination" affine_box nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (re skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (cached skolem-const-decl "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" affine_expr_Eval_fnd nil) (pownoises skolem-const-decl "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]" affine_expr_Eval_fnd nil) (last_take_nth formula-decl nil ordered_list structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (<= const-decl "bool" reals nil) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (take def-decl "list[T]" more_list_props structures) (append_ol const-decl "ordered_list" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (powvar? const-decl "bool" affine_expr nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (length_take formula-decl nil more_list_props structures) (newoff skolem-const-decl "int" affine_expr_Eval_fnd nil) (length_append formula-decl nil list_props nil) (append def-decl "list[T]" list_props nil) (last_idx_box formula-decl nil affine_box nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.nwidxs" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}")) (RE2AC_TCC58-1 nil 3631622080 ("" (then (skeep*) (assert) (hide -12) (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "pow < cached pow" -6) (label "cached" -7) (label "idxs" -8) (label "pownoises" -9) (label "acRes" -10) (label "result" -11) (label "idx" 1) (label "pow <= 1" 2) (label "no single value" 3) (label "no cv 0" 4))) (replaces "re") (replaces "result") (assert) (spread (split 5) ((then (inst 1 "(: (POW(re1, pow), acRes, pownoises) :)") (grind)) (then (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (expand "compatible_pairs?" "cache compatible pairs") (with-labels (skeep "cache compatible pairs") (("vars in box" "compatible on"))) (inst 1 "N") (assert) (expand "compatible_pairs_on?" 1) (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (expand "powvar?" 1) (expand "varidx_powvar" 1) (expand "compatible_pairs_on?") (typepred "cached") (assert) (with-labels (flatten -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (skeep "cached cache idx") (inst "compatible on" "i!1") (use "cache_powvar_correct_result") (with-labels (assert -1) ("cached is correct" "UNKNOWN")) (replace "cached" "cached is correct" :dir RL) (expand "CacheData_correct?") (with-labels (assert (-1 "cached`1 is powvar")) ("cached is correct" "UNKNOWN")) (with-labels (flatten "cached is correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (spread (split "cached cond ok") ((then (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (skeep) (inst "compatible on" "n") (with-labels (flatten "compatible on") (("eval cache" "cache if powvar" "UNKNOWN"))) (replace "cached`2 is powvarac" "eval cache") (replace "acRes" 1) (replace "varac" 1) (replace "cached cache idx" "cached`1 varidx" :dir RL) (reveal "re") (assert) (replace "cached cache idx" "pownoises" :dir RL) (replace "pownoises" "eval cache" :dir RL) (spread (case "nth(cache, i!1)`1 = POW(re1, opn(nth(cache, i!1)`1))") ((then (replaces -1) (expand "eval_ACExpr_Env") (expand "eval") (lemma "containment_pow_var_ac") (spread (split 1) ((then (use "containment_pow_var_ac") (assert) (spread (split 1) ((then (expand "eval") (replace -16 :dir RL) (expand "vars_in_box_compatible?") (inst? "vars in box") (flatten) (expand "nth_ac") (propax)) (then (flatten) (replace "pownoises") (hide -2) (spread (split "cached cond ok") ((then (typepred "cached") (spread (split -1) ((then (flatten) (replace -2 :hide? t) (replace "re" "cached cond ok") (assert) (hide-all-but ("cached cond ok" -4 "cached cache idx")) (expand "next_idx") (expand "last_idx") (expand ">=") (use "notmember_ol_nat") (assert) (spread (split 1) ((grind) (then (lift-if "cached cond ok") (spread (split "cached cond ok") ((then (flatten) (expand "varidx_powvar") (use "olidx_car_last[nzBaseType]") (assert) (expand "car_ol") (assert)) (then (flatten) (expand "varidx_powvar") (assert)))))))) (propax)))) (grind)))) (then (expand "pow_var_compatible?") (skeep) (expand "varidx_powvar") (inst "cache if powvar" "i!2") (replace "pownoises" "cache if powvar" :dir RL) (assert))))) (then (expand "pow_var_compatible?") (skeep) (expand "varidx_powvar") (inst "cache if powvar" "i!2") (replace "pownoises" "cache if powvar" :dir RL) (propax))))) (then (hide-all-but (1 "cached`1 is powvar" "cached`1 varidx" "re" "cached cache idx" -13 -14)) (replaces "cached cache idx" :dir RL) (replaces "re") (assert) (apply-extensionality) (expand "varidx_powvar") (use "IntervalExpr_VARIDX_extensionality") (assert))))) (then (replace "cached`1 varidx" "cached cond ok") (replace "varac" "no single value") (reveal "re") (hide-all-but ("no single value" "cached cond ok" "re")) (replaces "re") (assert) (expand "varidx_powvar") (grind))))) (then (expand "compatible_pairs_on?" "compatible on") (spread (inst "compatible on" "i-1") ((then (expand "nth" 2) (assert)) (then (typepred "i") (grind)))))))) (then (expand "idxs_bounded") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (replaces "acRes") (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (expand "idxs_bounded" "cache idxs bound") (typepred "cached") (assert) (with-labels (flatten -1) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (skeep "cached cache idx") (inst "cache idxs bound" "i!1") (use "cache_powvar_correct_result") (with-labels (assert (-1 "cache correct")) ("cached is correct" "UNKNOWN")) (replace "cached" "cached is correct" :dir RL) (expand "CacheData_correct?") (assert ("cached is correct" "cached`1 is powvar")) (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (spread (split "cached cond ok") ((then (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (replace "cached`2 is powvarac" "cache idxs bound") (replace "cached cache idx" "pownoises" :dir RL) (replace "pownoises" "cache idxs bound" :dir RL) (replace "cached cache idx" "cached`1 varidx" :dir RL) (replace "cached`1 varidx" "cache idxs bound") (reveal "re") (replace "re" "cache idxs bound") (assert) (use "next_idx_pow_var_ac") (replaces -1) (use "next_idx_pow_var_ac") (replaces -1) (lift-if 1) (spread (split 1) ((then (flatten) (assert)) (then (lift-if "cache idxs bound") (spread (split "cache idxs bound") ((grind) (then (with-labels (flatten "cache idxs bound") (("already knonwn" "already knonwn" "cache idxs bound" "UNKNOWN"))) (spread (split "cache idxs bound") ((then (flatten) (grind)) (then (with-labels (flatten "cache idxs bound") (("opn not 1" "cache idxs bound" "UNKNOWN"))) (assert) (hide-all-but (4 "cache idxs bound" "pow < cached pow" "cached cache idx")) (replaces "cached cache idx" :dir RL) (expand ">") (expand ">=") (use "nth_ol[nat,<]") (assert))))))))))) (then (replace "cached`1 varidx" "cached cond ok") (replace "varac" "no single value") (reveal "re") (hide-all-but ("no single value" "cached cond ok" "re")) (replaces "re") (assert) (expand "varidx_powvar") (grind))))) (then (expand "nth" 2) (assert) (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (expand "idxs_bounded" "cache idxs bound") (inst "cache idxs bound" "i-1")))))))) nil nil) ((last_ol def-decl "T" ordered_list structures) (factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial reals) (cdr_ol const-decl "ordered_list" ordered_list structures) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (idxs_ac const-decl "list[nat]" affine nil) (nth_ol formula-decl nil ordered_list structures) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (powvar? const-decl "bool" affine_expr nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (IntervalExpr_POW_extensionality formula-decl nil IntervalExpr_adt interval_arith) (IntervalExpr_VARIDX_extensionality formula-decl nil IntervalExpr_adt interval_arith) (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (op shared-adt-accessor-decl "[{x: IntervalExpr |
         bincludes?(x) OR fun?(x) OR pow?(x) OR sq?(x) OR neg?(x)
     OR abs?(x)} ->
   RealExpr]" IntervalExpr_adt interval_arith) (eval def-decl "real" interval_expr interval_arith) (pow_var_compatible? const-decl "bool" affine_pow nil) (last_idx const-decl "int" indexed_list structures) (notmember_ol_nat formula-decl nil affine_pow nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (car_ol const-decl "T" ordered_list structures) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (olidx_car_last formula-decl nil indexed_list structures) (vars_in_box_compatible? const-decl "bool" affine_box nil) (next_idx const-decl "nat" affine nil) (nzBaseType type-eq-decl nil affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (represents_var? const-decl "bool" affine nil) (Env type-eq-decl nil box interval_arith) (containment_pow_var_ac formula-decl nil affine_pow nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (varidx_powvar const-decl "nat" affine_expr nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "affine_expr_Eval_fnd.nwidxs" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}"))) (RE2AC_TCC64 0 (RE2AC_TCC64-2 "" 3803767336 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -4) (label "cached some" -6) (label "cached" -5) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 6) (label "pow gt opn" 5) (label "opw gt opn" 4))) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (expand "every") (("1" (split 1) (("1" (replace "nwidxs" 1) (("1" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert (-1 "cache correct")) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (assert) (("1" (with-labels (flatten "cached correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (split 1) (("1" (flatten) (("1" (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (typepred "nwidxs2") (("1" (expand "append_ol") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "appendable_ol?") (("2" (flatten) (("2" (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (replaces -1 3) (("1" (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (replaces -1 3) (("1" (skeep "cached cache idx") (("1" (replace "pownoises" 1) (("1" (replace "cached cache idx" 1 :dir RL) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (inst "cache idxs bound" "i") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (replace "cached`2 is powvarac" "cache idxs bound") (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if "cache idxs bound") (("1" (split "cache idxs bound") (("1" (assert) (("1" (replace "varac" "varac not single value") (("1" (replace "cached cache idx" "cache idxs bound") (("1" (replace "cached`1 varidx" "cache idxs bound") (("1" (replace "re") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (flatten "cache idxs bound") (("opn not 0" "varac not single value" "cache idxs bound" "UNKNOWN"))) (("2" (split "cache idxs bound") (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (with-labels (flatten "cache idxs bound") (("opn not 1" "cache idxs bound" "UNKNOWN"))) (("2" (expand ">=") (("2" (replace "pownoises" 6) (("2" (replace "cached cache idx" 6 :dir RL) (("2" (hide-all-but ("cache idxs bound" 6)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 5 -1 "pow gt opn" "opw gt opn")) (("2" (expand "nats" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (expand "first_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "last_take_nth[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (use "last_take_nth[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (use "take_ol[nat,<]") (("4" (assert) nil nil)) nil) ("5" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "cache") (("2" (generalize "cache" "cache") (("2" (induct "cache") (("1" (grind) nil nil) ("2" (skolem 1 ("h" "t")) (("2" (flatten) (("2" (expand "every" 1) (("2" (split 1) (("1" (typepred "h`3") (("1" (assert) nil nil)) nil) ("2" (split -1) (("1" (propax) nil nil) ("2" (expand "correct_cache?" -1) (("2" (flatten) nil nil)) nil) ("3" (expand "compatible_pairs?") (("3" (skeep) (("3" (inst?) (("3" (assert) (("3" (expand "compatible_pairs_on?") (("3" (skeep) (("3" (expand "nth" -3) (("3" (inst -3 "i+1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "idxs_bounded") (("4" (skeep) (("4" (expand "nth" -3) (("4" (inst -3 "i+1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "correct_cache?" -1) (("5" (flatten) nil nil)) nil) ("6" (expand "compatible_pairs?") (("6" (skeep) (("6" (inst?) (("6" (assert) (("6" (expand "compatible_pairs_on?") (("6" (skeep) (("6" (expand "nth" -3) (("6" (inst -3 "i+1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (expand "idxs_bounded") (("7" (skeep) (("7" (expand "nth" -3) (("7" (inst -3 "i+1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "correct_cache?") (("2" (expand "CacheData_correct?") (("2" (replace "re" 1) (("2" (assert) (("2" (lift-if "nwidxs") (("2" (split "nwidxs") (("1" (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (replace "nwidxs" 1) (("1" (expand "powvar?") (("1" (expand "varidx_powvar") (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (with-labels (typepred "nats(nextfreeidx, newoff - 1)") (("nats list[nat]" "nats ol" "nats not null" "nats car" "nats length" "nats i") ("newoff >= 1"))) (("1" (replaces "nats length" 2) (("1" (case "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replace "pownoises") (("2" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert -1) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (hide -3 "nats i") (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (flatten) (("2" (case "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                                                                                     nats(nextfreeidx, newoff - 1))) = car(pownoises)") (("1" (replaces -1 2) (("1" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert -1) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (split "cached correct") (("1" (flatten) (("1" (split -2) (("1" (replace -4 "cached correct") (("1" (replace "re" "cached correct") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "take" -1) (("1" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (hide -1) (("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "take" 2) (("2" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "pownoises" 1) (("3" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("3" (use "cache_powvar_correct_result") (("3" (with-labels (assert) (("cached correct"))) (("3" (replace "cached" "cached correct" :dir RL) (("3" (expand "CacheData_correct?" "cached correct") (("3" (typepred "cached") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (split "cached correct") (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil) ("3" (replaces "varac") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 2) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (expand "varidx_powvar") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (flatten) (("2" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (inst -5 "0") (("1" (expand "nth") (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -4 1) (("2" (replace "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (replaces "varac") (("3" (expand "varidx_powvar") (("3" (replaces -5) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "newoff") (("3" (hide-all-but (1 "pow gt opn" "opw gt opn")) (("3" (case "opn(val(cached)`1) < pow") (("1" (hide "pow gt opn" "opw gt opn") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 <= pow - opn(val(cached)`1)") (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC64-1 "" 3789917822 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (expand "every") (("1" (split 1) (("1" (replace "nwidxs" 1) (("1" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert (-1 "cache correct")) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (assert) (("1" (with-labels (flatten "cached correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (split 1) (("1" (flatten) (("1" (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (typepred "nwidxs2") (("1" (expand "append_ol") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "appendable_ol?") (("2" (flatten) (("2" (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (replaces -1 3) (("1" (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (replaces -1 3) (("1" (skeep "cached cache idx") (("1" (replace "pownoises" 1) (("1" (replace "cached cache idx" 1 :dir RL) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (inst "cache idxs bound" "i") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (replace "cached`2 is powvarac" "cache idxs bound") (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if "cache idxs bound") (("1" (split "cache idxs bound") (("1" (assert) (("1" (replace "varac" "varac not single value") (("1" (replace "cached cache idx" "cache idxs bound") (("1" (replace "cached`1 varidx" "cache idxs bound") (("1" (replace "re") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (flatten "cache idxs bound") (("opn not 0" "varac not single value" "cache idxs bound" "UNKNOWN"))) (("2" (split "cache idxs bound") (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (with-labels (flatten "cache idxs bound") (("opn not 1" "cache idxs bound" "UNKNOWN"))) (("2" (expand ">=") (("2" (replace "pownoises" 6) (("2" (replace "cached cache idx" 6 :dir RL) (("2" (hide-all-but ("cache idxs bound" 6)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 5 -1 "pow gt opn" "opw gt opn")) (("2" (expand "nats" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (expand "first_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "last_take_nth[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (use "last_take_nth[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (use "take_ol[nat,<]") (("4" (assert) nil nil)) nil) ("5" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "cache") (("2" (generalize "cache" "cache") (("2" (induct "cache") (("1" (grind) nil nil) ("2" (skolem 1 ("h" "t")) (("2" (flatten) (("2" (expand "every" 1) (("2" (split 1) (("1" (typepred "h`3") (("1" (assert) nil nil)) nil) ("2" (split -1) (("1" (propax) nil nil) ("2" (expand "correct_cache?" -1) (("2" (flatten) nil nil)) nil) ("3" (expand "compatible_pairs?") (("3" (skeep) (("3" (inst?) (("3" (assert) (("3" (expand "compatible_pairs_on?") (("3" (skeep) (("3" (expand "nth" -3) (("3" (inst -3 "i+1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "idxs_bounded") (("4" (skeep) (("4" (expand "nth" -3) (("4" (inst -3 "i+1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "correct_cache?" -1) (("5" (flatten) nil nil)) nil) ("6" (expand "compatible_pairs?") (("6" (skeep) (("6" (inst?) (("6" (assert) (("6" (expand "compatible_pairs_on?") (("6" (skeep) (("6" (expand "nth" -3) (("6" (inst -3 "i+1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (expand "idxs_bounded") (("7" (skeep) (("7" (expand "nth" -3) (("7" (inst -3 "i+1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "correct_cache?") (("2" (expand "CacheData_correct?") (("2" (replace "re" 1) (("2" (assert) (("2" (lift-if "nwidxs") (("2" (split "nwidxs") (("1" (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (replace "nwidxs" 1) (("1" (expand "powvar?") (("1" (expand "varidx_powvar") (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (with-labels (typepred "nats(nextfreeidx, newoff - 1)") (("nats list[nat]" "nats ol" "nats not null" "nats car" "nats length" "nats i") ("newoff >= 1"))) (("1" (replaces "nats length" 2) (("1" (case "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replace "pownoises") (("2" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert -1) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (hide -3 "nats i") (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (flatten) (("2" (case "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                                                                        nats(nextfreeidx, newoff - 1))) = car(pownoises)") (("1" (replaces -1 2) (("1" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert -1) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (split "cached correct") (("1" (flatten) (("1" (split -2) (("1" (replace -4 "cached correct") (("1" (replace "re" "cached correct") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "take" -1) (("1" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (hide -1) (("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "take" 2) (("2" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "pownoises" 1) (("3" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("3" (use "cache_powvar_correct_result") (("3" (with-labels (assert) (("cached correct"))) (("3" (replace "cached" "cached correct" :dir RL) (("3" (expand "CacheData_correct?" "cached correct") (("3" (typepred "cached") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (split "cached correct") (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil) ("3" (replaces "varac") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 2) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (expand "varidx_powvar") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (flatten) (("2" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (inst -5 "0") (("1" (expand "nth") (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -4 1) (("2" (replace "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (replaces "varac") (("3" (expand "varidx_powvar") (("3" (replaces -5) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "newoff") (("3" (hide-all-but (1 "pow gt opn" "opw gt opn")) (("3" (case "opn(val(cached)`1) < pow") (("1" (hide "pow gt opn" "opw gt opn") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 <= pow - opn(val(cached)`1)") (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (take_ol formula-decl nil ordered_list structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (last_ol def-decl "T" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (append def-decl "list[T]" list_props nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_ac const-decl "list[nat]" affine nil) (factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial reals) (cdr_ol const-decl "ordered_list" ordered_list structures) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (next_idx const-decl "nat" affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth_ac const-decl "AffineCombination" affine_box nil) (represents_var? const-decl "bool" affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (re skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (cached skolem-const-decl "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" affine_expr_Eval_fnd nil) (pownoises skolem-const-decl "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]" affine_expr_Eval_fnd nil) (last_take_nth formula-decl nil ordered_list structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (<= const-decl "bool" reals nil) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (take def-decl "list[T]" more_list_props structures) (append_ol const-decl "ordered_list" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (powvar? const-decl "bool" affine_expr nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (list_induction formula-decl nil list_adt nil) (i skolem-const-decl "below(length(t))" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(t))" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(t))" affine_expr_Eval_fnd nil) (Noise type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (h skolem-const-decl "CacheData" affine_expr_Eval_fnd nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (i skolem-const-decl "below(length(t))" affine_expr_Eval_fnd nil) (t skolem-const-decl "list[CacheData]" affine_expr_Eval_fnd nil) (every adt-def-decl "boolean" list_adt nil) (length_append formula-decl nil list_props nil) (newoff skolem-const-decl "int" affine_expr_Eval_fnd nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (length_take formula-decl nil more_list_props structures) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (last_idx_box formula-decl nil affine_box nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC59-5 nil 3767018113 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (expand "every") (("1" (split 1) (("1" (replace "nwidxs" 1) (("1" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert (-1 "cache correct")) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (assert) (("1" (with-labels (flatten "cached correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (split 1) (("1" (flatten) (("1" (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (typepred "nwidxs2") (("1" (expand "append_ol") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "appendable_ol?") (("2" (flatten) (("2" (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (replaces -1 3) (("1" (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (replaces -1 3) (("1" (skeep "cached cache idx") (("1" (replace "pownoises" 1) (("1" (replace "cached cache idx" 1 :dir RL) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (inst "cache idxs bound" "i") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (replace "cached`2 is powvarac" "cache idxs bound") (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if "cache idxs bound") (("1" (split "cache idxs bound") (("1" (assert) (("1" (replace "varac" "varac not single value") (("1" (replace "cached cache idx" "cache idxs bound") (("1" (replace "cached`1 varidx" "cache idxs bound") (("1" (replace "re") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (flatten "cache idxs bound") (("opn not 0" "varac not single value" "cache idxs bound" "UNKNOWN"))) (("2" (split "cache idxs bound") (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (with-labels (flatten "cache idxs bound") (("opn not 1" "cache idxs bound" "UNKNOWN"))) (("2" (expand ">=") (("2" (replace "pownoises" 6) (("2" (replace "cached cache idx" 6 :dir RL) (("2" (hide-all-but ("cache idxs bound" 6)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 5 -1 "pow gt opn" "opw gt opn")) (("2" (expand "nats" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (expand "first_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "last_take_nth[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (use "last_take_nth[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (use "take_ol[nat,<]") (("4" (assert) nil nil)) nil) ("5" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "cache") (("2" (generalize "cache" "cache") (("2" (induct "cache") (("1" (grind) nil nil) ("2" (skolem 1 ("h" "t")) (("2" (flatten) (("2" (expand "every" 1) (("2" (split 1) (("1" (typepred "h`3") (("1" (assert) nil nil)) nil) ("2" (split -1) (("1" (propax) nil nil) ("2" (expand "correct_cache?" -1) (("2" (flatten) nil nil)) nil) ("3" (expand "compatible_pairs?") (("3" (skeep) (("3" (inst?) (("3" (assert) (("3" (expand "compatible_pairs_on?") (("3" (skeep) (("3" (expand "nth" -3) (("3" (inst -3 "i+1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "idxs_bounded") (("4" (skeep) (("4" (expand "nth" -3) (("4" (inst -3 "i+1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "correct_cache?" -1) (("5" (flatten) nil nil)) nil) ("6" (expand "compatible_pairs?") (("6" (skeep) (("6" (inst?) (("6" (assert) (("6" (expand "compatible_pairs_on?") (("6" (skeep) (("6" (expand "nth" -3) (("6" (inst -3 "i+1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (expand "idxs_bounded") (("7" (skeep) (("7" (expand "nth" -3) (("7" (inst -3 "i+1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "correct_cache?") (("2" (expand "CacheData_correct?") (("2" (replace "re" 1) (("2" (assert) (("2" (lift-if "nwidxs") (("2" (split "nwidxs") (("1" (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (replace "nwidxs" 1) (("1" (expand "powvar?") (("1" (expand "varidx_powvar") (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (with-labels (typepred "nats(nextfreeidx, newoff - 1)") (("nats list[nat]" "nats ol" "nats not null" "nats car" "nats length" "nats i") ("newoff >= 1"))) (("1" (replaces "nats length" 2) (("1" (case "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replace "pownoises") (("2" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert -1) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (hide -3 "nats i") (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (flatten) (("2" (case "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                                                                        nats(nextfreeidx, newoff - 1))) = car(pownoises)") (("1" (replaces -1 2) (("1" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert -1) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (split "cached correct") (("1" (flatten) (("1" (split -2) (("1" (replace -4 "cached correct") (("1" (replace "re" "cached correct") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "take" -1) (("1" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (hide -1) (("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "take" 2) (("2" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "pownoises" 1) (("3" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("3" (use "cache_powvar_correct_result") (("3" (with-labels (assert) (("cached correct"))) (("3" (replace "cached" "cached correct" :dir RL) (("3" (expand "CacheData_correct?" "cached correct") (("3" (typepred "cached") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (split "cached correct") (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil) ("3" (replaces "varac") (("3" (replaces "idx") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 2) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (expand "varidx_powvar") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (flatten) (("2" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (inst -5 "0") (("1" (expand "nth") (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -4 1) (("2" (replace "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (replaces "varac") (("3" (expand "varidx_powvar") (("3" (replaces -5) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "newoff") (("3" (hide-all-but (1 "pow gt opn" "opw gt opn")) (("3" (case "opn(val(cached)`1) < pow") (("1" (hide "pow gt opn" "opw gt opn") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 <= pow - opn(val(cached)`1)") (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (take_ol formula-decl nil ordered_list structures) (last_ol def-decl "T" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (idxs_ac const-decl "list[nat]" affine nil) (factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial reals) (cdr_ol const-decl "ordered_list" ordered_list structures) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (next_idx const-decl "nat" affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (represents_var? const-decl "bool" affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (last_take_nth formula-decl nil ordered_list structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (take def-decl "list[T]" more_list_props structures) (append_ol const-decl "ordered_list" ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (lt_realorder name-judgement "RealOrder" real_orders reals) (varidx_powvar const-decl "nat" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (powvar? const-decl "bool" affine_expr nil) (Noise type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (length_take formula-decl nil more_list_props structures) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (last_idx_box formula-decl nil affine_box nil) (gt_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC59-4 nil 3632075985 ("" (grind) nil nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Env type-eq-decl nil affine_box nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (varidx_powvar const-decl "nat" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_ol? const-decl "bool" ordered_list structures) (idxs_ac const-decl "list[nat]" affine nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC59-3 nil 3632063218 ("" (skeep*) (("" (assert) (("" (hide -8) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached" -3) (label "newoff" -4) (label "nwidxs" -5) (label "acRes" -6) (label "result" -7) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(: (POWVAR(idx, pow), acRes, nwidxs) :)") (("1" (grind) nil nil)) nil) ("2" (with-labels (typepred "cache") (("cache comp pairs" "cache idxs bound" "cache correct" "UNKNOWN"))) (("2" (expand "compatible_pairs?") (("2" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (inst 1 "upd_noise_burst(N, nwidxs, LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (skeep) (("1" (inst "N vars in box" "i_1") (("1" (with-labels (flatten) (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "i_1") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (hide-all-but (1 "pow <= 1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1 1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces "single intervals in box" 1 :dir RL) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "i_1") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skeep 1) (("2" (case "i_1=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env" 1) (("1" (expand "vars_in_box_compatible?") (("1" (inst "N vars in box" "idx") (("1" (flatten) (("1" (replace "N vars in box" 1 :dir RL) (("1" (replace "acRes" 1) (("1" (split 1) (("1" (use "containment_pow_var_ac") (("1" (assert) (("1" (split 1) (("1" (hide 2) (("1" (replaces "varac") (("1" (expand "nth_ac") (("1" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 2) (("1" (skolem 1 "k") (("1" (flatten) (("1" (use "idxs_ac_var_ac") (("1" (assert) (("1" (replaces -1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flatten) (("2" (replaces "nwidxs" -1) (("2" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (expand ">") (("1" (replaces "varac") (("1" (use "last_idx_box") (("1" (expand ">=") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (expand "last_ol") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (use "pow_var_compatible_noise") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (use "pow_var_compatible_noise") (("1" (replace "varac" 1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst "cache comp pairs on" "i_1 -1 ") (("1" (expand "nth" 2) (("1" (assert) (("1" (flatten) (("1" (replaces "cache comp pairs on" 2 :dir RL) (("1" (split 2) (("1" (use "eval_updb_no_idxs") (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "idxs_bounded") (("2" (inst "cache idxs bound" "i_1 - 1") (("2" (expand "idxs_ac") (("2" (expand "next_idx") (("2" (use "beyond_last_idx_notmember") (("2" (assert) (("2" (replaces "nwidxs" -1) (("2" (use "member_nats") (("1" (assert) nil nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "pow_var_compatible?") (("2" (flatten) (("2" (assert) (("2" (skeep) (("2" (inst?) (("2" (case "get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                             upd_noise_burst(N,
                                                                             nwidxs,
                                                                             LAMBDA
                                                                             (i: nat):
                                                                             (get_noise_by_idx
                                                                              (car(pd(varac))`1, N)
                                                                              ^
                                                                              (2 + i)))) = get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                             N)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))),
                                                                      0)`1,
                                                                  upd_noise_burst(N,
                                                                                  nwidxs,
                                                                                  LAMBDA
                                                                                  (i: nat):
                                                                                  (get_noise_by_idx
                                                                                   (car(pd(varac))`1, N)
                                                                                   ^
                                                                                   (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))),
                                                                      0)`1,
                                                                  N)") (("1" (replaces -1) nil nil) ("2" (hide 2) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replace "nwidxs" -1) (("1" (expand "nth" -1 1) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (lemma "last_idx_box") (("1" (inst? -1 :where -2) (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (case "NOT null?(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))))") (("1" (assert) (("1" (lemma "olidx_car_last[nzBaseType]") (("1" (inst? -1 :where 1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (assert) (("1" (expand "car_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (hide "cache comp pairs on") (("1" (replace "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst? "cache idxs bound") (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (replace -1 "cache idxs bound") (("2" (expand ">=") (("2" (hide-all-but (-5 1 "cache idxs bound")) (("2" (use "nth_ol[nat,<]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i_1") (("2" (hide-all-but (-1 1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "newoff") (("3" (expand ">=") (("3" (hide-all-but (1 "pow <= 1")) (("3" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (typepred "cache") (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replaces "acRes") (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nwidxs") (("1" (case "length(nwidxs)=0") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replaces "newoff") (("2" (assert) (("2" (expand ">=") (("2" (replaces "nwidxs") (("2" (typepred "nats(nextfreeidx, nextfreeidx - 2 + pow)") (("2" (inst -5 "pow-2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) (("2" (replaces "newoff") (("2" (hide-all-but (2 -2 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "correct_cache?") (("5" (expand "CacheData_correct?") (("5" (flatten) (("5" (typepred "nextfreeidx") (("5" (replaces "nwidxs" 2) (("5" (expand "nats" 2) (("5" (lift-if 2) (("5" (split 2) (("1" (assert) (("1" (flatten) (("1" (replaces -1 1 :dir RL) (("1" (use "last_idx_box") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (use "last_idx_box") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Interval type-eq-decl nil interval interval_arith) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (nzBaseType type-eq-decl nil affine nil) (containment_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (eval_updb_no_idxs formula-decl nil affine nil) (idxs_ac_var_ac formula-decl nil affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_idx const-decl "int" indexed_list structures) (SingInterval? const-decl "bool" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (last_ol def-decl "T" ordered_list structures) (next_idx const-decl "nat" affine nil) (last_idx_box formula-decl nil affine_box nil) (pow_var_compatible_noise formula-decl nil affine_pow nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (beyond_last_idx_notmember formula-decl nil affine nil) (idxs_ac const-decl "list[nat]" affine nil) (olidx_car_last formula-decl nil indexed_list structures) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (nth_ol formula-decl nil ordered_list structures) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (ac_proj_pd formula-decl nil affine nil) (gnbi_updb_2 formula-decl nil affine nil) (member_nats formula-decl nil affine_pow nil) (power_Epsilon_is_Epsilon formula-decl nil affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (Env type-eq-decl nil affine_box nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC59-2 nil 3631872861 ("" (skeep*) (("" (assert) (("" (hide -8) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached" -3) (label "newoff" -4) (label "nwidxs" -5) (label "acRes" -6) (label "result" -7) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(: (POWVAR(idx, pow), acRes, nwidxs) :)") (("1" (grind) nil nil)) nil) ("2" (with-labels (typepred "cache") (("cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (expand "compatible_pairs?") (("2" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (inst 1 "upd_noise_burst(N, nwidxs, LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (skeep) (("1" (inst "N vars in box" "i_1") (("1" (with-labels (flatten) (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "i_1") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (hide-all-but (1 "pow <= 1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces "single intervals in box" 1 :dir RL) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "i_1") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skeep 1) (("2" (case "i_1=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env" 1) (("1" (expand "vars_in_box_compatible?") (("1" (inst "N vars in box" "idx") (("1" (flatten) (("1" (replace "N vars in box" 1 :dir RL) (("1" (replace "acRes" 1) (("1" (split 1) (("1" (use "containment_pow_var_ac") (("1" (assert) (("1" (split 1) (("1" (hide 2) (("1" (replaces "varac") (("1" (expand "nth_ac") (("1" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 2) (("1" (skolem 1 "k") (("1" (flatten) (("1" (use "idxs_ac_var_ac") (("1" (assert) (("1" (replaces -1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flatten) (("2" (replaces "nwidxs" -1) (("2" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (expand ">") (("1" (replaces "varac") (("1" (use "last_idx_box") (("1" (expand ">=") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (expand "last_ol") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (use "pow_var_compatible_noise") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (use "pow_var_compatible_noise") (("1" (replace "varac" 1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst "cache comp pairs on" "i_1 -1 ") (("1" (expand "nth" 2) (("1" (assert) (("1" (flatten) (("1" (replaces "cache comp pairs on" 2 :dir RL) (("1" (split 2) (("1" (use "eval_updb_no_idxs") (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "idxs_bounded") (("2" (inst "cache idxs bound" "i_1 - 1") (("2" (expand "idxs_ac") (("2" (expand "next_idx") (("2" (use "beyond_last_idx_notmember") (("2" (assert) (("2" (replaces "nwidxs" -1) (("2" (use "member_nats") (("1" (assert) nil nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "pow_var_compatible?") (("2" (flatten) (("2" (assert) (("2" (skeep) (("2" (inst?) (("2" (case "get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                       upd_noise_burst(N,
                                       nwidxs,
                                       LAMBDA
                                       (i: nat):
                                       (get_noise_by_idx
                                        (car(pd(varac))`1, N)
                                        ^
                                        (2 + i)))) = get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                       N)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))),
                            0)`1,
                        upd_noise_burst(N,
                                        nwidxs,
                                        LAMBDA
                                        (i: nat):
                                        (get_noise_by_idx
                                         (car(pd(varac))`1, N)
                                         ^
                                         (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))),
                            0)`1,
                        N)") (("1" (replaces -1) nil nil) ("2" (hide 2) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replace "nwidxs" -1) (("1" (expand "nth" -1 1) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (lemma "last_idx_box") (("1" (inst? -1 :where -2) (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (case "NOT null?(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))))") (("1" (assert) (("1" (lemma "olidx_car_last[nzBaseType]") (("1" (inst? -1 :where 1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (assert) (("1" (expand "car_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (hide "cache comp pairs on") (("1" (replace "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst? "cache idxs bound") (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (flatten) (("1" (replace -4 "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (replace -1 "cache idxs bound") (("2" (expand ">=") (("2" (hide-all-but (-6 1 "cache idxs bound")) (("2" (use "nth_ol[nat,<]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i_1") (("2" (hide-all-but (-1 1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "newoff") (("3" (expand ">=") (("3" (hide-all-but (1 "pow <= 1")) (("3" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (typepred "cache") (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replaces "acRes") (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nwidxs") (("1" (case "length(nwidxs)=0") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replaces "newoff") (("2" (assert) (("2" (expand ">=") (("2" (replaces "nwidxs") (("2" (typepred "nats(nextfreeidx, nextfreeidx - 2 + pow)") (("2" (inst -5 "pow-2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) (("2" (replaces "newoff") (("2" (hide-all-but (2 -2 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "correct_cache?") (("5" (expand "CacheData_correct?") (("5" (flatten) (("5" (typepred "nextfreeidx") (("5" (replaces "nwidxs" 2) (("5" (expand "nats" 2) (("5" (lift-if 2) (("5" (split 2) (("1" (assert) (("1" (flatten) (("1" (replaces -1 1 :dir RL) (("1" (use "last_idx_box") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (use "last_idx_box") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Env type-eq-decl nil affine_box nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (power_Epsilon_is_Epsilon formula-decl nil affine_pow nil) (member_nats formula-decl nil affine_pow nil) (gnbi_updb_2 formula-decl nil affine nil) (ac_proj_pd formula-decl nil affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (nth_ol formula-decl nil ordered_list structures) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (olidx_car_last formula-decl nil indexed_list structures) (idxs_ac const-decl "list[nat]" affine nil) (beyond_last_idx_notmember formula-decl nil affine nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (pow_var_compatible_noise formula-decl nil affine_pow nil) (last_idx_box formula-decl nil affine_box nil) (next_idx const-decl "nat" affine nil) (last_ol def-decl "T" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (SingInterval? const-decl "bool" affine nil) (last_idx const-decl "int" indexed_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (null_is_noise name-judgement "Noise" affine nil) (idxs_ac_var_ac formula-decl nil affine nil) (eval_updb_no_idxs formula-decl nil affine nil) (represents_var? const-decl "bool" affine nil) (containment_pow_var_ac formula-decl nil affine_pow nil) (nzBaseType type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (Interval type-eq-decl nil interval interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC59-1 nil 3631622080 ("" (skeep*) (("" (postpone) nil nil)) nil) nil nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC65 0 (RE2AC_TCC65-2 "" 3803769554 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -4) (label "cached some" -6) (label "cached" -5) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 6) (label "pow gt opn" 5) (label "opw gt opn" 4))) (("" (hide -13) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(:(re, acRes, nwidxs):)") (("1" (expand "append" 1) (("1" (grind) nil nil)) nil)) nil) ("2" (lift-if "nwidxs") (("2" (split nwidxs) (("1" (with-labels (name "opn" "opn(val(cached)`1)") (("opn name"))) (("1" (hide "opn name") (("1" (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (with-labels (typepred "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("1" (expand "compatible_pairs?") (("1" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("1" (inst 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+1+opn)))") (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (skolem 1 "k") (("1" (inst "N vars in box" "k") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1 2) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace "single intervals in box" 1 :dir RL :hide? t) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skolem 1 "k") (("2" (skeep) (("2" (split 1) (("1" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env" 1) (("1" (replaces "acRes") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("1" (skolem "cached cache idx" "i") (("1" (inst "cache comp pairs on" "i") (("1" (inst "cache comp pairs on" "n") (("1" (with-labels (flatten) (("cache eval" "cache if powvar" "UNKNOWN"))) (("1" (replace "cached cache idx") (("1" (expand "eval_ACExpr_Env" "cache eval") (("1" (assert) (("1" (use "cache_powvar_correct") (("1" (replace "cached cache idx") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("1" (replace "cached as AC" "cache eval") (("1" (replace "re") (("1" (assert) (("1" (replace "cached idx re") (("1" (replace "varac" 1) (("1" (lemma "containment_pow_var_ac") (("1" (expand "eval" 1) (("1" (expand "eval" 1) (("1" (inst? -1 :where 1) (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (inst "N vars in box" "idx") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (replace -17) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "nth_ac") (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1 2) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (lemma "eval_pd_noise_rec_pds_def") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth_ac") (("2" (replace "varac" :dir RL) (("2" (flatten) (("2" (replace "nwidxs" -1 :hide? t) (("2" (use "member_append_fi[nat]") (("2" (assert) (("2" (hide -2) (("2" (split -1) (("1" (split "cached cond ok") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (replace "pownoises") (("1" (hide-all-but (-1 -2 "varac" "varac not single value")) (("1" (replaces "varac") (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (expand "car_ol") (("1" (use "notmember_ol_nat") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (use "take_ol[nat,<]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (use "member_nats") (("2" (assert) (("2" (hide -2) (("2" (flatten) (("2" (typepred "nextfreeidx") (("2" (replace "varac") (("2" (use "last_idx_box") (("2" (expand "next_idx") (("2" (expand "last_idx") (("2" (hide-all-but (-1 -2 -3 "varac not single value")) (("2" (use "olidx_car_last[nzBaseType]") (("2" (split -1) (("1" (expand "car_ol") (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal "cache comp pairs on") (("3" (hide -1) (("3" (inst "cache comp pairs on" "i") (("3" (assert) (("3" (lemma "powvar_comp_noise_extension") (("3" (inst -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (assert) (("1" (replace "varac" -1) (("1" (replaces "cached cache idx" :dir RL) (("1" (replace "pownoises" -1) (("1" (replace "nwidxs" 1) (("1" (replace "pownoises" 1) (("1" (replace "re" (-1 1)) (("1" (replace "newoff" 1) (("1" (reveal "opn name") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace "pownoises" 1) (("2" (expand "idxs_bounded" "cache idxs bound") (("2" (inst "cache idxs bound" "i") (("2" (case "next_idx(pd(nth(cache, i)`2)) = nth(nth(cache, i)`3, opn(val(cached)`1)-2)+1") (("1" (replace -1 "cache idxs bound" :hide? t) (("1" (use "last_take_nth[nat,<]") (("1" (replace -1 1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (replace "cached cache idx") (("2" (replace "cached as AC" 1) (("2" (use "next_idx_pow_var_ac") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (replace "varac" "varac not single value") (("3" (assert) (("3" (expand "varidx_powvar") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "varidx_powvar") (("3" (replace "varac" "varac not single value") (("3" (replace "pownoises" 1) (("3" (replace "varac" 1) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "length" "varac not single value") (("4" (replace "varac") (("4" (split 1) (("1" (expand "nth_ac") (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 "varac not single value")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (replace "re" 1) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (reveal "varac") (("2" (replace "varac") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac" "varac not single value")) (("4" (expand "length") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache comp pairs on" "k-1") (("2" (inst "cache comp pairs on" "n") (("2" (with-labels (flatten "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (("2" (replace "cache eval" 2 :dir RL) (("2" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 3) (("1" (skeep) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (inst?) (("1" (expand "idxs_ac") (("1" (use "beyond_last_idx_notmember") (("1" (assert) (("1" (expand "next_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "k=0") (("1" (replaces -1) (("1" (flatten) (("1" (expand "nth" (-1 -2)) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached in cache"))) (("1" (skolem "cached in cache" "j") (("1" (inst "cache comp pairs on" "j") (("1" (inst "cache comp pairs on" "n") (("1" (with-labels (flatten "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("1" (assert) (("1" (lemma "powvar_comp_noise_extension") (("1" (inst -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (assert) (("1" (replace "varac" -1) (("1" (replaces "cached in cache" :dir RL) (("1" (replace "pownoises" -1) (("1" (replace "cached idx re" "cached N compatible") (("1" (replace "re" "cached N compatible") (("1" (replace "nwidxs" 1) (("1" (replace "pownoises" 1) (("1" (replace "re" (-1 1)) (("1" (replace "newoff" 1) (("1" (reveal "opn name") (("1" (assert) (("1" (expand "varidx_powvar") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "pownoises" 1) (("2" (expand "idxs_bounded" "cache idxs bound") (("2" (inst "cache idxs bound" "j") (("2" (case "next_idx(pd(nth(cache, j)`2)) = nth(nth(cache, j)`3, opn(val(cached)`1)-2)+1") (("1" (replace -1 "cache idxs bound" :hide? t) (("1" (use "last_take_nth[nat,<]") (("1" (replace -1 1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (replace "cached in cache") (("2" (assert) (("2" (flatten) (("2" (replace "varac") (("2" (replace "cached idx re") (("2" (replace "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached in cache") (("2" (use "cache_powvar_correct") (("2" (replace "cached in cache") (("2" (expand "CacheData_correct?") (("2" (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "cached as AC" 1) (("2" (use "next_idx_pow_var_ac") (("2" (replace "cached idx re" -1) (("2" (replace "re" -1) (("2" (replace "varac" "varac not single value") (("2" (assert) (("2" (replace "cached idx re" 1) (("2" (replace "re" 1) (("2" (expand "varidx_powvar") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "cache_powvar_correct") (("3" (replace "cached in cache") (("3" (expand "CacheData_correct?") (("3" (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (assert) (("3" (replace "varac" "varac not single value") (("3" (replace "cached idx re" -1) (("3" (replace "re" -1) (("3" (expand "varidx_powvar") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "cache_powvar_correct") (("3" (replace "cached in cache") (("3" (expand "CacheData_correct?") (("3" (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (assert) (("3" (replace "varac" "varac not single value") (("3" (replace "pownoises" 1) (("3" (replace "varac" 1) (("3" (replace "cached idx re" "cached cond ok") (("3" (replace "re" "cached cond ok") (("3" (expand "varidx_powvar") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "length" "varac not single value") (("4" (assert) nil nil)) nil) ("5" (replace "re" 1) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst "cache comp pairs on" "k-1") (("1" (inst "cache comp pairs on" "n") (("1" (expand "nth" 2) (("1" (assert) (("1" (flatten) (("1" (expand "nth" (-1 -2)) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (flatten) (("1" (skolem 2 "i") (("1" (assert) (("1" (inst "cache comp pairs on" "i") (("1" (case "get_noise_by_idx( nth(nth(cache, k - 1)`3, i)
                                                                                                                                                          	                              , upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i: nat): (get_noise_by_idx(car(pd(varac))`1, N)^(1 + i +opn)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                                                0)`1,
                                                                                                                                                                                                                                                                                            upd_noise_burst(N,
                                                                                                                                                                                                                                                                                                            nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                                                                            LAMBDA
                                                                                                                                                                                                                                                                                                            (i: nat):
                                                                                                                                                                                                                                                                                                            (get_noise_by_idx
                                                                                                                                                                                                                                                                                                             (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                                                             ^
                                                                                                                                                                                                                                                                                                             (1 + i +opn))))
                                                                                                                                                                                                                                                                            ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                                                0)`1,
                                                                                                                                                                                                                                                                                            N)
                                                                                                                                                                                                                                                                            ^ (2 + i)") (("1" (replaces -1) nil nil) ("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "nth_ac" -2) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (name-replace "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (("1" (use "last_idx_box") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (expand_ol) (("1" (expand "nth" -4 1) (("1" (assert) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-1 -7)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (typepred "cached") (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -1 "cache idxs bound" :hide? t) (("2" (typepred "i") (("2" (hide-all-but (-1 -5 "cache idxs bound")) (("2" (expand ">=") (("2" (case "i = opn(nth(cache, k - 1)`1) - 2") (("1" (replaces -1) (("1" (hide -1) (("1" (assert) nil nil)) nil)) nil) ("2" (case "i < opn(nth(cache, k - 1)`1) - 2") (("1" (hide -2) (("1" (lemma "nth_ol[nat,<]") (("1" (inst -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "i") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (assert) (("3" (use "power_Epsilon_is_Epsilon") (("3" (assert) (("3" (expand "length") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "opn >= 2")) (("4" (skeep) (("4" (reveal "opn name") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (hide-all-but (1 "varac not single value")) (("5" (expand "length") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "k") (("2" (hide-all-but (-1 1 2)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (flatten "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (("2" (with-labels (typepred "cache") (("correct cache" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (expand "compatible_pairs?") (("2" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (inst 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(2+i)))") (("1" (split 2) (("1" (expand "vars_in_box_compatible?") (("1" (skolem 1 "k") (("1" (inst "N vars in box" "k") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces "single intervals in box" 1 :dir RL) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skolem 1 "k") (("2" (skeep) (("2" (split 1) (("1" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env" 1) (("1" (replaces "acRes") (("1" (expand "eval") (("1" (lemma "containment_pow_var_ac") (("1" (expand "eval" 1) (("1" (replace "re" 1) (("1" (assert) (("1" (inst -1 "upd_noise_burst(N,
                                                                                                                                                                                                   nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                   LAMBDA
                                                                                                                                                                                                   (i: nat):
                                                                                                                                                                                                   (get_noise_by_idx(car(pd(varac))`1, N)
                                                                                                                                                                                                    ^
                                                                                                                                                                                                    (2+i)))" "vs(varidx(re1))" "varac" "pow" "nwidxs") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (inst "N vars in box" "idx") (("1" (replace "varac" 1) (("1" (expand "nth_ac" 1) (("1" (with-labels (flatten "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (("1" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 2) (("1" (skolem 1 "j") (("1" (flatten) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (reveal "varac") (("2" (replaces "varac") (("2" (expand "nth_ac") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "varac") (("3" (expand "length") (("3" (expand "nth_ac") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replaces "nwidxs" -1) (("2" (use "member_nats") (("2" (assert) (("2" (flatten) (("2" (replaces "varac") (("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "pow_var_compatible_noise") (("1" (assert) nil nil) ("2" (replaces "varac") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value" "varac")) (("2" (replaces "varac") (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value" "varac")) (("3" (replaces "varac") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache comp pairs on" "k-1") (("2" (inst "cache comp pairs on" "n") (("2" (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (replaces "eval cache" 2 :dir RL) (("2" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 3) (("1" (skolem 1 "i") (("1" (flatten) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (lemma "beyond_last_idx_notmember") (("1" (inst -1 "i" "pd(nth(cache, k - 1)`2)") (("1" (assert) (("1" (expand "idxs_ac") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value" "varac")) (("2" (replaces "varac") (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value" "varac")) (("3" (replaces "varac") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "re" 1) (("1" (assert) (("1" (use "pow_var_compatible_noise") (("1" (replaces "nwidxs") (("1" (replaces "varac") (("1" (expand "powvar?") (("1" (expand "varidx_powvar") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nth_ac") (("2" (replaces "varac") (("2" (hide-all-but (1 "varac not single value")) (("2" (expand "varidx_powvar") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (expand "varidx_powvar") (("2" (assert) (("2" (flatten) (("2" (inst "cache comp pairs on" "k-1") (("2" (inst "cache comp pairs on" "n") (("2" (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (assert) (("2" (expand "pow_var_compatible?") (("2" (flatten) (("2" (assert) (("2" (skolem 2 "j") (("2" (inst "cache if powvar" "j") (("2" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                  0)`1,
                                                                                                                                                                                                                                              upd_noise_burst(N,
                                                                                                                                                                                                                                                              nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                              LAMBDA
                                                                                                                                                                                                                                                              (i: nat):
                                                                                                                                                                                                                                                              (get_noise_by_idx
                                                                                                                                                                                                                                                               (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                               ^
                                                                                                                                                                                                                                                               (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                  0)`1,
                                                                                                                                                                                                                                              N)") (("1" (case "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                                                    upd_noise_burst(N,
                                                                                                                                                                                                                                                                                    nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                                                    LAMBDA
                                                                                                                                                                                                                                                                                    (i: nat):
                                                                                                                                                                                                                                                                                    (get_noise_by_idx
                                                                                                                                                                                                                                                                                     (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                                     ^
                                                                                                                                                                                                                                                                                     (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                                                    N)") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst?) (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -1 "cache idxs bound" :hide? t) (("2" (typepred "j") (("2" (hide-all-but (-1 -5 "cache idxs bound")) (("2" (expand ">=") (("2" (case "j = opn(nth(cache, k - 1)`1) - 2 ") (("1" (hide -2) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil) ("2" (case "j < opn(nth(cache, k - 1)`1) - 2") (("1" (hide (-2 1)) (("1" (lemma "nth_ol[nat,<]") (("1" (inst -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "j") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "nth_ac" -2) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (name-replace "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (("1" (use "last_idx_box") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (expand_ol) (("1" (expand "nth" -4 1) (("1" (assert) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "last_idx_in_box") (("2" (assert) (("2" (expand "somevidx") (("2" (expand "varidx_powvar") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (use "power_Epsilon_is_Epsilon") (("3" (assert) (("3" (expand "length") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil) ("5" (expand "varidx_powvar") (("5" (assert) nil nil)) nil) ("6" (expand "varidx_powvar") (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "newoff" 1) (("3" (expand ">=") (("3" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (1 -1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("4" (replace "newoff" 1) (("4" (expand "idxs_bounded" 1) (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "acRes" 1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (replace "nwidxs" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (case "pow - 1 = opn(val(cached)`1)") (("1" (replace -1 1 :dir RL) (("1" (assert) (("1" (case "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                                                                                                                      nats(nextfreeidx, newoff - 1)),
                                                                                                                                                                                                                                               pow - 2) = nextfreeidx") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "nth(append(take[nat](pownoises, pow - 2), nats(nextfreeidx, newoff - 1)), pow - 2) =
                                                                              nth(nats(nextfreeidx, newoff - 1), pow - 2 - length(take[nat](pownoises, pow - 2)))") (("1" (replaces -1 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "length(pownoises) = pow - 2") (("1" (replaces -1 2) (("1" (grind) nil nil)) nil) ("2" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "more_list_props[nat].nth_append") (("2" (split -1) (("1" (replaces -1 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (use "length_take[nat]") (("1" (replace -1 -2) (("1" (expand "min") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (use "length_take[nat]") (("2" (replace -1 1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (replace "pownoises" 1) (("2" (hide -1 -2) (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (skolem "cached cache idx" "j") (("2" (replace "cached cache idx" :dir RL) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) (("2" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "cached idx re" "cached cond ok") (("2" (replace "re" "cached cond ok") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (split 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (grind) nil nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (use "length_take[nat]") (("2" (replace -1 1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (replace "pownoises" 1) (("2" (hide -1 -2) (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (skolem "cached cache idx" "j") (("2" (replace "cached cache idx" :dir RL) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) (("2" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "cached idx re" "cached cond ok") (("2" (replace "re" "cached cond ok") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "nth(append(take[nat](pownoises, opn(val(cached)`1) - 1), nats(nextfreeidx, newoff - 1)), pow - 2)
                                                                      =
                                                                      nth(nats(nextfreeidx, newoff - 1),
                                                                          pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1)))") (("1" (replaces -1 2) (("1" (case "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                                      pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (case "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 1) (("1" (replaces "newoff" 1) (("1" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (inst? -5) (("1" (replace -5 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "more_list_props[nat].nth_append") (("1" (split -1) (("1" (replaces -1 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (use "length_take[nat]") (("1" (replace -1 -2) (("1" (expand "min") (("1" (lift-if -2) (("1" (split -2) (("1" (assert) nil nil) ("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (skolem "cached cache idx" "j") (("2" (replace "cached cache idx" :dir RL) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) (("2" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "varac") (("2" (replace "cached idx re" "cached cond ok") (("2" (replace "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (split 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_append[nat]") (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (skolem "cached cache idx" "j") (("2" (replace "cached cache idx" :dir RL) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) (("2" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "varac") (("2" (replace "cached idx re" "cached cond ok") (("2" (replace "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "newoff" 2) (("2" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (inst? -5) (("2" (replaces -5 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache idxs bounded" "i-1") (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 2 "cache idxs bounded")) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC65-1 "" 3789917913 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (hide -13) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(:(re, acRes, nwidxs):)") (("1" (expand "append" 1) (("1" (grind) nil nil)) nil)) nil) ("2" (lift-if "nwidxs") (("2" (split nwidxs) (("1" (with-labels (name "opn" "opn(val(cached)`1)") (("opn name"))) (("1" (hide "opn name") (("1" (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (with-labels (typepred "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("1" (expand "compatible_pairs?") (("1" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("1" (inst 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+1+opn)))") (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (skolem 1 "k") (("1" (inst "N vars in box" "k") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1 2) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace "single intervals in box" 1 :dir RL :hide? t) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skolem 1 "k") (("2" (skeep) (("2" (split 1) (("1" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env" 1) (("1" (replaces "acRes") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("1" (skolem "cached cache idx" "i") (("1" (inst "cache comp pairs on" "i") (("1" (inst "cache comp pairs on" "n") (("1" (with-labels (flatten) (("cache eval" "cache if powvar" "UNKNOWN"))) (("1" (replace "cached cache idx") (("1" (expand "eval_ACExpr_Env" "cache eval") (("1" (assert) (("1" (use "cache_powvar_correct") (("1" (replace "cached cache idx") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("1" (replace "cached as AC" "cache eval") (("1" (replace "re") (("1" (assert) (("1" (replace "cached idx re") (("1" (replace "varac" 1) (("1" (lemma "containment_pow_var_ac") (("1" (expand "eval" 1) (("1" (expand "eval" 1) (("1" (inst? -1 :where 1) (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (inst "N vars in box" "idx") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (replace -17) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "nth_ac") (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1 2) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (lemma "eval_pd_noise_rec_pds_def") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth_ac") (("2" (replace "varac" :dir RL) (("2" (flatten) (("2" (replace "nwidxs" -1 :hide? t) (("2" (use "member_append_fi[nat]") (("2" (assert) (("2" (hide -2) (("2" (split -1) (("1" (split "cached cond ok") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (replace "pownoises") (("1" (hide-all-but (-1 -2 "varac" "varac not single value")) (("1" (replaces "varac") (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (expand "car_ol") (("1" (use "notmember_ol_nat") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (use "take_ol[nat,<]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (use "member_nats") (("2" (assert) (("2" (hide -2) (("2" (flatten) (("2" (typepred "nextfreeidx") (("2" (replace "varac") (("2" (use "last_idx_box") (("2" (expand "next_idx") (("2" (expand "last_idx") (("2" (hide-all-but (-1 -2 -3 "varac not single value")) (("2" (use "olidx_car_last[nzBaseType]") (("2" (split -1) (("1" (expand "car_ol") (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal "cache comp pairs on") (("3" (hide -1) (("3" (inst "cache comp pairs on" "i") (("3" (assert) (("3" (lemma "powvar_comp_noise_extension") (("3" (inst -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (assert) (("1" (replace "varac" -1) (("1" (replaces "cached cache idx" :dir RL) (("1" (replace "pownoises" -1) (("1" (replace "nwidxs" 1) (("1" (replace "pownoises" 1) (("1" (replace "re" (-1 1)) (("1" (replace "newoff" 1) (("1" (reveal "opn name") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace "pownoises" 1) (("2" (expand "idxs_bounded" "cache idxs bound") (("2" (inst "cache idxs bound" "i") (("2" (case "next_idx(pd(nth(cache, i)`2)) = nth(nth(cache, i)`3, opn(val(cached)`1)-2)+1") (("1" (replace -1 "cache idxs bound" :hide? t) (("1" (use "last_take_nth[nat,<]") (("1" (replace -1 1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (replace "cached cache idx") (("2" (replace "cached as AC" 1) (("2" (use "next_idx_pow_var_ac") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (replace "varac" "varac not single value") (("3" (assert) (("3" (expand "varidx_powvar") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "varidx_powvar") (("3" (replace "varac" "varac not single value") (("3" (replace "pownoises" 1) (("3" (replace "varac" 1) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "length" "varac not single value") (("4" (replace "varac") (("4" (split 1) (("1" (expand "nth_ac") (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 "varac not single value")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (replace "re" 1) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (reveal "varac") (("2" (replace "varac") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac" "varac not single value")) (("4" (expand "length") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache comp pairs on" "k-1") (("2" (inst "cache comp pairs on" "n") (("2" (with-labels (flatten "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (("2" (replace "cache eval" 2 :dir RL) (("2" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 3) (("1" (skeep) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (inst?) (("1" (expand "idxs_ac") (("1" (use "beyond_last_idx_notmember") (("1" (assert) (("1" (expand "next_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "k=0") (("1" (replaces -1) (("1" (flatten) (("1" (expand "nth" (-1 -2)) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached in cache"))) (("1" (skolem "cached in cache" "j") (("1" (inst "cache comp pairs on" "j") (("1" (inst "cache comp pairs on" "n") (("1" (with-labels (flatten "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("1" (assert) (("1" (lemma "powvar_comp_noise_extension") (("1" (inst -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (assert) (("1" (replace "varac" -1) (("1" (replaces "cached in cache" :dir RL) (("1" (replace "pownoises" -1) (("1" (replace "cached idx re" "cached N compatible") (("1" (replace "re" "cached N compatible") (("1" (replace "nwidxs" 1) (("1" (replace "pownoises" 1) (("1" (replace "re" (-1 1)) (("1" (replace "newoff" 1) (("1" (reveal "opn name") (("1" (assert) (("1" (expand "varidx_powvar") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "pownoises" 1) (("2" (expand "idxs_bounded" "cache idxs bound") (("2" (inst "cache idxs bound" "j") (("2" (case "next_idx(pd(nth(cache, j)`2)) = nth(nth(cache, j)`3, opn(val(cached)`1)-2)+1") (("1" (replace -1 "cache idxs bound" :hide? t) (("1" (use "last_take_nth[nat,<]") (("1" (replace -1 1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (replace "cached in cache") (("2" (assert) (("2" (flatten) (("2" (replace "varac") (("2" (replace "cached idx re") (("2" (replace "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached in cache") (("2" (use "cache_powvar_correct") (("2" (replace "cached in cache") (("2" (expand "CacheData_correct?") (("2" (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "cached as AC" 1) (("2" (use "next_idx_pow_var_ac") (("2" (replace "cached idx re" -1) (("2" (replace "re" -1) (("2" (replace "varac" "varac not single value") (("2" (assert) (("2" (replace "cached idx re" 1) (("2" (replace "re" 1) (("2" (expand "varidx_powvar") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "cache_powvar_correct") (("3" (replace "cached in cache") (("3" (expand "CacheData_correct?") (("3" (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (assert) (("3" (replace "varac" "varac not single value") (("3" (replace "cached idx re" -1) (("3" (replace "re" -1) (("3" (expand "varidx_powvar") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "cache_powvar_correct") (("3" (replace "cached in cache") (("3" (expand "CacheData_correct?") (("3" (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (assert) (("3" (replace "varac" "varac not single value") (("3" (replace "pownoises" 1) (("3" (replace "varac" 1) (("3" (replace "cached idx re" "cached cond ok") (("3" (replace "re" "cached cond ok") (("3" (expand "varidx_powvar") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "length" "varac not single value") (("4" (assert) nil nil)) nil) ("5" (replace "re" 1) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst "cache comp pairs on" "k-1") (("1" (inst "cache comp pairs on" "n") (("1" (expand "nth" 2) (("1" (assert) (("1" (flatten) (("1" (expand "nth" (-1 -2)) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (flatten) (("1" (skolem 2 "i") (("1" (assert) (("1" (inst "cache comp pairs on" "i") (("1" (case "get_noise_by_idx( nth(nth(cache, k - 1)`3, i)
                                                                                                                                     	                              , upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i: nat): (get_noise_by_idx(car(pd(varac))`1, N)^(1 + i +opn)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                         0)`1,
                                                                                                                                                                                                                                                                     upd_noise_burst(N,
                                                                                                                                                                                                                                                                                     nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                                                     LAMBDA
                                                                                                                                                                                                                                                                                     (i: nat):
                                                                                                                                                                                                                                                                                     (get_noise_by_idx
                                                                                                                                                                                                                                                                                      (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                                      ^
                                                                                                                                                                                                                                                                                      (1 + i +opn))))
                                                                                                                                                                                                                                                     ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                         0)`1,
                                                                                                                                                                                                                                                                     N)
                                                                                                                                                                                                                                                     ^ (2 + i)") (("1" (replaces -1) nil nil) ("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "nth_ac" -2) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (name-replace "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (("1" (use "last_idx_box") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (expand_ol) (("1" (expand "nth" -4 1) (("1" (assert) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-1 -7)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (typepred "cached") (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -1 "cache idxs bound" :hide? t) (("2" (typepred "i") (("2" (hide-all-but (-1 -5 "cache idxs bound")) (("2" (expand ">=") (("2" (case "i = opn(nth(cache, k - 1)`1) - 2") (("1" (replaces -1) (("1" (hide -1) (("1" (assert) nil nil)) nil)) nil) ("2" (case "i < opn(nth(cache, k - 1)`1) - 2") (("1" (hide -2) (("1" (lemma "nth_ol[nat,<]") (("1" (inst -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "i") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (assert) (("3" (use "power_Epsilon_is_Epsilon") (("3" (assert) (("3" (expand "length") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "opn >= 2")) (("4" (skeep) (("4" (reveal "opn name") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (hide-all-but (1 "varac not single value")) (("5" (expand "length") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "k") (("2" (hide-all-but (-1 1 2)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (flatten "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (("2" (with-labels (typepred "cache") (("correct cache" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (expand "compatible_pairs?") (("2" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (inst 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(2+i)))") (("1" (split 2) (("1" (expand "vars_in_box_compatible?") (("1" (skolem 1 "k") (("1" (inst "N vars in box" "k") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces "single intervals in box" 1 :dir RL) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skolem 1 "k") (("2" (skeep) (("2" (split 1) (("1" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env" 1) (("1" (replaces "acRes") (("1" (expand "eval") (("1" (lemma "containment_pow_var_ac") (("1" (expand "eval" 1) (("1" (replace "re" 1) (("1" (assert) (("1" (inst -1 "upd_noise_burst(N,
                                                                                                                                                                                     nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                     LAMBDA
                                                                                                                                                                                     (i: nat):
                                                                                                                                                                                     (get_noise_by_idx(car(pd(varac))`1, N)
                                                                                                                                                                                      ^
                                                                                                                                                                                      (2+i)))" "vs(varidx(re1))" "varac" "pow" "nwidxs") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (inst "N vars in box" "idx") (("1" (replace "varac" 1) (("1" (expand "nth_ac" 1) (("1" (with-labels (flatten "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (("1" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 2) (("1" (skolem 1 "j") (("1" (flatten) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (reveal "varac") (("2" (replaces "varac") (("2" (expand "nth_ac") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "varac") (("3" (expand "length") (("3" (expand "nth_ac") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replaces "nwidxs" -1) (("2" (use "member_nats") (("2" (assert) (("2" (flatten) (("2" (replaces "varac") (("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "pow_var_compatible_noise") (("1" (assert) nil nil) ("2" (replaces "varac") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value" "varac")) (("2" (replaces "varac") (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value" "varac")) (("3" (replaces "varac") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache comp pairs on" "k-1") (("2" (inst "cache comp pairs on" "n") (("2" (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (replaces "eval cache" 2 :dir RL) (("2" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 3) (("1" (skolem 1 "i") (("1" (flatten) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (lemma "beyond_last_idx_notmember") (("1" (inst -1 "i" "pd(nth(cache, k - 1)`2)") (("1" (assert) (("1" (expand "idxs_ac") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value" "varac")) (("2" (replaces "varac") (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value" "varac")) (("3" (replaces "varac") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "re" 1) (("1" (assert) (("1" (use "pow_var_compatible_noise") (("1" (replaces "nwidxs") (("1" (replaces "varac") (("1" (expand "powvar?") (("1" (expand "varidx_powvar") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nth_ac") (("2" (replaces "varac") (("2" (hide-all-but (1 "varac not single value")) (("2" (expand "varidx_powvar") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (expand "varidx_powvar") (("2" (assert) (("2" (flatten) (("2" (inst "cache comp pairs on" "k-1") (("2" (inst "cache comp pairs on" "n") (("2" (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (assert) (("2" (expand "pow_var_compatible?") (("2" (flatten) (("2" (assert) (("2" (skolem 2 "j") (("2" (inst "cache if powvar" "j") (("2" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                               0)`1,
                                                                                                                                                                                                                           upd_noise_burst(N,
                                                                                                                                                                                                                                           nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                           LAMBDA
                                                                                                                                                                                                                                           (i: nat):
                                                                                                                                                                                                                                           (get_noise_by_idx
                                                                                                                                                                                                                                            (car(pd(varac))`1, N)
                                                                                                                                                                                                                                            ^
                                                                                                                                                                                                                                            (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                               0)`1,
                                                                                                                                                                                                                           N)") (("1" (case "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                               upd_noise_burst(N,
                                                                                                                                                                                                                                                               nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                               LAMBDA
                                                                                                                                                                                                                                                               (i: nat):
                                                                                                                                                                                                                                                               (get_noise_by_idx
                                                                                                                                                                                                                                                                (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                ^
                                                                                                                                                                                                                                                                (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                               N)") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst?) (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -1 "cache idxs bound" :hide? t) (("2" (typepred "j") (("2" (hide-all-but (-1 -5 "cache idxs bound")) (("2" (expand ">=") (("2" (case "j = opn(nth(cache, k - 1)`1) - 2 ") (("1" (hide -2) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil) ("2" (case "j < opn(nth(cache, k - 1)`1) - 2") (("1" (hide (-2 1)) (("1" (lemma "nth_ol[nat,<]") (("1" (inst -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "j") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "nth_ac" -2) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (name-replace "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (("1" (use "last_idx_box") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (expand_ol) (("1" (expand "nth" -4 1) (("1" (assert) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "last_idx_in_box") (("2" (assert) (("2" (expand "somevidx") (("2" (expand "varidx_powvar") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (use "power_Epsilon_is_Epsilon") (("3" (assert) (("3" (expand "length") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil) ("5" (expand "varidx_powvar") (("5" (assert) nil nil)) nil) ("6" (expand "varidx_powvar") (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "newoff" 1) (("3" (expand ">=") (("3" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (1 -1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("4" (replace "newoff" 1) (("4" (expand "idxs_bounded" 1) (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "acRes" 1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (replace "nwidxs" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (case "pow - 1 = opn(val(cached)`1)") (("1" (replace -1 1 :dir RL) (("1" (assert) (("1" (case "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                                                                                                   nats(nextfreeidx, newoff - 1)),
                                                                                                                                                                                                                            pow - 2) = nextfreeidx") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "nth(append(take[nat](pownoises, pow - 2), nats(nextfreeidx, newoff - 1)), pow - 2) =
                                                         nth(nats(nextfreeidx, newoff - 1), pow - 2 - length(take[nat](pownoises, pow - 2)))") (("1" (replaces -1 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "length(pownoises) = pow - 2") (("1" (replaces -1 2) (("1" (grind) nil nil)) nil) ("2" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "more_list_props[nat].nth_append") (("2" (split -1) (("1" (replaces -1 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (use "length_take[nat]") (("1" (replace -1 -2) (("1" (expand "min") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (use "length_take[nat]") (("2" (replace -1 1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (replace "pownoises" 1) (("2" (hide -1 -2) (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (skolem "cached cache idx" "j") (("2" (replace "cached cache idx" :dir RL) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) (("2" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "cached idx re" "cached cond ok") (("2" (replace "re" "cached cond ok") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (split 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (grind) nil nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (use "length_take[nat]") (("2" (replace -1 1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (replace "pownoises" 1) (("2" (hide -1 -2) (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (skolem "cached cache idx" "j") (("2" (replace "cached cache idx" :dir RL) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) (("2" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "cached idx re" "cached cond ok") (("2" (replace "re" "cached cond ok") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "nth(append(take[nat](pownoises, opn(val(cached)`1) - 1), nats(nextfreeidx, newoff - 1)), pow - 2)
                                                   =
                                                   nth(nats(nextfreeidx, newoff - 1),
                                                       pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1)))") (("1" (replaces -1 2) (("1" (case "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                 pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (case "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 1) (("1" (replaces "newoff" 1) (("1" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (inst? -5) (("1" (replace -5 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "more_list_props[nat].nth_append") (("1" (split -1) (("1" (replaces -1 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (use "length_take[nat]") (("1" (replace -1 -2) (("1" (expand "min") (("1" (lift-if -2) (("1" (split -2) (("1" (assert) nil nil) ("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (skolem "cached cache idx" "j") (("2" (replace "cached cache idx" :dir RL) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) (("2" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "varac") (("2" (replace "cached idx re" "cached cond ok") (("2" (replace "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (split 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_append[nat]") (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (skolem "cached cache idx" "j") (("2" (replace "cached cache idx" :dir RL) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) (("2" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "varac") (("2" (replace "cached idx re" "cached cond ok") (("2" (replace "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "newoff" 2) (("2" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (inst? -5) (("2" (replaces -5 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache idxs bounded" "i-1") (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 2 "cache idxs bounded")) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (int_plus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial reals) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (nth_append formula-decl nil more_list_props structures) (length_append formula-decl nil list_props nil) (cache_powvar_correct_result formula-decl nil affine_expr_Eval_fnd nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (length_take formula-decl nil more_list_props structures) (N skolem-const-decl "Noise" affine_expr_Eval_fnd nil) (pow skolem-const-decl "nat" affine_expr_Eval_fnd nil) (k skolem-const-decl "below(length(cons((re, acRes, nwidxs), cache)))" affine_expr_Eval_fnd nil) (j skolem-const-decl "below(opn(nth(cache, k - 1)`1) - 1)" affine_expr_Eval_fnd nil) (somevidx skolem-const-decl "nat" affine_expr_Eval_fnd nil) (pow_var_compatible_noise formula-decl nil affine_pow nil) (k skolem-const-decl "below(length(box))" affine_expr_Eval_fnd nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (length def-decl "nat" list_props nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (= const-decl "[T, T -> boolean]" equalities nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (newoff skolem-const-decl "int" affine_expr_Eval_fnd nil) (/= const-decl "boolean" notequal nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (nzBaseType type-eq-decl nil affine nil) (varac skolem-const-decl "AffineCombination" affine_expr_Eval_fnd nil) (N skolem-const-decl "Noise" affine_expr_Eval_fnd nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (opn skolem-const-decl "nat" affine_expr_Eval_fnd nil) (^ const-decl "real" exponentiation nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (upd_noise_burst const-decl "Noise" affine nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (acRes skolem-const-decl "AffineCombination" affine_expr_Eval_fnd nil) (nwidxs skolem-const-decl "list[nat]" affine_expr_Eval_fnd nil) (k skolem-const-decl "below(length(cons((re, acRes, nwidxs), cache)))" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(opn(nth(cache, k - 1)`1) - 1)" affine_expr_Eval_fnd nil) (nth_ol formula-decl nil ordered_list structures) (containment_pow_var_ac formula-decl nil affine_pow nil) (SingInterval? const-decl "bool" affine nil) (expt def-decl "real" exponentiation nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (last_idx const-decl "int" indexed_list structures) (take def-decl "list[T]" more_list_props structures) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (re1 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (idxs_ac const-decl "list[nat]" affine nil) (idxs_pd def-decl "list[nat]" affine nil) (notmember_ol_nat formula-decl nil affine_pow nil) (cached skolem-const-decl "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (re skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (last_ol def-decl "T" ordered_list structures) (member def-decl "bool" list_props nil) (take_ol formula-decl nil ordered_list structures) (olidx_car_last formula-decl nil indexed_list structures) (last_idx_box formula-decl nil affine_box nil) (member_append_fi formula-decl nil more_list_props structures) (pownoises skolem-const-decl "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]" affine_expr_Eval_fnd nil) (above nonempty-type-eq-decl nil integers nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (last_take_nth formula-decl nil ordered_list structures) (powvar_comp_noise_extension formula-decl nil affine_pow nil) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (represents_var? const-decl "bool" affine nil) (next_idx const-decl "nat" affine nil) (idx skolem-const-decl "nat" affine_expr_Eval_fnd nil) (nth_ac const-decl "AffineCombination" affine_box nil) (eval def-decl "real" interval_expr interval_arith) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (cache_powvar_correct formula-decl nil affine_expr_Eval_fnd nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (beyond_last_idx_notmember formula-decl nil affine nil) (eval_updb_no_idxs formula-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (real_minus_real_is_real application-judgement "real" reals nil) (var_ac const-decl "AffineCombination" affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (eval_ac_noise const-decl "real" affine nil) (ac_proj_pd formula-decl nil affine nil) (gnbi_updb_2 formula-decl nil affine nil) (member_nats formula-decl nil affine_pow nil) (power_Epsilon_is_Epsilon formula-decl nil affine_pow nil) (null adt-constructor-decl "(null?)" list_adt nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (k skolem-const-decl "below(length(box))" affine_expr_Eval_fnd nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) ({\|\|} const-decl "AffineCombination" affine nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (lt_idx_strict_order formula-decl nil indexed_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (append def-decl "list[T]" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC60-4 nil 3767019773 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (hide -13) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(:(re, acRes, nwidxs):)") (("1" (expand "append" 1) (("1" (grind) nil nil)) nil)) nil) ("2" (lift-if "nwidxs") (("2" (split nwidxs) (("1" (with-labels (name "opn" "opn(val(cached)`1)") (("opn name"))) (("1" (hide "opn name") (("1" (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (with-labels (typepred "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("1" (expand "compatible_pairs?") (("1" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("1" (inst 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+1+opn)))") (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (skolem 1 "k") (("1" (inst "N vars in box" "k") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1 2) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace "single intervals in box" 1 :dir RL :hide? t) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skolem 1 "k") (("2" (skeep) (("2" (split 1) (("1" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env" 1) (("1" (replaces "acRes") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("1" (skolem "cached cache idx" "i") (("1" (inst "cache comp pairs on" "i") (("1" (inst "cache comp pairs on" "n") (("1" (with-labels (flatten) (("cache eval" "cache if powvar" "UNKNOWN"))) (("1" (replace "cached cache idx") (("1" (expand "eval_ACExpr_Env" "cache eval") (("1" (assert) (("1" (use "cache_powvar_correct") (("1" (replace "cached cache idx") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("1" (replace "cached as AC" "cache eval") (("1" (replace "re") (("1" (assert) (("1" (replace "cached idx re") (("1" (replace "varac" 1) (("1" (lemma "containment_pow_var_ac") (("1" (expand "eval" 1) (("1" (expand "eval" 1) (("1" (inst? -1 :where 1) (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (inst "N vars in box" "idx") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (replace -17) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "nth_ac") (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1 2) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (lemma "eval_pd_noise_rec_pds_def") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth_ac") (("2" (replace "varac" :dir RL) (("2" (flatten) (("2" (replace "nwidxs" -1 :hide? t) (("2" (use "member_append_fi[nat]") (("2" (assert) (("2" (hide -2) (("2" (split -1) (("1" (split "cached cond ok") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (replace "pownoises") (("1" (hide-all-but (-1 -2 "varac" "varac not single value")) (("1" (replaces "varac") (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (expand "car_ol") (("1" (use "notmember_ol_nat") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (use "take_ol[nat,<]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (use "member_nats") (("2" (assert) (("2" (hide -2) (("2" (flatten) (("2" (typepred "nextfreeidx") (("2" (replace "varac") (("2" (use "last_idx_box") (("2" (expand "next_idx") (("2" (expand "last_idx") (("2" (hide-all-but (-1 -2 -3 "varac not single value")) (("2" (use "olidx_car_last[nzBaseType]") (("2" (split -1) (("1" (expand "car_ol") (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal "cache comp pairs on") (("3" (hide -1) (("3" (inst "cache comp pairs on" "i") (("3" (assert) (("3" (lemma "powvar_comp_noise_extension") (("3" (inst -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (assert) (("1" (replace "varac" -1) (("1" (replaces "cached cache idx" :dir RL) (("1" (replace "pownoises" -1) (("1" (replace "nwidxs" 1) (("1" (replace "pownoises" 1) (("1" (replace "re" (-1 1)) (("1" (replace "newoff" 1) (("1" (reveal "opn name") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace "pownoises" 1) (("2" (expand "idxs_bounded" "cache idxs bound") (("2" (inst "cache idxs bound" "i") (("2" (case "next_idx(pd(nth(cache, i)`2)) = nth(nth(cache, i)`3, opn(val(cached)`1)-2)+1") (("1" (replace -1 "cache idxs bound" :hide? t) (("1" (use "last_take_nth[nat,<]") (("1" (replace -1 1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (replace "cached cache idx") (("2" (replace "cached as AC" 1) (("2" (use "next_idx_pow_var_ac") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (replace "varac" "varac not single value") (("3" (assert) (("3" (expand "varidx_powvar") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "varidx_powvar") (("3" (replace "varac" "varac not single value") (("3" (replace "pownoises" 1) (("3" (replace "varac" 1) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "length" "varac not single value") (("4" (replace "varac") (("4" (split 1) (("1" (expand "nth_ac") (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 "varac not single value")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (replace "re" 1) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (reveal "varac") (("2" (replace "varac") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac" "varac not single value")) (("4" (expand "length") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache comp pairs on" "k-1") (("2" (inst "cache comp pairs on" "n") (("2" (with-labels (flatten "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (("2" (replace "cache eval" 2 :dir RL) (("2" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 3) (("1" (skeep) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (inst?) (("1" (expand "idxs_ac") (("1" (use "beyond_last_idx_notmember") (("1" (assert) (("1" (expand "next_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "k=0") (("1" (replaces -1) (("1" (flatten) (("1" (expand "nth" (-1 -2)) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached in cache"))) (("1" (skolem "cached in cache" "j") (("1" (inst "cache comp pairs on" "j") (("1" (inst "cache comp pairs on" "n") (("1" (with-labels (flatten "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("1" (assert) (("1" (lemma "powvar_comp_noise_extension") (("1" (inst -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (assert) (("1" (replace "varac" -1) (("1" (replaces "cached in cache" :dir RL) (("1" (replace "pownoises" -1) (("1" (replace "cached idx re" "cached N compatible") (("1" (replace "re" "cached N compatible") (("1" (replace "nwidxs" 1) (("1" (replace "pownoises" 1) (("1" (replace "re" (-1 1)) (("1" (replace "newoff" 1) (("1" (reveal "opn name") (("1" (assert) (("1" (expand "varidx_powvar") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "pownoises" 1) (("2" (expand "idxs_bounded" "cache idxs bound") (("2" (inst "cache idxs bound" "j") (("2" (case "next_idx(pd(nth(cache, j)`2)) = nth(nth(cache, j)`3, opn(val(cached)`1)-2)+1") (("1" (replace -1 "cache idxs bound" :hide? t) (("1" (use "last_take_nth[nat,<]") (("1" (replace -1 1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (replace "cached in cache") (("2" (assert) (("2" (flatten) (("2" (replace "varac") (("2" (replace "cached idx re") (("2" (replace "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached in cache") (("2" (use "cache_powvar_correct") (("2" (replace "cached in cache") (("2" (expand "CacheData_correct?") (("2" (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "cached as AC" 1) (("2" (use "next_idx_pow_var_ac") (("2" (replace "cached idx re" -1) (("2" (replace "re" -1) (("2" (replace "varac" "varac not single value") (("2" (assert) (("2" (replace "cached idx re" 1) (("2" (replace "re" 1) (("2" (expand "varidx_powvar") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "cache_powvar_correct") (("3" (replace "cached in cache") (("3" (expand "CacheData_correct?") (("3" (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (assert) (("3" (replace "varac" "varac not single value") (("3" (replace "cached idx re" -1) (("3" (replace "re" -1) (("3" (expand "varidx_powvar") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "cache_powvar_correct") (("3" (replace "cached in cache") (("3" (expand "CacheData_correct?") (("3" (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (assert) (("3" (replace "varac" "varac not single value") (("3" (replace "pownoises" 1) (("3" (replace "varac" 1) (("3" (replace "cached idx re" "cached cond ok") (("3" (replace "re" "cached cond ok") (("3" (expand "varidx_powvar") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "length" "varac not single value") (("4" (assert) nil nil)) nil) ("5" (replace "re" 1) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst "cache comp pairs on" "k-1") (("1" (inst "cache comp pairs on" "n") (("1" (expand "nth" 2) (("1" (assert) (("1" (flatten) (("1" (expand "nth" (-1 -2)) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (flatten) (("1" (skolem 2 "i") (("1" (assert) (("1" (inst "cache comp pairs on" "i") (("1" (case "get_noise_by_idx( nth(nth(cache, k - 1)`3, i)
                                                                                                                                     	                              , upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i: nat): (get_noise_by_idx(car(pd(varac))`1, N)^(1 + i +opn)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                         0)`1,
                                                                                                                                                                                                                                                                     upd_noise_burst(N,
                                                                                                                                                                                                                                                                                     nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                                                     LAMBDA
                                                                                                                                                                                                                                                                                     (i: nat):
                                                                                                                                                                                                                                                                                     (get_noise_by_idx
                                                                                                                                                                                                                                                                                      (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                                      ^
                                                                                                                                                                                                                                                                                      (1 + i +opn))))
                                                                                                                                                                                                                                                     ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                         0)`1,
                                                                                                                                                                                                                                                                     N)
                                                                                                                                                                                                                                                     ^ (2 + i)") (("1" (replaces -1) nil nil) ("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "nth_ac" -2) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (name-replace "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (("1" (use "last_idx_box") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (expand_ol) (("1" (expand "nth" -4 1) (("1" (assert) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-1 -7)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (typepred "cached") (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -1 "cache idxs bound" :hide? t) (("2" (typepred "i") (("2" (hide-all-but (-1 -5 "cache idxs bound")) (("2" (expand ">=") (("2" (case "i = opn(nth(cache, k - 1)`1) - 2") (("1" (replaces -1) (("1" (hide -1) (("1" (assert) nil nil)) nil)) nil) ("2" (case "i < opn(nth(cache, k - 1)`1) - 2") (("1" (hide -2) (("1" (lemma "nth_ol[nat,<]") (("1" (inst -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "i") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (assert) (("3" (use "power_Epsilon_is_Epsilon") (("3" (assert) (("3" (expand "length") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "opn >= 2")) (("4" (skeep) (("4" (reveal "opn name") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (hide-all-but (1 "varac not single value")) (("5" (expand "length") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "k") (("2" (hide-all-but (-1 1 2)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (flatten "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (("2" (with-labels (typepred "cache") (("correct cache" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (expand "compatible_pairs?") (("2" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (inst 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(2+i)))") (("1" (split 2) (("1" (expand "vars_in_box_compatible?") (("1" (skolem 1 "k") (("1" (inst "N vars in box" "k") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces "single intervals in box" 1 :dir RL) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skolem 1 "k") (("2" (skeep) (("2" (split 1) (("1" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env" 1) (("1" (replaces "acRes") (("1" (expand "eval") (("1" (lemma "containment_pow_var_ac") (("1" (expand "eval" 1) (("1" (replace "re" 1) (("1" (assert) (("1" (inst -1 "upd_noise_burst(N,
                                                                                                                                                                                     nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                     LAMBDA
                                                                                                                                                                                     (i: nat):
                                                                                                                                                                                     (get_noise_by_idx(car(pd(varac))`1, N)
                                                                                                                                                                                      ^
                                                                                                                                                                                      (2+i)))" "vs(varidx(re1))" "varac" "pow" "nwidxs") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (inst "N vars in box" "idx") (("1" (replace "varac" 1) (("1" (expand "nth_ac" 1) (("1" (with-labels (flatten "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (("1" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 2) (("1" (skolem 1 "j") (("1" (flatten) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (reveal "varac") (("2" (replaces "varac") (("2" (expand "nth_ac") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "varac") (("3" (expand "length") (("3" (expand "nth_ac") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replaces "nwidxs" -1) (("2" (use "member_nats") (("2" (assert) (("2" (flatten) (("2" (replaces "varac") (("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "pow_var_compatible_noise") (("1" (assert) nil nil) ("2" (replaces "varac") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value" "varac")) (("2" (replaces "varac") (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value" "varac")) (("3" (replaces "varac") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache comp pairs on" "k-1") (("2" (inst "cache comp pairs on" "n") (("2" (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (replaces "eval cache" 2 :dir RL) (("2" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 3) (("1" (skolem 1 "i") (("1" (flatten) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (lemma "beyond_last_idx_notmember") (("1" (inst -1 "i" "pd(nth(cache, k - 1)`2)") (("1" (assert) (("1" (expand "idxs_ac") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value" "varac")) (("2" (replaces "varac") (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value" "varac")) (("3" (replaces "varac") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "re" 1) (("1" (assert) (("1" (use "pow_var_compatible_noise") (("1" (replaces "nwidxs") (("1" (replaces "varac") (("1" (expand "powvar?") (("1" (expand "varidx_powvar") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nth_ac") (("2" (replaces "varac") (("2" (hide-all-but (1 "varac not single value")) (("2" (expand "varidx_powvar") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (expand "varidx_powvar") (("2" (assert) (("2" (flatten) (("2" (inst "cache comp pairs on" "k-1") (("2" (inst "cache comp pairs on" "n") (("2" (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (assert) (("2" (expand "pow_var_compatible?") (("2" (flatten) (("2" (assert) (("2" (skolem 2 "j") (("2" (inst "cache if powvar" "j") (("2" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                               0)`1,
                                                                                                                                                                                                                           upd_noise_burst(N,
                                                                                                                                                                                                                                           nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                           LAMBDA
                                                                                                                                                                                                                                           (i: nat):
                                                                                                                                                                                                                                           (get_noise_by_idx
                                                                                                                                                                                                                                            (car(pd(varac))`1, N)
                                                                                                                                                                                                                                            ^
                                                                                                                                                                                                                                            (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                               0)`1,
                                                                                                                                                                                                                           N)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                               upd_noise_burst(N,
                                                                                                                                                                                                                                                               nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                               LAMBDA
                                                                                                                                                                                                                                                               (i: nat):
                                                                                                                                                                                                                                                               (get_noise_by_idx
                                                                                                                                                                                                                                                                (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                ^
                                                                                                                                                                                                                                                                (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                               N)") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst?) (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -1 "cache idxs bound" :hide? t) (("2" (typepred "j") (("2" (hide-all-but (-1 -5 "cache idxs bound")) (("2" (expand ">=") (("2" (case "j = opn(nth(cache, k - 1)`1) - 2 ") (("1" (hide -2) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil) ("2" (case "j < opn(nth(cache, k - 1)`1) - 2") (("1" (hide (-2 1)) (("1" (lemma "nth_ol[nat,<]") (("1" (inst -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "j") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "nth_ac" -2) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (name-replace "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (("1" (use "last_idx_box") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (expand_ol) (("1" (expand "nth" -4 1) (("1" (assert) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "last_idx_in_box") (("2" (assert) (("2" (expand "somevidx") (("2" (expand "varidx_powvar") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (use "power_Epsilon_is_Epsilon") (("3" (assert) (("3" (expand "length") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil) ("5" (expand "varidx_powvar") (("5" (assert) nil nil)) nil) ("6" (expand "varidx_powvar") (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "newoff" 1) (("3" (expand ">=") (("3" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (1 -1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("4" (replace "newoff" 1) (("4" (expand "idxs_bounded" 1) (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "acRes" 1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (replace "nwidxs" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (case "pow - 1 = opn(val(cached)`1)") (("1" (replace -1 1 :dir RL) (("1" (assert) (("1" (case "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                                                                                                   nats(nextfreeidx, newoff - 1)),
                                                                                                                                                                                                                            pow - 2) = nextfreeidx") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "nth(append(take[nat](pownoises, pow - 2), nats(nextfreeidx, newoff - 1)), pow - 2) =
                                                         nth(nats(nextfreeidx, newoff - 1), pow - 2 - length(take[nat](pownoises, pow - 2)))") (("1" (replaces -1 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "length(pownoises) = pow - 2") (("1" (replaces -1 2) (("1" (grind) nil nil)) nil) ("2" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "more_list_props[nat].nth_append") (("2" (split -1) (("1" (replaces -1 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (use "length_take[nat]") (("1" (replace -1 -2) (("1" (expand "min") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (use "length_take[nat]") (("2" (replace -1 1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (replace "pownoises" 1) (("2" (hide -1 -2) (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (skolem "cached cache idx" "j") (("2" (replace "cached cache idx" :dir RL) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) (("2" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "cached idx re" "cached cond ok") (("2" (replace "re" "cached cond ok") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (split 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (grind) nil nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (use "length_take[nat]") (("2" (replace -1 1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (replace "pownoises" 1) (("2" (hide -1 -2) (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (skolem "cached cache idx" "j") (("2" (replace "cached cache idx" :dir RL) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) (("2" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "cached idx re" "cached cond ok") (("2" (replace "re" "cached cond ok") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "nth(append(take[nat](pownoises, opn(val(cached)`1) - 1), nats(nextfreeidx, newoff - 1)), pow - 2)
                                                   =
                                                   nth(nats(nextfreeidx, newoff - 1),
                                                       pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1)))") (("1" (replaces -1 2) (("1" (case "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                 pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (case "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 1) (("1" (replaces "newoff" 1) (("1" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (inst? -5) (("1" (replace -5 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "more_list_props[nat].nth_append") (("1" (split -1) (("1" (replaces -1 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (use "length_take[nat]") (("1" (replace -1 -2) (("1" (expand "min") (("1" (lift-if -2) (("1" (split -2) (("1" (assert) nil nil) ("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (skolem "cached cache idx" "j") (("2" (replace "cached cache idx" :dir RL) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) (("2" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "varac") (("2" (replace "cached idx re" "cached cond ok") (("2" (replace "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (split 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (skolem "cached cache idx" "j") (("2" (replace "cached cache idx" :dir RL) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) (("2" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "varac") (("2" (replace "cached idx re" "cached cond ok") (("2" (replace "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "newoff" 2) (("2" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (inst? -5) (("2" (replaces -5 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache idxs bounded" "i-1") (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 2 "cache idxs bounded")) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial reals) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (nth_append formula-decl nil more_list_props structures) (length_take formula-decl nil more_list_props structures) (pow_var_compatible_noise formula-decl nil affine_pow nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (lt_realorder name-judgement "RealOrder" real_orders reals) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (nzBaseType type-eq-decl nil affine nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (upd_noise_burst const-decl "Noise" affine nil) (nth_ol formula-decl nil ordered_list structures) (containment_pow_var_ac formula-decl nil affine_pow nil) (SingInterval? const-decl "bool" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (last_idx const-decl "int" indexed_list structures) (take def-decl "list[T]" more_list_props structures) (idxs_pd def-decl "list[nat]" affine nil) (idxs_ac const-decl "list[nat]" affine nil) (notmember_ol_nat formula-decl nil affine_pow nil) (last_ol def-decl "T" ordered_list structures) (take_ol formula-decl nil ordered_list structures) (olidx_car_last formula-decl nil indexed_list structures) (last_idx_box formula-decl nil affine_box nil) (member_append_fi formula-decl nil more_list_props structures) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (last_take_nth formula-decl nil ordered_list structures) (powvar_comp_noise_extension formula-decl nil affine_pow nil) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (represents_var? const-decl "bool" affine nil) (next_idx const-decl "nat" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (eval def-decl "real" interval_expr interval_arith) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (beyond_last_idx_notmember formula-decl nil affine nil) (eval_updb_no_idxs formula-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (ac_proj_pd formula-decl nil affine nil) (gnbi_updb_2 formula-decl nil affine nil) (member_nats formula-decl nil affine_pow nil) (power_Epsilon_is_Epsilon formula-decl nil affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (lt_idx_strict_order formula-decl nil indexed_list structures) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC60-3 nil 3767018486 ("" (then (skeep*) (assert) (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (hide -13) (replaces "result") (assert) (spread (split 7) ((spread (inst 1 "(:(re, acRes, nwidxs):)") ((then (expand "append" 1) (grind)) (grind))) (then (lift-if "nwidxs") (spread (split nwidxs) ((then (with-labels (name "opn" "opn(val(cached)`1)") (("opn name"))) (hide "opn name") (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (with-labels (typepred "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (expand "compatible_pairs?") (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (spread (inst 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+1+opn)))") ((spread (split 1) ((then (expand "vars_in_box_compatible?") (skolem 1 "k") (inst "N vars in box" "k") (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (spread (split 1) ((then (replace "eval box is vs" 1 :dir RL) (expand "var_ac" 1) (lift-if 1) (spread (split 1) ((then (flatten) (expand "eval_ac_noise" 2) (spread (use "eval_pd_noise_rec_pds_def") ((then (assert) (expand_ol) (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1 2) (assert) (typepred "nextfreeidx") (spread (use "gnbi_updb_2") ((then (assert) (hide 2) (use "member_nats") (assert) (flatten) (typepred "k") (typepred "nextfreeidx") (expand "last_idx_in_box") (assert)) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "varac not single value")) (skeep) (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert))))) (assert)))) (then (flatten) (expand "eval_ac_noise" 1) (use "eval_pd_noise_rec_pds_def") (assert) (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((expand_ol) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert)))))))) (then (flatten) (assert) (replace "single intervals in box" 1 :dir RL :hide? t) (spread (use "gnbi_updb_2") ((then (assert) (hide 1) (replaces "nwidxs" -1) (use "member_nats") (assert) (flatten) (typepred "k") (typepred "nextfreeidx") (grind)) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert)))))))) (then (expand "compatible_pairs_on?") (skolem 1 "k") (skeep) (spread (split 1) ((spread (case "k=0") ((then (replaces -1) (expand "nth" 1) (expand "eval_ACExpr_Env" 1) (replaces "acRes") (typepred "cached") (assert) (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (skolem "cached cache idx" "i") (inst "cache comp pairs on" "i") (inst "cache comp pairs on" "n") (with-labels (flatten) (("cache eval" "cache if powvar" "UNKNOWN"))) (replace "cached cache idx") (expand "eval_ACExpr_Env" "cache eval") (assert) (use "cache_powvar_correct") (replace "cached cache idx") (expand "CacheData_correct?") (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (replace "cached as AC" "cache eval") (replace "re") (assert) (replace "cached idx re") (replace "varac" 1) (lemma "containment_pow_var_ac") (expand "eval" 1) (expand "eval" 1) (spread (inst? -1 :where 1) ((then (assert) (hide 2) (spread (split 1) ((then (expand "vars_in_box_compatible?") (inst "N vars in box" "idx") (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (replace -17) (replace "eval box is vs" 1 :dir RL) (expand "nth_ac") (expand "var_ac" 1) (lift-if 1) (spread (split 1) ((then (flatten) (expand "eval_ac_noise" 2) (spread (use "eval_pd_noise_rec_pds_def") ((then (assert) (expand_ol) (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1 2) (assert) (typepred "nextfreeidx") (spread (use "gnbi_updb_2") ((then (assert) (hide 2) (use "member_nats") (assert) (flatten) (expand "last_idx_in_box") (assert)) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert))))) (flatten)))) (then (flatten) (expand "eval_ac_noise" 1) (use "eval_pd_noise_rec_pds_def") (assert) (expand_ol) (replaces -1) (lemma "eval_pd_noise_rec_pds_def") (grind))))) (then (expand "nth_ac") (replace "varac" :dir RL) (flatten) (replace "nwidxs" -1 :hide? t) (use "member_append_fi[nat]") (assert) (hide -2) (spread (split -1) ((spread (split "cached cond ok") ((then (expand "next_idx") (expand "last_idx") (replace "pownoises") (hide-all-but (-1 -2 "varac" "varac not single value")) (replaces "varac") (use "olidx_car_last[nzBaseType]") (assert) (expand "car_ol") (spread (use "notmember_ol_nat") ((then (assert) (grind)) (use "take_ol[nat,<]")))) (grind))) (then (use "member_nats") (assert) (hide -2) (flatten) (typepred "nextfreeidx") (replace "varac") (use "last_idx_box") (expand "next_idx") (expand "last_idx") (hide-all-but (-1 -2 -3 "varac not single value")) (use "olidx_car_last[nzBaseType]") (spread (split -1) ((then (expand "car_ol") (assert)) (then (expand "length") (assert)))))))) (then (reveal "cache comp pairs on") (hide -1) (inst "cache comp pairs on" "i") (assert) (lemma "powvar_comp_noise_extension") (spread (inst -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") ((then (assert) (replace "varac" -1) (replaces "cached cache idx" :dir RL) (replace "pownoises" -1) (replace "nwidxs" 1) (replace "pownoises" 1) (replace "re" (-1 1)) (replace "newoff" 1) (reveal "opn name") (assert) (grind)) (then (hide 2) (replace "pownoises" 1) (expand "idxs_bounded" "cache idxs bound") (inst "cache idxs bound" "i") (spread (case "next_idx(pd(nth(cache, i)`2)) = nth(nth(cache, i)`3, opn(val(cached)`1)-2)+1") ((then (replace -1 "cache idxs bound" :hide? t) (spread (use "last_take_nth[nat,<]") ((then (replace -1 1 :hide? t) (assert)) (grind)))) (then (replace "cached cache idx") (replace "cached as AC" 1) (use "next_idx_pow_var_ac") (assert) (grind)) (then (replace "varac" "varac not single value") (assert) (expand "varidx_powvar") (assert))))) (then (expand "varidx_powvar") (replace "varac" "varac not single value") (replace "pownoises" 1) (replace "varac" 1) (flatten) (assert) (flatten) (assert)) (then (expand "length" "varac not single value") (replace "varac") (spread (split 1) ((then (expand "nth_ac") (hide-all-but 1) (grind)) (then (hide-all-but (-1 "varac not single value")) (assert))))) (then (replace "re" 1) (assert)))))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (reveal "varac") (grind))))) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert)) (then (hide-all-but (1 "varac" "varac not single value")) (expand "length") (grind))))) (then (expand "nth" 2) (assert) (inst "cache comp pairs on" "k-1") (inst "cache comp pairs on" "n") (with-labels (flatten "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (replace "cache eval" 2 :dir RL) (spread (use "eval_updb_no_idxs") ((then (assert) (hide 3) (skeep) (use "member_nats") (assert) (flatten) (expand "idxs_bounded" "cache idxs bound") (inst?) (expand "idxs_ac") (use "beyond_last_idx_notmember") (assert) (expand "next_idx") (assert)) (then (hide-all-but (1 "varac not single value")) (skeep) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert)) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert))))))) (spread (case "k=0") ((then (replaces -1) (flatten) (expand "nth" (-1 -2)) (expand "nth" 1) (typepred "cached") (assert) (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached in cache"))) (skolem "cached in cache" "j") (inst "cache comp pairs on" "j") (inst "cache comp pairs on" "n") (with-labels (flatten "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (assert) (lemma "powvar_comp_noise_extension") (spread (inst -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") ((then (assert) (replace "varac" -1) (replaces "cached in cache" :dir RL) (replace "pownoises" -1) (replace "cached idx re" "cached N compatible") (replace "re" "cached N compatible") (replace "nwidxs" 1) (replace "pownoises" 1) (replace "re" (-1 1)) (replace "newoff" 1) (reveal "opn name") (assert) (expand "varidx_powvar") (assert)) (then (replace "pownoises" 1) (expand "idxs_bounded" "cache idxs bound") (inst "cache idxs bound" "j") (spread (case "next_idx(pd(nth(cache, j)`2)) = nth(nth(cache, j)`3, opn(val(cached)`1)-2)+1") ((then (replace -1 "cache idxs bound" :hide? t) (spread (use "last_take_nth[nat,<]") ((then (replace -1 1 :hide? t) (assert)) (then (use "cache_powvar_correct") (expand "CacheData_correct?") (replace "cached in cache") (assert) (flatten) (replace "varac") (replace "cached idx re") (replace "re") (assert) (expand "varidx_powvar") (assert))))) (then (replace "cached in cache") (use "cache_powvar_correct") (replace "cached in cache") (expand "CacheData_correct?") (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (replace "cached as AC" 1) (use "next_idx_pow_var_ac") (replace "cached idx re" -1) (replace "re" -1) (replace "varac" "varac not single value") (assert) (replace "cached idx re" 1) (replace "re" 1) (assert) (expand "varidx_powvar") (propax)) (then (use "cache_powvar_correct") (replace "cached in cache") (expand "CacheData_correct?") (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (assert) (replace "varac" "varac not single value") (replace "cached idx re" -1) (replace "re" -1) (assert) (expand "varidx_powvar") (assert))))) (then (use "cache_powvar_correct") (replace "cached in cache") (expand "CacheData_correct?") (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (assert) (replace "varac" "varac not single value") (replace "pownoises" 1) (replace "varac" 1) (replace "cached idx re" "cached cond ok") (replace "re" "cached cond ok") (assert) (expand "varidx_powvar") (assert) (flatten) (assert) (flatten) (assert)) (then (expand "length" "varac not single value") (assert)) (then (replace "re" 1) (assert))))) (then (flatten) (spread (inst "cache comp pairs on" "k-1") ((then (inst "cache comp pairs on" "n") (expand "nth" 2) (assert) (flatten) (expand "nth" (-1 -2)) (assert) (expand "pow_var_compatible?") (flatten) (skolem 2 "i") (assert) (inst "cache comp pairs on" "i") (spread (case "get_noise_by_idx( nth(nth(cache, k - 1)`3, i)
                                                                                                                                            	                              , upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i: nat): (get_noise_by_idx(car(pd(varac))`1, N)^(1 + i +opn)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") ((then (replaces -1) (spread (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                                 0)`1,
                                                                                                                                                                                                                                                                             upd_noise_burst(N,
                                                                                                                                                                                                                                                                                             nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                                                             LAMBDA
                                                                                                                                                                                                                                                                                             (i: nat):
                                                                                                                                                                                                                                                                                             (get_noise_by_idx
                                                                                                                                                                                                                                                                                              (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                                              ^
                                                                                                                                                                                                                                                                                              (1 + i +opn))))
                                                                                                                                                                                                                                                             ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                                                 0)`1,
                                                                                                                                                                                                                                                                             N)
                                                                                                                                                                                                                                                             ^ (2 + i)") ((replaces -1) (spread (use "gnbi_updb_2") ((then (assert) (hide 1) (hide 2) (use "member_nats") (assert) (hide -2) (flatten) (typepred "nextfreeidx") (expand "nth_ac" -2) (expand "idxs_bounded") (inst "cache idxs bound" "k-1") (expand "next_idx") (name-replace "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (use "last_idx_box") (expand "next_idx") (expand "last_idx") (lift-if -1) (spread (split -1) ((then (flatten) (use "olidx_car_last[nzBaseType]") (expand_ol) (expand "nth" -4 1) (assert) (expand "nth_ac") (assert)) (then (assert) (hide-all-but (-1 -7)) (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert)) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert))))))) (then (hide 3) (spread (use "gnbi_updb_2") ((then (assert) (hide 1) (use "member_nats") (assert) (hide -2) (flatten) (expand "idxs_bounded") (inst "cache idxs bound" "k-1") (use "cache_powvar_correct") (expand "CacheData_correct?") (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (lemma "next_idx_pow_var_ac") (inst? -1 :where "cache idxs bound") (lift-if -1) (spread (split -1) ((then (typepred "cached") (assert)) (then (flatten) (spread (split -1) ((grind) (then (flatten) (replace -1 "cache idxs bound" :hide? t) (typepred "i") (hide-all-but (-1 -5 "cache idxs bound")) (expand ">=") (spread (case "i = opn(nth(cache, k - 1)`1) - 2") ((then (replaces -1) (hide -1) (assert)) (spread (case "i < opn(nth(cache, k - 1)`1) - 2") ((then (hide -2) (lemma "nth_ol[nat,<]") (inst -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "i") (assert)) (assert)))))))))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert))))) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert)) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert)) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert))))) (then (typepred "k") (hide-all-but (-1 1 2)) (assert) (grind)))))))))))) (then (hide-all-but (1 "varac not single value")) (skeep) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert)) (assert)))) (then (with-labels (flatten "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (with-labels (typepred "cache") (("correct cache" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (expand "compatible_pairs?") (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (spread (inst 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(2+i)))") ((spread (split 2) ((then (expand "vars_in_box_compatible?") (skolem 1 "k") (inst "N vars in box" "k") (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (spread (split 1) ((then (replace "eval box is vs" 1 :dir RL) (expand "var_ac" 1) (lift-if 1) (spread (split 1) ((then (flatten) (expand "eval_ac_noise" 2) (spread (use "eval_pd_noise_rec_pds_def") ((then (assert) (expand_ol) (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1) (assert) (typepred "nextfreeidx") (spread (use "gnbi_updb_2") ((then (assert) (hide 2) (use "member_nats") (assert) (flatten) (typepred "k") (typepred "nextfreeidx") (expand "last_idx_in_box") (assert)) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert))))) (assert)))) (then (flatten) (expand "eval_ac_noise" 1) (use "eval_pd_noise_rec_pds_def") (assert) (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((expand_ol) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)))))))) (then (flatten) (assert) (replaces "single intervals in box" 1 :dir RL) (spread (use "gnbi_updb_2") ((then (assert) (hide 1) (replaces "nwidxs" -1) (use "member_nats") (assert) (flatten) (typepred "k") (typepred "nextfreeidx") (grind)) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)))))))) (then (expand "compatible_pairs_on?") (skolem 1 "k") (skeep) (spread (split 1) ((spread (case "k=0") ((then (replaces -1) (expand "nth" 1) (expand "eval_ACExpr_Env" 1) (replaces "acRes") (expand "eval") (lemma "containment_pow_var_ac") (expand "eval" 1) (replace "re" 1) (assert) (spread (inst -1 "upd_noise_burst(N,
                                                                                                                                                                                           nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                           LAMBDA
                                                                                                                                                                                           (i: nat):
                                                                                                                                                                                           (get_noise_by_idx(car(pd(varac))`1, N)
                                                                                                                                                                                            ^
                                                                                                                                                                                            (2+i)))" "vs(varidx(re1))" "varac" "pow" "nwidxs") ((then (assert) (hide 2) (spread (split 1) ((then (expand "vars_in_box_compatible?") (inst "N vars in box" "idx") (replace "varac" 1) (expand "nth_ac" 1) (with-labels (flatten "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (spread (use "eval_updb_no_idxs") ((then (assert) (hide 2) (skolem 1 "j") (flatten) (use "member_nats") (assert) (flatten) (typepred "nextfreeidx") (use "last_idx_box") (grind)) (then (hide-all-but (1 "varac not single value")) (skeep) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (reveal "varac") (replaces "varac") (expand "nth_ac") (expand "length") (assert))))) (then (replaces "varac") (expand "length") (expand "nth_ac") (assert))))) (then (flatten) (replaces "nwidxs" -1) (use "member_nats") (assert) (flatten) (replaces "varac") (typepred "nextfreeidx") (use "last_idx_box") (grind)) (spread (use "pow_var_compatible_noise") ((assert) (then (replaces "varac") (hide-all-but 1) (grind))))))) (then (hide-all-but (1 "varac not single value" "varac")) (replaces "varac") (skeep) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value" "varac")) (replaces "varac") (expand "length") (assert))))) (then (expand "nth" 2) (assert) (inst "cache comp pairs on" "k-1") (inst "cache comp pairs on" "n") (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (replaces "eval cache" 2 :dir RL) (spread (use "eval_updb_no_idxs") ((then (assert) (hide 3) (skolem 1 "i") (flatten) (use "member_nats") (assert) (flatten) (expand "idxs_bounded") (inst "cache idxs bound" "k-1") (expand "next_idx") (lemma "beyond_last_idx_notmember") (inst -1 "i" "pd(nth(cache, k - 1)`2)") (assert) (expand "idxs_ac") (propax)) (then (hide-all-but (1 "varac not single value" "varac")) (replaces "varac") (skeep) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value" "varac")) (replaces "varac") (expand "length") (assert))))))) (spread (case "k=0") ((then (replaces -1) (expand "nth" 1) (replace "re" 1) (assert) (spread (use "pow_var_compatible_noise") ((then (replaces "nwidxs") (replaces "varac") (expand "powvar?") (expand "varidx_powvar") (assert)) (then (expand "nth_ac") (replaces "varac") (hide-all-but (1 "varac not single value")) (expand "varidx_powvar") (grind))))) (then (expand "nth" 2) (expand "varidx_powvar") (assert) (flatten) (inst "cache comp pairs on" "k-1") (inst "cache comp pairs on" "n") (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (assert) (expand "pow_var_compatible?") (flatten) (assert) (skolem 2 "j") (inst "cache if powvar" "j") (spread (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                     0)`1,
                                                                                                                                                                                                                                 upd_noise_burst(N,
                                                                                                                                                                                                                                                 nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                 LAMBDA
                                                                                                                                                                                                                                                 (i: nat):
                                                                                                                                                                                                                                                 (get_noise_by_idx
                                                                                                                                                                                                                                                  (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                  ^
                                                                                                                                                                                                                                                  (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                     0)`1,
                                                                                                                                                                                                                                 N)") ((then (replaces -1) (spread (case "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                                      upd_noise_burst(N,
                                                                                                                                                                                                                                                                      nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                                      LAMBDA
                                                                                                                                                                                                                                                                      (i: nat):
                                                                                                                                                                                                                                                                      (get_noise_by_idx
                                                                                                                                                                                                                                                                       (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                                       ^
                                                                                                                                                                                                                                                                       (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                                                      N)") ((then (replaces -1) (grind)) (then (hide 3) (spread (use "gnbi_updb_2") ((then (assert) (hide 1) (use "member_nats") (assert) (flatten) (expand "idxs_bounded") (inst?) (use "cache_powvar_correct") (expand "CacheData_correct?") (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (lemma "next_idx_pow_var_ac") (inst? -1 :where "cache idxs bound") (lift-if -1) (spread (split -1) ((then (flatten) (grind)) (then (flatten) (spread (split -1) ((grind) (then (flatten) (replace -1 "cache idxs bound" :hide? t) (typepred "j") (hide-all-but (-1 -5 "cache idxs bound")) (expand ">=") (spread (case "j = opn(nth(cache, k - 1)`1) - 2 ") ((then (hide -2) (replaces -1) (assert)) (spread (case "j < opn(nth(cache, k - 1)`1) - 2") ((then (hide (-2 1)) (lemma "nth_ol[nat,<]") (inst -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "j") (assert)) (assert)))))))))))) (then (hide-all-but (1 "varac not single value")) (skeep) (spread (use "power_Epsilon_is_Epsilon") ((then (assert) (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert)))))))) (then (hide 3) (spread (use "gnbi_updb_2") ((then (assert) (hide 1) (use "member_nats") (assert) (flatten) (typepred "nextfreeidx") (expand "nth_ac" -2) (expand "idxs_bounded") (inst "cache idxs bound" "k-1") (expand "next_idx") (name-replace "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (use "last_idx_box") (expand "next_idx") (expand "last_idx") (lift-if -1) (spread (split -1) ((then (flatten) (use "olidx_car_last[nzBaseType]") (expand_ol) (expand "nth" -4 1) (assert) (expand "nth_ac") (assert)) (then (flatten) (expand "last_idx_in_box") (assert) (expand "somevidx") (expand "varidx_powvar") (assert) (grind))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert)) (then (expand "varidx_powvar") (assert)) (then (expand "varidx_powvar") (propax)))))))))))) (then (hide-all-but (1 "varac not single value")) (skeep) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (assert))))))) (then (replace "newoff" 1) (expand ">=") (spread (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") ((then (replaces -1) (spread (case "0 < pow - opn(val(cached)`1)") ((then (hide-all-but (1 -1)) (name-replace "A" "pow - opn(val(cached)`1)") (assert)) (grind)))) (assert)))) (then (replace "newoff" 1) (expand "idxs_bounded" 1) (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (replace "acRes" 1) (use "next_idx_pow_var_ac") (replaces -1) (lift-if 1) (spread (split 1) ((then (flatten) (grind)) (then (flatten) (spread (split 3) ((then (flatten) (grind)) (then (flatten) (replace "nwidxs" 2) (lift-if 2) (spread (split 2) ((then (flatten) (spread (case "pow - 1 = opn(val(cached)`1)") ((then (replace -1 1 :dir RL) (assert) (spread (case "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                                                                                                           nats(nextfreeidx, newoff - 1)),
                                                                                                                                                                                                                                    pow - 2) = nextfreeidx") ((assert) (then (hide 2) (spread (case "nth(append(take[nat](pownoises, pow - 2), nats(nextfreeidx, newoff - 1)), pow - 2) =
                                                                  nth(nats(nextfreeidx, newoff - 1), pow - 2 - length(take[nat](pownoises, pow - 2)))") ((then (replaces -1 1) (use "length_take[nat]") (replaces -1 1) (expand "min") (lift-if 1) (spread (split 1) ((then (flatten) (grind)) (then (flatten) (spread (case "length(pownoises) = pow - 2") ((then (replaces -1 2) (grind)) (spread (case "length(pownoises) > opn(val(cached)`1) - 2") ((assert) (then (replace "pownoises" 1) (typepred "cached") (use "cache_powvar_correct_result") (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (with-labels (assert) (("cached correct"))) (replace "cached" "cached correct" :dir RL) (expand "CacheData_correct?" "cached correct") (typepred "cached") (assert) (flatten) (assert) (flatten) (replace "varac" "varac not single value") (replace -2 "cached correct") (replace "re" "cached correct") (assert) (expand "varidx_powvar") (assert)))))))))) (then (use "more_list_props[nat].nth_append") (spread (split -1) ((then (replaces -1 1) (lift-if 1) (spread (split 1) ((then (flatten) (use "length_take[nat]") (replace -1 -2) (expand "min") (lift-if -1) (spread (split -1) ((then (flatten) (assert)) (then (flatten) (assert))))) (propax)))) (then (use "length_append[nat]") (use "length_take[nat]") (replace -1 1) (expand "min") (lift-if 1) (spread (split 1) ((then (flatten) (assert)) (then (flatten) (replace "pownoises" 1) (hide -1 -2) (typepred "cached") (assert) (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (skolem "cached cache idx" "j") (replace "cached cache idx" :dir RL) (use "cache_powvar_correct") (expand "CacheData_correct?") (assert) (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (replace "cached idx re" "cached cond ok") (replace "re" "cached cond ok") (assert) (expand "varidx_powvar") (assert)))))))) (spread (split 1) ((then (use "length_take[nat]") (replaces -1 1) (grind)) (then (use "length_append[nat]") (use "length_take[nat]") (replace -1 1) (expand "min") (lift-if 1) (spread (split 1) ((then (flatten) (assert)) (then (flatten) (replace "pownoises" 1) (hide -1 -2) (typepred "cached") (assert) (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (skolem "cached cache idx" "j") (replace "cached cache idx" :dir RL) (use "cache_powvar_correct") (expand "CacheData_correct?") (assert) (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (replace "cached idx re" "cached cond ok") (replace "re" "cached cond ok") (assert) (expand "varidx_powvar") (assert))))))))))))) (spread (case "nth(append(take[nat](pownoises, opn(val(cached)`1) - 1), nats(nextfreeidx, newoff - 1)), pow - 2)
                                                          =
                                                          nth(nats(nextfreeidx, newoff - 1),
                                                              pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1)))") ((then (replaces -1 2) (spread (case "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                         pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") ((then (replaces -1 2) (replace "newoff" 2) (assert)) (spread (case "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") ((then (replaces -1 1) (replaces "newoff" 1) (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (inst? -5) (replace -5 2) (assert)) (spread (use "length_take[nat]") ((then (replace -1 1) (expand "min" 1) (lift-if 1) (spread (split 1) ((propax) (then (flatten) (replaces "pownoises" 1) (use "cache_powvar_correct_result") (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (with-labels (assert) (("cached correct"))) (expand "CacheData_correct?" "cached correct") (typepred "cached") (assert) (flatten) (assert) (flatten) (replace "cached" "cached correct" :dir RL) (replace -2 "cached correct") (replace "re" "cached correct") (assert) (expand "varidx_powvar") (assert))))) (assert))))) (spread (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") ((then (replace -1 1) (assert)) (spread (use "length_take[nat]") ((then (replace -1 1) (expand "min" 1) (lift-if 1) (spread (split 1) ((propax) (then (flatten) (replaces "pownoises" 1) (use "cache_powvar_correct_result") (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (with-labels (assert) (("cached correct"))))))) (assert)))))))) (spread (use "more_list_props[nat].nth_append") ((spread (split -1) ((then (replaces -1 1) (lift-if 1) (spread (split 1) ((then (flatten) (spread (use "length_take[nat]") ((then (replace -1 -2) (expand "min") (lift-if -2) (spread (split -2) ((assert) (then (assert) (flatten) (assert))))) (assert)))) (propax)))) (spread (use "length_take[nat]") ((then (replaces -1 1) (expand "min") (lift-if 1) (spread (split 1) ((assert) (then (flatten) (replaces "pownoises" 1) (typepred "cached") (assert) (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (skolem "cached cache idx" "j") (replace "cached cache idx" :dir RL) (use "cache_powvar_correct") (expand "CacheData_correct?") (assert) (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (replace "varac") (replace "cached idx re" "cached cond ok") (replace "re") (assert) (expand "varidx_powvar") (assert))))) (assert))))) (assert) (assert))) (spread (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") ((spread (split 1) ((then (replaces -1 1) (assert)) (spread (use "length_append[nat]") ((then (replaces -1 1) (spread (use "length_take[nat]") ((then (replaces -1 1) (expand "min") (lift-if 1) (spread (split 1) ((assert) (then (flatten) (replaces "pownoises" 1) (typepred "cached") (assert) (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (skolem "cached cache idx" "j") (replace "cached cache idx" :dir RL) (use "cache_powvar_correct") (expand "CacheData_correct?") (assert) (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (replace "varac") (replace "cached idx re" "cached cond ok") (replace "re") (assert) (expand "varidx_powvar") (assert))))) (assert)))) (assert) (assert))))) (then (hide 2) (spread (use "length_take[nat]") ((then (replace -1 1) (expand "min" 1) (lift-if 1) (spread (split 1) ((propax) (then (flatten) (replaces "pownoises" 1) (use "cache_powvar_correct_result") (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (with-labels (assert) (("cached correct"))) (expand "CacheData_correct?" "cached correct") (typepred "cached") (assert) (flatten) (assert) (flatten) (replace "cached" "cached correct" :dir RL) (replace -2 "cached correct") (replace "re" "cached correct") (assert) (expand "varidx_powvar") (assert))))) (assert)))) (assert))) (assert) (assert)))))) (then (flatten) (replace "newoff" 2) (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (inst? -5) (replaces -5 3) (assert))))))))))) (then (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (expand "idxs_bounded" "cache idxs bounded") (expand "nth" 2) (assert) (inst "cache idxs bounded" "i-1") (expand ">=") (spread (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") ((then (replaces -1) (spread (case "0 < pow - opn(val(cached)`1)") ((then (hide-all-but (-1 2 "cache idxs bounded")) (name-replace "A" "pow - opn(val(cached)`1)") (assert)) (grind)))) (grind)))))))))) nil nil) nil nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC60-2 nil 3637347318 ("" (then (skeep*) (replaces -5) (spread (typepred "nats(nextfreeidx, newoff - 1)") ((then (replaces -4) (spread (split 8) ((then (replaces -8) (assert)) (then (flatten) (expand "car_ol") (replaces -3) (expand "next_idx") (use "last_idx_box") (replaces -6) (expand "next_idx") (typepred "nextfreeidx") (assert))))) (then (replaces -4) (assert))))) nil nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (next_idx const-decl "nat" affine nil) (last_idx_box formula-decl nil affine_box nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC60-1 nil 3631872799 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "cached" -4) (label "idxs" -5) (label "pownoises" -6) (label "newoff" -7) (label "nwidxs" -8) (label "acRes" -9) (label "result" -10) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (expand "every") (("1" (split 1) (("1" (replace "nwidxs" 1) (("1" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert (-1 "cache correct")) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (("1" (assert) (("1" (with-labels (flatten "cached correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (("1" (split "cached cond ok") (("1" (split 1) (("1" (flatten) (("1" (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") (("1" (typepred "nwidxs2") (("1" (expand "append_ol") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "appendable_ol?") (("2" (flatten) (("2" (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") (("1" (replaces -1 3) (("1" (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") (("1" (replaces -1 3) (("1" (skeep "cached cache idx") (("1" (replace "pownoises" 1) (("1" (replace "cached cache idx" 1 :dir RL) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (inst "cache idxs bound" "i") (("1" (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (("1" (replace "cached`2 is powvarac" "cache idxs bound") (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if "cache idxs bound") (("1" (split "cache idxs bound") (("1" (assert) (("1" (replace "varac" "varac not single value") (("1" (replace "cached cache idx" "cache idxs bound") (("1" (replace "cached`1 varidx" "cache idxs bound") (("1" (replace "re") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (flatten "cache idxs bound") (("opn not 0" "varac not single value" "cache idxs bound" "UNKNOWN"))) (("2" (split "cache idxs bound") (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (with-labels (flatten "cache idxs bound") (("opn not 1" "cache idxs bound" "UNKNOWN"))) (("2" (expand ">=") (("2" (replace "pownoises" 6) (("2" (replace "cached cache idx" 6 :dir RL) (("2" (hide-all-but ("cache idxs bound" 6)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3 5 -1 "pow gt opn" "opw gt opn")) (("2" (expand "nats" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand_ol) (("2" (expand "first_ol") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "last_take_nth[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (use "last_take_nth[nat,<]") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (use "take_ol[nat,<]") (("4" (assert) nil nil)) nil) ("5" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (replace "cached`1 varidx" "cached cond ok") (("2" (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "cache") (("2" (generalize "cache" "cache") (("2" (induct "cache") (("1" (grind) nil nil) ("2" (skolem 1 ("h" "t")) (("2" (flatten) (("2" (expand "every" 1) (("2" (split 1) (("1" (typepred "h`3") (("1" (assert) nil nil)) nil) ("2" (split -1) (("1" (propax) nil nil) ("2" (expand "correct_cache?" -1) (("2" (flatten) nil nil)) nil) ("3" (expand "compatible_pairs?") (("3" (skeep) (("3" (inst?) (("3" (assert) (("3" (expand "compatible_pairs_on?") (("3" (skeep) (("3" (expand "nth" -3) (("3" (inst -3 "i+1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "idxs_bounded") (("4" (skeep) (("4" (expand "nth" -3) (("4" (inst -3 "i+1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "correct_cache?" -1) (("5" (flatten) nil nil)) nil) ("6" (expand "compatible_pairs?") (("6" (skeep) (("6" (inst?) (("6" (assert) (("6" (expand "compatible_pairs_on?") (("6" (skeep) (("6" (expand "nth" -3) (("6" (inst -3 "i+1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (expand "idxs_bounded") (("7" (skeep) (("7" (expand "nth" -3) (("7" (inst -3 "i+1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "correct_cache?") (("2" (expand "CacheData_correct?") (("2" (replace "re" 1) (("2" (assert) (("2" (lift-if "nwidxs") (("2" (split "nwidxs") (("1" (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (replace "nwidxs" 1) (("1" (split 1) (("1" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (with-labels (typepred "nats(nextfreeidx, newoff - 1)") (("nats list[nat]" "nats ol" "nats not null" "nats car" "nats length" "nats i") ("newoff >= 1"))) (("1" (replaces "nats length" 2) (("1" (case "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replace "pownoises") (("2" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert -1) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (flatten) (("2" (case "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                        nats(nextfreeidx, newoff - 1))) = car(pownoises)") (("1" (replaces -1 2) (("1" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("1" (use "cache_powvar_correct_result") (("1" (with-labels (assert -1) (("cached correct"))) (("1" (replace "cached" "cached correct" :dir RL) (("1" (expand "CacheData_correct?" "cached correct") (("1" (typepred "cached") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (split "cached correct") (("1" (flatten) (("1" (split -2) (("1" (replace -4 "cached correct") (("1" (replace "re" "cached correct") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "take" -1) (("1" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (hide -1) (("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "take" 2) (("2" (case "length(pownoises) >= opn(val(cached)`1) - 1") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "pownoises" 1) (("3" (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("3" (use "cache_powvar_correct_result") (("3" (with-labels (assert) (("cached correct"))) (("3" (replace "cached" "cached correct" :dir RL) (("3" (expand "CacheData_correct?" "cached correct") (("3" (typepred "cached") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (split "cached correct") (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (replace "varac" "varac not single value") (("2" (replace -3 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 2) (("2" (split 2) (("1" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replace -4 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (flatten) (("2" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (inst -5 "0") (("1" (expand "nth") (("1" (replace -5 3) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -4 1) (("2" (replace "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "newoff") (("3" (hide-all-but (1 "pow gt opn" "opw gt opn")) (("3" (case "opn(val(cached)`1) < pow") (("1" (hide "pow gt opn" "opw gt opn") (("1" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 <= pow - opn(val(cached)`1)") (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (take_ol formula-decl nil ordered_list structures) (last_ol def-decl "T" ordered_list structures) (first_ol const-decl "T" ordered_list structures) (next_idx const-decl "nat" affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzBaseType type-eq-decl nil affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (represents_var? const-decl "bool" affine nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (cons_ol const-decl "ordered_list" ordered_list structures) (last_take_nth formula-decl nil ordered_list structures) (appendable_ol? const-decl "bool" ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (var_ac const-decl "AffineCombination" affine nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (last_idx const-decl "int" indexed_list structures) (Noise type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (last_idx_box formula-decl nil affine_box nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC66 0 (RE2AC_TCC66-1 "" 3789917914 ("" (skeep*) (("" (grind) nil nil)) nil) ((ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}")) (RE2AC_TCC61-3 nil 3637347692 ("" (then (skeep*) (grind)) nil nil) ((empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}")) (RE2AC_TCC61-2 nil 3632079158 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached some" -3) (label "cached" -4) (label "idxs" -5) (label "pownoises" -6) (label "newoff" -7) (label "nwidxs" -8) (label "acRes" -9) (label "result" -10) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (hide -11) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(:(re, acRes, nwidxs):)") (("1" (expand "append" 1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (lift-if "nwidxs") (("2" (split nwidxs) (("1" (with-labels (name "opn" "opn(val(cached)`1)") (("opn name"))) (("1" (hide "opn name") (("1" (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (with-labels (typepred "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("1" (expand "compatible_pairs?") (("1" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("1" (inst 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+1+opn)))") (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (skolem 1 "k") (("1" (inst "N vars in box" "k") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1 2) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace "single intervals in box" 1 :dir RL :hide? t) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skolem 1 "k") (("2" (split 1) (("1" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env" 1) (("1" (replaces "acRes") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("1" (skolem "cached cache idx" "i") (("1" (inst "cache comp pairs on" "i") (("1" (with-labels (flatten) (("cache eval" "cache if powvar" "UNKNOWN"))) (("1" (replace "cached cache idx") (("1" (expand "eval_ACExpr_Env" "cache eval") (("1" (assert) (("1" (use "cache_powvar_correct") (("1" (replace "cached cache idx") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("1" (replace "cached as AC" "cache eval") (("1" (replace "re") (("1" (assert) (("1" (replace "cached idx re") (("1" (replace "varac" 1) (("1" (lemma "containment_pow_var_ac") (("1" (inst? -1 :where 1) (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (inst "N vars in box" "idx") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "nth_ac") (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1 2) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (lemma "eval_pd_noise_rec_pds_def") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth_ac") (("2" (replace "varac" :dir RL) (("2" (flatten) (("2" (replace "nwidxs" -1 :hide? t) (("2" (use "member_append_fi[nat]") (("2" (assert) (("2" (hide -2) (("2" (split -1) (("1" (split "cached cond ok") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (replace "pownoises") (("1" (hide-all-but (-1 -2 "varac" "varac not single value")) (("1" (replaces "varac") (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (expand "car_ol") (("1" (use "notmember_ol_nat") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (use "take_ol[nat,<]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (use "member_nats") (("2" (assert) (("2" (hide -2) (("2" (flatten) (("2" (typepred "nextfreeidx") (("2" (replace "varac") (("2" (use "last_idx_box") (("2" (expand "next_idx") (("2" (expand "last_idx") (("2" (hide-all-but (-1 -2 -3 "varac not single value")) (("2" (use "olidx_car_last[nzBaseType]") (("2" (split -1) (("1" (expand "car_ol") (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal "cache comp pairs on") (("3" (inst "cache comp pairs on" "i") (("3" (with-labels (flatten "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("3" (assert) (("3" (lemma "powvar_comp_noise_extension") (("3" (inst -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (assert) (("1" (replace "varac" -1) (("1" (replaces "cached cache idx" :dir RL) (("1" (replace "pownoises" -1) (("1" (replace "nwidxs" 1) (("1" (replace "pownoises" 1) (("1" (replace "re" (-1 1)) (("1" (replace "newoff" 1) (("1" (reveal "opn name") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace "pownoises" 1) (("2" (expand "idxs_bounded" "cache idxs bound") (("2" (inst "cache idxs bound" "i") (("2" (case "next_idx(pd(nth(cache, i)`2)) = nth(nth(cache, i)`3, opn(val(cached)`1)-2)+1") (("1" (replace -1 "cache idxs bound" :hide? t) (("1" (use "last_take_nth[nat,<]") (("1" (replace -1 1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (replace "cached cache idx") (("2" (replace "cached as AC" 1) (("2" (use "next_idx_pow_var_ac") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (replace "varac" "varac not single value") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "varac" "varac not single value") (("3" (replace "pownoises" 1) (("3" (replace "varac" 1) (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (expand "length" "varac not single value") (("4" (replace "varac") (("4" (split 1) (("1" (expand "nth_ac") (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 "varac not single value")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (replace "re" 1) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (reveal "varac") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac" "varac not single value")) (("4" (expand "length") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache comp pairs on" "k-1") (("2" (with-labels (flatten "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (("2" (replace "cache eval" 2 :dir RL) (("2" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 3) (("1" (skeep) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (inst?) (("1" (expand "idxs_ac") (("1" (use "beyond_last_idx_notmember") (("1" (assert) (("1" (expand "next_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "k=0") (("1" (replaces -1) (("1" (flatten) (("1" (expand "nth" (-1 -2)) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached in cache"))) (("1" (skolem "cached in cache" "j") (("1" (inst "cache comp pairs on" "j") (("1" (with-labels (flatten "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("1" (assert) (("1" (lemma "powvar_comp_noise_extension") (("1" (inst -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (assert) (("1" (replace "varac" -1) (("1" (replaces "cached in cache" :dir RL) (("1" (replace "pownoises" -1) (("1" (replace "cached idx re" "cached N compatible") (("1" (replace "re" "cached N compatible") (("1" (replace "nwidxs" 1) (("1" (replace "pownoises" 1) (("1" (replace "re" (-1 1)) (("1" (replace "newoff" 1) (("1" (reveal "opn name") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "pownoises" 1) (("2" (expand "idxs_bounded" "cache idxs bound") (("2" (inst "cache idxs bound" "j") (("2" (case "next_idx(pd(nth(cache, j)`2)) = nth(nth(cache, j)`3, opn(val(cached)`1)-2)+1") (("1" (replace -1 "cache idxs bound" :hide? t) (("1" (use "last_take_nth[nat,<]") (("1" (replace -1 1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (replace "cached in cache") (("2" (assert) (("2" (flatten) (("2" (replace "varac") (("2" (replace "cached idx re") (("2" (replace "re") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached in cache") (("2" (use "cache_powvar_correct") (("2" (replace "cached in cache") (("2" (expand "CacheData_correct?") (("2" (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "cached as AC" 1) (("2" (use "next_idx_pow_var_ac") (("2" (replace "cached idx re" -1) (("2" (replace "re" -1) (("2" (replace "varac" "varac not single value") (("2" (assert) (("2" (replace "cached idx re" 1) (("2" (replace "re" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "cache_powvar_correct") (("3" (replace "cached in cache") (("3" (expand "CacheData_correct?") (("3" (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (assert) (("3" (replace "varac" "varac not single value") (("3" (replace "cached idx re" -1) (("3" (replace "re" -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "cache_powvar_correct") (("3" (replace "cached in cache") (("3" (expand "CacheData_correct?") (("3" (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (assert) (("3" (replace "varac" "varac not single value") (("3" (replace "pownoises" 1) (("3" (replace "varac" 1) (("3" (replace "cached idx re" "cached cond ok") (("3" (replace "re" "cached cond ok") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "length" "varac not single value") (("4" (assert) nil nil)) nil) ("5" (replace "re" 1) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst "cache comp pairs on" "k-1") (("1" (expand "nth" 2) (("1" (assert) (("1" (flatten) (("1" (expand "nth" (-1 -2)) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (flatten) (("1" (skolem 2 "i") (("1" (assert) (("1" (inst "cache comp pairs on" "i") (("1" (case "get_noise_by_idx( nth(nth(cache, k - 1)`3, i)
                      	                              , upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i: nat): (get_noise_by_idx(car(pd(varac))`1, N)^(1 + i +opn)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                                                                                                                                               0)`1,
                                                                                                                                           upd_noise_burst(N,
                                                                                                                                                           nats(nextfreeidx, newoff - 1),
                                                                                                                                                           LAMBDA
                                                                                                                                                           (i: nat):
                                                                                                                                                           (get_noise_by_idx
                                                                                                                                                            (car(pd(varac))`1, N)
                                                                                                                                                            ^
                                                                                                                                                            (1 + i +opn))))
                                                                                                                           ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                                                                                                                                               0)`1,
                                                                                                                                           N)
                                                                                                                           ^ (2 + i)") (("1" (replaces -1) nil nil) ("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "nth_ac" -2) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (name-replace "somevidx" "varidx(nth(cache, k - 1)`1)") (("1" (use "last_idx_box") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (expand_ol) (("1" (expand "nth" -4 1) (("1" (assert) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-1 -7)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (typepred "cached") (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -1 "cache idxs bound" :hide? t) (("2" (typepred "i") (("2" (hide-all-but (-1 -5 "cache idxs bound")) (("2" (expand ">=") (("2" (case "i = opn(nth(cache, k - 1)`1) - 2") (("1" (replaces -1) (("1" (hide -1) (("1" (assert) nil nil)) nil)) nil) ("2" (case "i < opn(nth(cache, k - 1)`1) - 2") (("1" (hide -2) (("1" (lemma "nth_ol[nat,<]") (("1" (inst -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "i") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (assert) (("3" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "opn >= 2")) (("4" (skeep) (("4" (reveal "opn name") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (hide-all-but (1 "varac not single value")) (("5" (expand "length") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "k") (("2" (hide-all-but (-1 1 2)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (flatten "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (("2" (with-labels (typepred "cache") (("correct cache" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (expand "compatible_pairs?") (("2" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (inst 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(2+i)))") (("1" (split 2) (("1" (expand "vars_in_box_compatible?") (("1" (skolem 1 "k") (("1" (inst "N vars in box" "k") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces "single intervals in box" 1 :dir RL) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skolem 1 "k") (("2" (split 1) (("1" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env" 1) (("1" (replaces "acRes") (("1" (lemma "containment_pow_var_ac") (("1" (inst -1 "upd_noise_burst(N,
                                                                                                          nats(nextfreeidx, newoff - 1),
                                                                                                          LAMBDA
                                                                                                          (i: nat):
                                                                                                          (get_noise_by_idx(car(pd(varac))`1, N)
                                                                                                           ^
                                                                                                           (2+i)))" "vs(varidx(re))" "varac" "pow" "nwidxs") (("1" (replace "re" 1) (("1" (assert) (("1" (replace "re" -1) (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (inst "N vars in box" "idx") (("1" (replace "varac" 1) (("1" (expand "nth_ac" 1) (("1" (with-labels (flatten "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (("1" (replace "box eval" 1 :dir RL) (("1" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 2) (("1" (skolem 1 "j") (("1" (flatten) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (reveal "varac") (("2" (replaces "varac") (("2" (expand "nth_ac") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "varac") (("3" (expand "length") (("3" (expand "nth_ac") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replaces "nwidxs" -1) (("2" (use "member_nats") (("2" (assert) (("2" (flatten) (("2" (replaces "varac") (("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "pow_var_compatible_noise") (("1" (assert) nil nil) ("2" (replaces "varac") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value" "varac")) (("2" (replaces "varac") (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value" "varac")) (("3" (replaces "varac") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache comp pairs on" "k-1") (("2" (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (replaces "eval cache" 2 :dir RL) (("2" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 3) (("1" (skolem 1 "i") (("1" (flatten) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (lemma "beyond_last_idx_notmember") (("1" (inst -1 "i" "pd(nth(cache, k - 1)`2)") (("1" (assert) (("1" (expand "idxs_ac") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value" "varac")) (("2" (replaces "varac") (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value" "varac")) (("3" (replaces "varac") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "re" 1) (("1" (assert) (("1" (use "pow_var_compatible_noise") (("1" (replaces "nwidxs") (("1" (replaces "varac") nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (flatten) (("2" (inst "cache comp pairs on" "k-1") (("2" (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (assert) (("2" (expand "pow_var_compatible?") (("2" (flatten) (("2" (assert) (("2" (skolem 2 "j") (("2" (inst "cache if powvar" "j") (("2" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                                                                                                                           0)`1,
                                                                                                                       upd_noise_burst(N,
                                                                                                                                       nats(nextfreeidx, newoff - 1),
                                                                                                                                       LAMBDA
                                                                                                                                       (i: nat):
                                                                                                                                       (get_noise_by_idx
                                                                                                                                        (car(pd(varac))`1, N)
                                                                                                                                        ^
                                                                                                                                        (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, k - 1)`1))),
                                                                                                                           0)`1,
                                                                                                                       N)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                upd_noise_burst(N,
                                                                                                                                                nats(nextfreeidx, newoff - 1),
                                                                                                                                                LAMBDA
                                                                                                                                                (i: nat):
                                                                                                                                                (get_noise_by_idx
                                                                                                                                                 (car(pd(varac))`1, N)
                                                                                                                                                 ^
                                                                                                                                                 (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                N)") (("1" (replaces -1) nil nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst?) (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -1 "cache idxs bound" :hide? t) (("2" (typepred "j") (("2" (hide-all-but (-1 -5 "cache idxs bound")) (("2" (expand ">=") (("2" (case "j = opn(nth(cache, k - 1)`1) - 2 ") (("1" (hide -2) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil) ("2" (case "j < opn(nth(cache, k - 1)`1) - 2") (("1" (hide (-2 1)) (("1" (lemma "nth_ol[nat,<]") (("1" (inst -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "j") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "nth_ac" -2) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (name-replace "somevidx" "varidx(nth(cache, k - 1)`1)") (("1" (use "last_idx_box") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (expand_ol) (("1" (expand "nth" -4 1) (("1" (assert) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-1 -8)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "newoff" 1) (("3" (expand ">=") (("3" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (1 -1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("4" (replace "newoff" 1) (("4" (expand "idxs_bounded" 1) (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "acRes" 1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (replace "nwidxs" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (case "pow - 1 = opn(val(cached)`1)") (("1" (replace -1 1 :dir RL) (("1" (assert) (("1" (case "nth(append(take[nat](pownoises, pow - 2),
                                                                                                          nats(nextfreeidx, newoff - 1)),
                                                                                                   pow - 2) = nextfreeidx") (("1" (assert) nil nil) ("2" (hide 2) (("2" (use "nth_append[nat]") (("1" (replaces -1 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "length(pownoises) = pow - 2") (("1" (replaces -1 2) (("1" (grind) nil nil)) nil) ("2" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (grind) nil nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (replace -1 1) (("2" (use "length_take[nat]") (("2" (replace -1 1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (replace "pownoises" 1) (("2" (hide -1 -2) (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (skolem "cached cache idx" "j") (("2" (replace "cached cache idx" :dir RL) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) (("2" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "cached idx re" "cached cond ok") (("2" (replace "re" "cached cond ok") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "nth_append[nat]") (("1" (replaces -1 2) (("1" (case "nth(nats(nextfreeidx, newoff - 1),
                                                                                                            pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (case "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 1) (("1" (replaces "newoff" 1) (("1" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (inst? -5) (("1" (replace -5 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil) ("2" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (split 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (skolem "cached cache idx" "j") (("2" (replace "cached cache idx" :dir RL) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) (("2" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "varac") (("2" (replace "cached idx re" "cached cond ok") (("2" (replace "re") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "newoff" 2) (("2" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (inst? -5) (("2" (replaces -5 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache idxs bounded" "i-1") (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 2 "cache idxs bounded")) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial reals) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (pow_var_compatible_noise formula-decl nil affine_pow nil) (cons_ol const-decl "ordered_list" ordered_list structures) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (nzBaseType type-eq-decl nil affine nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (upd_noise_burst const-decl "Noise" affine nil) (beyond_last_idx_notmember formula-decl nil affine nil) (eval_updb_no_idxs formula-decl nil affine nil) (containment_pow_var_ac formula-decl nil affine_pow nil) (idxs_ac const-decl "list[nat]" affine nil) (idxs_pd def-decl "list[nat]" affine nil) (last_idx const-decl "int" indexed_list structures) (pow_var_compatible? const-decl "bool" affine_pow nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (SingInterval? const-decl "bool" affine nil) (notmember_ol_nat formula-decl nil affine_pow nil) (last_ol def-decl "T" ordered_list structures) (take_ol formula-decl nil ordered_list structures) (olidx_car_last formula-decl nil indexed_list structures) (last_idx_box formula-decl nil affine_box nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (last_take_nth formula-decl nil ordered_list structures) (powvar_comp_noise_extension formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (next_idx const-decl "nat" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (nth_ol formula-decl nil ordered_list structures) (vars_in_box_compatible? const-decl "bool" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (ac_proj_pd formula-decl nil affine nil) (gnbi_updb_2 formula-decl nil affine nil) (member_nats formula-decl nil affine_pow nil) (power_Epsilon_is_Epsilon formula-decl nil affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (ordered_list type-eq-decl nil ordered_list structures)) nil (RE2AC subtype "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}")) (RE2AC_TCC61-1 nil 3631872799 ("" (cases-tcc) nil nil) nil nil (RE2AC subtype "(number_fields.-)(affine_expr_Eval_fnd.newoff, 1)" "{e: naturalnumbers.nat | reals.<=(affine_expr_Eval_fnd.nextfreeidx, e)}"))) (RE2AC_TCC67 0 (RE2AC_TCC67-1 "" 3789917915 ("" (skeep*) (("" (expand "nth_ac") (("" (replaces -4) (("" (hide-all-but 7) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((nth_ac const-decl "AffineCombination" affine_box nil) (represents_var? const-decl "bool" affine nil) (length def-decl "nat" list_props nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC62-3 nil 3637352058 ("" (then (skeep*) (expand "nth_ac") (replaces -4) (hide-all-but 7) (grind)) nil nil) ((le_realorder name-judgement "RealOrder" real_orders reals) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (represents_var? const-decl "bool" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC62-2 nil 3637348807 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (("" (hide -13) (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(:(re, acRes, nwidxs):)") (("1" (expand "append" 1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("2" (lift-if "nwidxs") (("2" (split nwidxs) (("1" (with-labels (name "opn" "opn(val(cached)`1)") (("opn name"))) (("1" (hide "opn name") (("1" (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (("1" (with-labels (typepred "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("1" (expand "compatible_pairs?") (("1" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("1" (inst 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+1+opn)))") (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (skolem 1 "k") (("1" (inst "N vars in box" "k") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1 2) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace "single intervals in box" 1 :dir RL :hide? t) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skolem 1 "k") (("2" (split 1) (("1" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env" 1) (("1" (replaces "acRes") (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("1" (skolem "cached cache idx" "i") (("1" (inst "cache comp pairs on" "i") (("1" (with-labels (flatten) (("cache eval" "cache if powvar" "UNKNOWN"))) (("1" (replace "cached cache idx") (("1" (expand "eval_ACExpr_Env" "cache eval") (("1" (assert) (("1" (use "cache_powvar_correct") (("1" (replace "cached cache idx") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("1" (replace "cached as AC" "cache eval") (("1" (replace "re") (("1" (assert) (("1" (replace "cached idx re") (("1" (replace "varac" 1) (("1" (lemma "containment_pow_var_ac") (("1" (expand "eval" 1) (("1" (expand "eval" 1) (("1" (inst? -1 :where 1) (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (inst "N vars in box" "idx") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (replace -17) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "nth_ac") (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1 2) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (lemma "eval_pd_noise_rec_pds_def") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth_ac") (("2" (replace "varac" :dir RL) (("2" (flatten) (("2" (replace "nwidxs" -1 :hide? t) (("2" (use "member_append_fi[nat]") (("2" (assert) (("2" (hide -2) (("2" (split -1) (("1" (split "cached cond ok") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (replace "pownoises") (("1" (hide-all-but (-1 -2 "varac" "varac not single value")) (("1" (replaces "varac") (("1" (use "olidx_car_last[nzBaseType]") (("1" (assert) (("1" (expand "car_ol") (("1" (use "notmember_ol_nat") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (use "take_ol[nat,<]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (use "member_nats") (("2" (assert) (("2" (hide -2) (("2" (flatten) (("2" (typepred "nextfreeidx") (("2" (replace "varac") (("2" (use "last_idx_box") (("2" (expand "next_idx") (("2" (expand "last_idx") (("2" (hide-all-but (-1 -2 -3 "varac not single value")) (("2" (use "olidx_car_last[nzBaseType]") (("2" (split -1) (("1" (expand "car_ol") (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal "cache comp pairs on") (("3" (inst "cache comp pairs on" "i") (("3" (with-labels (flatten "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("3" (assert) (("3" (lemma "powvar_comp_noise_extension") (("3" (inst -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (assert) (("1" (replace "varac" -1) (("1" (replaces "cached cache idx" :dir RL) (("1" (replace "pownoises" -1) (("1" (replace "nwidxs" 1) (("1" (replace "pownoises" 1) (("1" (replace "re" (-1 1)) (("1" (replace "newoff" 1) (("1" (reveal "opn name") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace "pownoises" 1) (("2" (expand "idxs_bounded" "cache idxs bound") (("2" (inst "cache idxs bound" "i") (("2" (case "next_idx(pd(nth(cache, i)`2)) = nth(nth(cache, i)`3, opn(val(cached)`1)-2)+1") (("1" (replace -1 "cache idxs bound" :hide? t) (("1" (use "last_take_nth[nat,<]") (("1" (replace -1 1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (replace "cached cache idx") (("2" (replace "cached as AC" 1) (("2" (use "next_idx_pow_var_ac") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (replace "varac" "varac not single value") (("3" (assert) (("3" (expand "varidx_powvar") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "varidx_powvar") (("3" (replace "varac" "varac not single value") (("3" (replace "pownoises" 1) (("3" (replace "varac" 1) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "length" "varac not single value") (("4" (replace "varac") (("4" (split 1) (("1" (expand "nth_ac") (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-1 "varac not single value")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (replace "re" 1) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (reveal "varac") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac" "varac not single value")) (("4" (expand "length") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache comp pairs on" "k-1") (("2" (with-labels (flatten "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (("2" (replace "cache eval" 2 :dir RL) (("2" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 3) (("1" (skeep) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded" "cache idxs bound") (("1" (inst?) (("1" (expand "idxs_ac") (("1" (use "beyond_last_idx_notmember") (("1" (assert) (("1" (expand "next_idx") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "k=0") (("1" (replaces -1) (("1" (flatten) (("1" (expand "nth" (-1 -2)) (("1" (expand "nth" 1) (("1" (typepred "cached") (("1" (assert) (("1" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached in cache"))) (("1" (skolem "cached in cache" "j") (("1" (inst "cache comp pairs on" "j") (("1" (with-labels (flatten "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (("1" (assert) (("1" (lemma "powvar_comp_noise_extension") (("1" (inst -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") (("1" (assert) (("1" (replace "varac" -1) (("1" (replaces "cached in cache" :dir RL) (("1" (replace "pownoises" -1) (("1" (replace "cached idx re" "cached N compatible") (("1" (replace "re" "cached N compatible") (("1" (replace "nwidxs" 1) (("1" (replace "pownoises" 1) (("1" (replace "re" (-1 1)) (("1" (replace "newoff" 1) (("1" (reveal "opn name") (("1" (assert) (("1" (expand "varidx_powvar") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "pownoises" 1) (("2" (expand "idxs_bounded" "cache idxs bound") (("2" (inst "cache idxs bound" "j") (("2" (case "next_idx(pd(nth(cache, j)`2)) = nth(nth(cache, j)`3, opn(val(cached)`1)-2)+1") (("1" (replace -1 "cache idxs bound" :hide? t) (("1" (use "last_take_nth[nat,<]") (("1" (replace -1 1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (replace "cached in cache") (("2" (assert) (("2" (flatten) (("2" (replace "varac") (("2" (replace "cached idx re") (("2" (replace "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cached in cache") (("2" (use "cache_powvar_correct") (("2" (replace "cached in cache") (("2" (expand "CacheData_correct?") (("2" (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "cached as AC" 1) (("2" (use "next_idx_pow_var_ac") (("2" (replace "cached idx re" -1) (("2" (replace "re" -1) (("2" (replace "varac" "varac not single value") (("2" (assert) (("2" (replace "cached idx re" 1) (("2" (replace "re" 1) (("2" (assert) (("2" (expand "varidx_powvar") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "cache_powvar_correct") (("3" (replace "cached in cache") (("3" (expand "CacheData_correct?") (("3" (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (assert) (("3" (replace "varac" "varac not single value") (("3" (replace "cached idx re" -1) (("3" (replace "re" -1) (("3" (assert) (("3" (expand "varidx_powvar") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "cache_powvar_correct") (("3" (replace "cached in cache") (("3" (expand "CacheData_correct?") (("3" (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (("3" (assert) (("3" (replace "varac" "varac not single value") (("3" (replace "pownoises" 1) (("3" (replace "varac" 1) (("3" (replace "cached idx re" "cached cond ok") (("3" (replace "re" "cached cond ok") (("3" (assert) (("3" (expand "varidx_powvar") (("3" (assert) (("3" (flatten) (("3" (assert) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "length" "varac not single value") (("4" (assert) nil nil)) nil) ("5" (replace "re" 1) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst "cache comp pairs on" "k-1") (("1" (expand "nth" 2) (("1" (assert) (("1" (flatten) (("1" (expand "nth" (-1 -2)) (("1" (assert) (("1" (expand "pow_var_compatible?") (("1" (flatten) (("1" (skolem 2 "i") (("1" (assert) (("1" (inst "cache comp pairs on" "i") (("1" (case "get_noise_by_idx( nth(nth(cache, k - 1)`3, i)
                                           	                              , upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i: nat): (get_noise_by_idx(car(pd(varac))`1, N)^(1 + i +opn)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                      0)`1,
                                                                                                                                                                  upd_noise_burst(N,
                                                                                                                                                                                  nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                  LAMBDA
                                                                                                                                                                                  (i: nat):
                                                                                                                                                                                  (get_noise_by_idx
                                                                                                                                                                                   (car(pd(varac))`1, N)
                                                                                                                                                                                   ^
                                                                                                                                                                                   (1 + i +opn))))
                                                                                                                                                  ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                      0)`1,
                                                                                                                                                                  N)
                                                                                                                                                  ^ (2 + i)") (("1" (replaces -1) nil nil) ("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "nth_ac" -2) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (name-replace "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (("1" (use "last_idx_box") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (expand_ol) (("1" (expand "nth" -4 1) (("1" (assert) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-1 -7)) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (typepred "cached") (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -1 "cache idxs bound" :hide? t) (("2" (typepred "i") (("2" (hide-all-but (-1 -5 "cache idxs bound")) (("2" (expand ">=") (("2" (case "i = opn(nth(cache, k - 1)`1) - 2") (("1" (replaces -1) (("1" (hide -1) (("1" (assert) nil nil)) nil)) nil) ("2" (case "i < opn(nth(cache, k - 1)`1) - 2") (("1" (hide -2) (("1" (lemma "nth_ol[nat,<]") (("1" (inst -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "i") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (assert) (("3" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "opn >= 2")) (("4" (skeep) (("4" (reveal "opn name") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (hide-all-but (1 "varac not single value")) (("5" (expand "length") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "k") (("2" (hide-all-but (-1 1 2)) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "opn >= 2")) (("3" (skeep) (("3" (reveal "opn name") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (flatten "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (("2" (with-labels (typepred "cache") (("correct cache" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (expand "compatible_pairs?") (("2" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (inst 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(2+i)))") (("1" (split 2) (("1" (expand "vars_in_box_compatible?") (("1" (skolem 1 "k") (("1" (inst "N vars in box" "k") (("1" (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces "single intervals in box" 1 :dir RL) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "k") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skolem 1 "k") (("2" (split 1) (("1" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env" 1) (("1" (replaces "acRes") (("1" (expand "eval") (("1" (lemma "containment_pow_var_ac") (("1" (expand "eval" 1) (("1" (replace "re" 1) (("1" (assert) (("1" (inst -1 "upd_noise_burst(N,
                                                                                                                        nats(nextfreeidx, newoff - 1),
                                                                                                                        LAMBDA
                                                                                                                        (i: nat):
                                                                                                                        (get_noise_by_idx(car(pd(varac))`1, N)
                                                                                                                         ^
                                                                                                                         (2+i)))" "vs(varidx(re1))" "varac" "pow" "nwidxs") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (inst "N vars in box" "idx") (("1" (replace "varac" 1) (("1" (expand "nth_ac" 1) (("1" (with-labels (flatten "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (("1" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 2) (("1" (skolem 1 "j") (("1" (flatten) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (use "last_idx_box") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (reveal "varac") (("2" (replaces "varac") (("2" (expand "nth_ac") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "varac") (("3" (expand "length") (("3" (expand "nth_ac") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replaces "nwidxs" -1) (("2" (use "member_nats") (("2" (assert) (("2" (flatten) (("2" (replaces "varac") (("2" (typepred "nextfreeidx") (("2" (use "last_idx_box") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "pow_var_compatible_noise") (("1" (assert) nil nil) ("2" (replaces "varac") (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value" "varac")) (("2" (replaces "varac") (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value" "varac")) (("3" (replaces "varac") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache comp pairs on" "k-1") (("2" (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (replaces "eval cache" 2 :dir RL) (("2" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 3) (("1" (skolem 1 "i") (("1" (flatten) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (lemma "beyond_last_idx_notmember") (("1" (inst -1 "i" "pd(nth(cache, k - 1)`2)") (("1" (assert) (("1" (expand "idxs_ac") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value" "varac")) (("2" (replaces "varac") (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value" "varac")) (("3" (replaces "varac") (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "k=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "re" 1) (("1" (assert) (("1" (use "pow_var_compatible_noise") (("1" (replaces "nwidxs") (("1" (replaces "varac") (("1" (expand "powvar?") (("1" (expand "varidx_powvar") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nth_ac") (("2" (replaces "varac") (("2" (hide-all-but (1 "varac not single value")) (("2" (expand "varidx_powvar") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (expand "varidx_powvar") (("2" (assert) (("2" (flatten) (("2" (inst "cache comp pairs on" "k-1") (("2" (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (("2" (assert) (("2" (expand "pow_var_compatible?") (("2" (flatten) (("2" (assert) (("2" (skolem 2 "j") (("2" (inst "cache if powvar" "j") (("2" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                              0)`1,
                                                                                                                                          upd_noise_burst(N,
                                                                                                                                                          nats(nextfreeidx, newoff - 1),
                                                                                                                                                          LAMBDA
                                                                                                                                                          (i: nat):
                                                                                                                                                          (get_noise_by_idx
                                                                                                                                                           (car(pd(varac))`1, N)
                                                                                                                                                           ^
                                                                                                                                                           (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                              0)`1,
                                                                                                                                          N)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                     upd_noise_burst(N,
                                                                                                                                                                     nats(nextfreeidx, newoff - 1),
                                                                                                                                                                     LAMBDA
                                                                                                                                                                     (i: nat):
                                                                                                                                                                     (get_noise_by_idx
                                                                                                                                                                      (car(pd(varac))`1, N)
                                                                                                                                                                      ^
                                                                                                                                                                      (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                     N)") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst?) (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (replace -1 "cache idxs bound" :hide? t) (("2" (typepred "j") (("2" (hide-all-but (-1 -5 "cache idxs bound")) (("2" (expand ">=") (("2" (case "j = opn(nth(cache, k - 1)`1) - 2 ") (("1" (hide -2) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil) ("2" (case "j < opn(nth(cache, k - 1)`1) - 2") (("1" (hide (-2 1)) (("1" (lemma "nth_ol[nat,<]") (("1" (inst -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "j") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "nth_ac" -2) (("1" (expand "idxs_bounded") (("1" (inst "cache idxs bound" "k-1") (("1" (expand "next_idx") (("1" (name-replace "somevidx" "varidx(nth(cache, k - 1)`1)") (("1" (use "last_idx_box") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (use "olidx_car_last[nzBaseType]") (("1" (expand_ol) (("1" (expand "nth" -4 1) (("1" (assert) (("1" (expand "nth_ac") (("1" (assert) (("1" (expand "varidx_powvar") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replaces -17) (("2" (expand "varidx_powvar") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil) ("5" (expand "varidx_powvar") (("5" (assert) nil nil)) nil) ("6" (expand "varidx_powvar") (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace "newoff" 1) (("3" (expand ">=") (("3" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (1 -1)) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("4" (replace "newoff" 1) (("4" (expand "idxs_bounded" 1) (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replace "acRes" 1) (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (replace "nwidxs" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (case "pow - 1 = opn(val(cached)`1)") (("1" (replace -1 1 :dir RL) (("1" (assert) (("1" (case "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                             nats(nextfreeidx, newoff - 1)),
                                                                                                                      pow - 2) = nextfreeidx") (("1" (assert) nil nil) ("2" (hide 2) (("2" (use "nth_append[nat]") (("1" (replaces -1 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "length(pownoises) = pow - 2") (("1" (replaces -1 2) (("1" (grind) nil nil)) nil) ("2" (case "length(pownoises) > opn(val(cached)`1) - 2") (("1" (assert) nil nil) ("2" (replace "pownoises" 1) (("2" (typepred "cached") (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (replace "cached" "cached correct" :dir RL) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "varac" "varac not single value") (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (grind) nil nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (replace -1 1) (("2" (use "length_take[nat]") (("2" (replace -1 1) (("2" (expand "min") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (replace "pownoises" 1) (("2" (hide -1 -2) (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (skolem "cached cache idx" "j") (("2" (replace "cached cache idx" :dir RL) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) (("2" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "cached idx re" "cached cond ok") (("2" (replace "re" "cached cond ok") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "nth_append[nat]") (("1" (replaces -1 2) (("1" (case "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                 pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") (("1" (replaces -1 2) (("1" (replace "newoff" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (case "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") (("1" (replaces -1 1) (("1" (replaces "newoff" 1) (("1" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("1" (inst? -5) (("1" (replace -5 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil) ("2" (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") (("1" (split 1) (("1" (replaces -1 1) (("1" (assert) nil nil)) nil) ("2" (use "length_append[nat]") (("1" (replaces -1 1) (("1" (use "length_take[nat]") (("1" (replaces -1 1) (("1" (expand "min") (("1" (lift-if 1) (("1" (split 1) (("1" (assert) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (typepred "cached") (("2" (assert) (("2" (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (("2" (skolem "cached cache idx" "j") (("2" (replace "cached cache idx" :dir RL) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) (("2" (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (("2" (replace "varac") (("2" (replace "cached idx re" "cached cond ok") (("2" (replace "re") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (use "length_take[nat]") (("1" (replace -1 1) (("1" (expand "min" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (replaces "pownoises" 1) (("2" (use "cache_powvar_correct_result") (("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (with-labels (assert) (("cached correct"))) (("2" (expand "CacheData_correct?" "cached correct") (("2" (typepred "cached") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (replace "cached" "cached correct" :dir RL) (("2" (replace -2 "cached correct") (("2" (replace "re" "cached correct") (("2" (assert) (("2" (expand "varidx_powvar") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace "newoff" 2) (("2" (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (("2" (inst? -5) (("2" (replaces -5 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (("2" (expand "idxs_bounded" "cache idxs bounded") (("2" (expand "nth" 2) (("2" (assert) (("2" (inst "cache idxs bounded" "i-1") (("2" (expand ">=") (("2" (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") (("1" (replaces -1) (("1" (case "0 < pow - opn(val(cached)`1)") (("1" (hide-all-but (-1 2 "cache idxs bounded")) (("1" (name-replace "A" "pow - opn(val(cached)`1)") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (RE2AC subtype "affine_expr_Eval_fnd.varac" "(affine.represents_var?)")) (RE2AC_TCC62-1 nil 3632064917 ("" (subtype-tcc) nil nil) ((Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Env type-eq-decl nil affine_box nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (next_idx const-decl "nat" affine nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.varac" "(affine.represents_var?)"))) (RE2AC_TCC68 0 (RE2AC_TCC63-2 nil 3767021364 ("" (skeep*) (("" (replaces -7) (("" (typepred "nats(nextfreeidx, newoff - 1)") (("1" (replaces -4) (("1" (split 8) (("1" (replaces -10) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (expand "car_ol") (("2" (replaces -3) (("2" (expand "next_idx") (("2" (use "last_idx_box") (("2" (replaces -8) (("2" (expand "next_idx") (("2" (typepred "nextfreeidx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -6) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (last_idx_box formula-decl nil affine_box nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (next_idx const-decl "nat" affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (= const-decl "[T, T -> boolean]" equalities nil) (car_ol const-decl "T" ordered_list structures) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (> const-decl "bool" reals nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.nwidxs" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}")) (RE2AC_TCC63-1 nil 3632064917 ("" (then (skeep*) (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (with-labels (split "not in cache 1") (("pow gt opn cached`1"))) (spread (with-labels (split "not in cache 2") (("pow gt opn cached`1"))) ((then (expand "/=") (propax)) (then (replaces "nwidxs" 7) (spread (split 7) ((then (use "cache_powvar_correct_result") (with-labels (assert) (("cached correct"))) (replace "cached" "cached correct" :dir RL) (expand "CacheData_correct?" "cached correct") (typepred "cached") (assert) (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (assert) (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (spread (split "cached cond ok") ((spread (split "cached correct") ((then (flatten) (spread (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") ((then (typepred "nwidxs2") (expand "append_ol") (assert)) (then (expand "appendable_ol?") (flatten) (spread (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") ((then (replaces -1 3) (spread (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") ((then (replace -1 3 :hide? t) (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (skeep "cached cache idx") (hide 4) (replace "pownoises" 1) (replace "cached cache idx" 1 :dir RL) (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (expand "idxs_bounded") (expand "nth_ac") (replace "pownoises") (inst "cache correct" "i") (replace "cached`2 is powvarac") (use "next_idx_pow_var_ac") (replaces -1) (grind)) (then (hide-all-but (1 3 "cached correct" "pow gt opn cached`1")) (replaces -2 1) (expand "nats" 1) (lift-if 1) (spread (split 1) ((grind) (then (flatten) (expand_ol) (expand "first_ol") (propax)))))))) (spread (use "last_take_nth[nat,<]") ((assert) (assert))) (assert) (assert)))) (then (use "take_ol[nat,<]") (assert)) (assert)))) (propax))) (then (replace "cached`1 varidx" "cached cond ok") (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (grind))))) (then (lift-if 1) (spread (split 1) ((then (flatten) (spread (split 1) ((spread (use "length_append[nat]") ((then (replaces -1) (spread (typepred "nats(nextfreeidx, newoff - 1)") ((then (replaces -4 2) (spread (use "length_take[nat]") ((then (replaces -1 2) (spread (case "length(pownoises) > opn(val(cached)`1) - 2") ((then (expand "min" 2) (lift-if 2) (spread (case "length(pownoises) = opn(val(cached)`1) - 1") ((assert) (assert)))) (then (replace "pownoises" 1) (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (use "cache_powvar_correct_result") (with-labels (assert) (("cached correct"))) (replace "cached" "cached correct" :dir RL) (expand "CacheData_correct?" "cached correct") (typepred "cached") (assert) (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (assert) (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (replace "cached`1 varidx" "cached cond ok") (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (grind))))) (assert)))) (assert)))) (assert) (assert))) (then (flatten) (replace "pownoises" 2) (with-labels (typepred "cache") (("cache compatible pairs" "cache idxs bounded" "cache correct" "UNKNOWN"))) (use "cache_powvar_correct_result") (with-labels (assert) (("cached correct"))) (replace "cached" "cached correct" :dir RL) (expand "CacheData_correct?" "cached correct") (typepred "cached") (assert) (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (assert) (with-labels (flatten) (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (replace "cached`1 varidx" "cached cond ok") (spread (split "cached cond ok") ((then (flatten) (replaces "varac" 2) (replace "re" "cached cond ok") (assert) (spread (case "car[nat]
                                                                                                   (append(take[nat](val(cached)`3, opn(val(cached)`1) - 2 + 1),
                                                                                                           nats(nextfreeidx, newoff - 1))) = car(val(cached)`3)") ((then (replaces -1) (assert) (grind)) (then (expand "take" 1) (expand "append" 1) (propax)) (grind)))) (then (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (grind)))))))) (then (flatten) (spread (split 2) ((spread (typepred "nats(nextfreeidx, newoff - 1)") ((then (replace -4 2) (replace "newoff" 2) (assert)) (assert))) (then (flatten) (expand "nats" 2) (replace "newoff" 2) (lift-if 2) (spread (split 2) ((then (flatten) (assert) (replace "varac" 1) (typepred "nextfreeidx") (use "last_idx_box") (assert)) (then (flatten) (expand_ol) (replace "varac" 2) (typepred "nextfreeidx") (use "last_idx_box") (assert))))))))))))))))) nil nil) ((last_idx_box formula-decl nil affine_box nil) (length_take formula-decl nil more_list_props structures) (powvar? const-decl "bool" affine_expr nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (varidx_powvar const-decl "nat" affine_expr nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (appendable_ol? const-decl "bool" ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (take def-decl "list[T]" more_list_props structures) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (last_take_nth formula-decl nil ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (var_ac const-decl "AffineCombination" affine nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (idxs_ac const-decl "list[nat]" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (idxs_pd def-decl "list[nat]" affine nil) (last_idx const-decl "int" indexed_list structures) (first_ol const-decl "T" ordered_list structures) (last_ol def-decl "T" ordered_list structures) (take_ol formula-decl nil ordered_list structures) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.nwidxs" "{idxs: ordered_list[nat, restrict[[real, real], [nat, nat], booleans.bool].restrict(reals.<)].ordered_list | booleans.OR((booleans.AND(reals.>(list_props[nat].length(idxs), (number_fields.-)(affine_expr_Eval_fnd.pow, 2)), (booleans.IMPLIES((booleans.NOT)(list_adt[nat].null?(idxs)), reals.>=(list_adt[nat].car(idxs), affine.next_idx(pd(affine_expr_Eval_fnd.varac))))))), list_props[[nat, nzBaseType]].length(pd(affine_expr_Eval_fnd.varac)) = 0)}"))) (RE2AC_TCC69 0 (RE2AC_TCC69-1 "" 3803769691 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -4) (label "cached" -5) (label "newoff" -6) (label "nwidxs" -7) (label "acRes" -8) (label "result" -9) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 6) (label "not in cache 2" 5) (label "not in cache 1" 4))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (expand "correct_cache?") (("1" (expand "CacheData_correct?") (("1" (expand "powvar?") (("1" (expand "varidx_powvar") (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (replaces "nwidxs" 2) (("1" (expand "nats" 2) (("1" (lift-if 2) (("1" (split 2) (("1" (assert) (("1" (flatten) (("1" (replaces -1 1 :dir RL) (("1" (use "last_idx_box") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (use "last_idx_box") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff") (("2" (hide-all-but (1 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow-1)") (("1" (replaces -1) (("1" (case "0<=pow - 1") (("1" (name-replace "A" "pow -1 ") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC64-3 nil 3767021404 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached" -5) (label "newoff" -6) (label "nwidxs" -7) (label "acRes" -8) (label "result" -9) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (expand "correct_cache?") (("1" (expand "CacheData_correct?") (("1" (expand "powvar?") (("1" (expand "varidx_powvar") (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (replaces "nwidxs" 2) (("1" (expand "nats" 2) (("1" (lift-if 2) (("1" (split 2) (("1" (assert) (("1" (flatten) (("1" (replaces -1 1 :dir RL) (("1" (use "last_idx_box") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (use "last_idx_box") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff") (("2" (hide-all-but (1 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow-1)") (("1" (replaces -1) (("1" (case "0<=pow - 1") (("1" (name-replace "A" "pow -1 ") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (powvar? const-decl "bool" affine_expr nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial reals) (cdr_ol const-decl "ordered_list" ordered_list structures) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nat_expt application-judgement "nat" exponentiation nil) (int_times_even_is_even application-judgement "even_int" integers nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth def-decl "T" list_props nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (last_idx_box formula-decl nil affine_box nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC64-2 nil 3632080211 ("" (then (skeep*) (assert) (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (replaces "result") (assert) (spread (split 7) ((then (expand "every") (spread (split 1) ((then (replace "nwidxs" 1) (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bound" "UNKNOWN"))) (use "cache_powvar_correct_result") (with-labels (assert (-1 "cache correct")) (("cached correct"))) (replace "cached" "cached correct" :dir RL) (expand "CacheData_correct?" "cached correct") (typepred "cached") (assert) (with-labels (flatten) (("cached`1 is powvar" "cached`1 varidx" "cached cache idx" "UNKNOWN"))) (assert) (with-labels (flatten "cached correct") (("cached idx in box" "cached cond ok" "cached`2 is powvarac" "UNKNOWN"))) (spread (split "cached cond ok") ((spread (split 1) ((then (flatten) (spread (name "nwidxs2" "append_ol[nat,<](take[nat](pownoises, opn(val(cached)`1) - 2+1), nats(nextfreeidx, newoff - 1))") ((then (typepred "nwidxs2") (expand "append_ol") (assert)) (then (expand "appendable_ol?") (flatten) (spread (case "last_ol[nat,<](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = nth(pownoises,  opn(val[CacheData](cached)`1) - 2)") ((then (replaces -1 3) (spread (case "first_ol[nat,<](nats(nextfreeidx, newoff - 1)) = nextfreeidx") ((then (replaces -1 3) (skeep "cached cache idx") (replace "pownoises" 1) (replace "cached cache idx" 1 :dir RL) (expand "idxs_bounded" "cache idxs bound") (inst "cache idxs bound" "i") (replace "cached cache idx" "cached`2 is powvarac" :dir RL) (replace "cached`2 is powvarac" "cache idxs bound") (use "next_idx_pow_var_ac") (replaces -1) (lift-if "cache idxs bound") (spread (split "cache idxs bound") ((then (assert) (replace "varac" "varac not single value") (replace "cached cache idx" "cache idxs bound") (replace "cached`1 varidx" "cache idxs bound") (replace "re") (assert) (grind)) (then (with-labels (flatten "cache idxs bound") (("opn not 0" "varac not single value" "cache idxs bound" "UNKNOWN"))) (spread (split "cache idxs bound") ((then (flatten) (ground)) (then (with-labels (flatten "cache idxs bound") (("opn not 1" "cache idxs bound" "UNKNOWN"))) (expand ">=") (replace "pownoises" 6) (replace "cached cache idx" 6 :dir RL) (hide-all-but ("cache idxs bound" 6)) (assert)))))))) (then (hide-all-but (1 3 5 -1 "pow gt opn" "opw gt opn")) (expand "nats" 1) (lift-if 1) (spread (split 1) ((grind) (then (flatten) (expand_ol) (expand "first_ol") (propax))))) (spread (use "last_take_nth[nat,<]") ((assert) (assert)))))) (spread (use "last_take_nth[nat,<]") ((assert) (assert))) (assert) (assert)))) (assert) (then (use "take_ol[nat,<]") (assert)) (assert)))) (propax))) (then (replace "cached`1 varidx" "cached cond ok") (hide-all-but ("varac" "varac not single value" "cached cond ok" "re")) (grind))))) (then (hide-all-but 1) (typepred "cache") (generalize "cache" "cache") (spread (induct "cache") ((grind) (then (skolem 1 ("h" "t")) (flatten) (expand "every" 1) (spread (split 1) ((then (typepred "h`3") (assert)) (spread (split -1) ((propax) (then (expand "correct_cache?" -1) (flatten)) (then (expand "compatible_pairs?") (skeep) (inst?) (assert) (expand "compatible_pairs_on?") (skeep) (expand "nth" -3) (spread (inst -3 "i+1") ((assert) (then (typepred "i") (assert) (grind))))) (then (expand "idxs_bounded") (skeep) (expand "nth" -3) (spread (inst -3 "i+1") ((assert) (then (typepred "i") (grind))))) (then (expand "correct_cache?" -1) (flatten)) (then (expand "compatible_pairs?") (skeep) (inst?) (assert) (expand "compatible_pairs_on?") (skeep) (expand "nth" -3) (spread (inst -3 "i+1") ((assert) (then (typepred "i") (assert) (grind))))) (then (expand "idxs_bounded") (skeep) (expand "nth" -3) (spread (inst -3 "i+1") ((assert) (then (typepred "i") (grind)))))))))))))))) (then (expand "correct_cache?") (expand "CacheData_correct?") (replace "re" 1) (assert) (lift-if "nwidxs") (spread (split "nwidxs") ((then (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (replace "nwidxs" 1) (expand "powvar?") (expand "varidx_powvar") (spread (split 1) ((spread (use "length_append[nat]") ((then (replaces -1 1) (spread (with-labels (typepred "nats(nextfreeidx, newoff - 1)") (("nats list[nat]" "nats ol" "nats not null" "nats car" "nats length" "nats i") ("newoff >= 1"))) ((then (replaces "nats length" 2) (spread (case "length[nat](take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") ((then (replaces -1 2) (replace "newoff" 2) (assert)) (spread (use "length_take[nat]") ((then (replaces -1 1) (expand "min") (lift-if 1) (spread (split 1) ((propax) (then (flatten) (replace "pownoises") (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (use "cache_powvar_correct_result") (with-labels (assert -1) (("cached correct"))) (replace "cached" "cached correct" :dir RL) (expand "CacheData_correct?" "cached correct") (typepred "cached") (assert) (flatten) (assert) (flatten) (replace -2 "cached correct") (replace "re" "cached correct") (assert) (hide -3 "nats i") (expand "varidx_powvar") (assert))))) (assert))) (assert)))) (assert)))) (assert) (assert))) (then (flatten) (spread (case "car(append(take[nat](pownoises, opn(val(cached)`1) - 1),
                                                                                      nats(nextfreeidx, newoff - 1))) = car(pownoises)") ((then (replaces -1 2) (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (use "cache_powvar_correct_result") (with-labels (assert -1) (("cached correct"))) (replace "cached" "cached correct" :dir RL) (expand "CacheData_correct?" "cached correct") (typepred "cached") (assert) (flatten) (assert) (flatten) (spread (split "cached correct") ((then (flatten) (spread (split -2) ((then (replace -4 "cached correct") (replace "re" "cached correct") (assert) (grind)) (then (expand "length") (assert))))) (then (replace "varac" "varac not single value") (replace -3 "cached correct") (replace "re" "cached correct") (assert) (grind))))) (then (expand "append" 1) (lift-if 1) (spread (split 1) ((then (flatten) (expand "take" -1) (spread (case "length(pownoises) >= opn(val(cached)`1) - 1") ((assert) (then (hide -1) (replace "pownoises" 1) (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (use "cache_powvar_correct_result") (with-labels (assert) (("cached correct"))) (replace "cached" "cached correct" :dir RL) (expand "CacheData_correct?" "cached correct") (typepred "cached") (assert) (flatten) (assert) (flatten) (replace "varac" "varac not single value") (replace -2 "cached correct") (replace "re" "cached correct") (assert) (grind))))) (then (flatten) (assert) (expand "take" 2) (spread (case "length(pownoises) >= opn(val(cached)`1) - 1") ((assert) (then (replace "pownoises" 1) (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (use "cache_powvar_correct_result") (with-labels (assert) (("cached correct"))) (replace "cached" "cached correct" :dir RL) (expand "CacheData_correct?" "cached correct") (typepred "cached") (assert) (flatten) (assert) (flatten) (replace "varac" "varac not single value") (replace -2 "cached correct") (replace "re" "cached correct") (assert) (grind)))))))) (then (replace "pownoises" 1) (with-labels (typepred "cache") (("cache correct" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (use "cache_powvar_correct_result") (with-labels (assert) (("cached correct"))) (replace "cached" "cached correct" :dir RL) (expand "CacheData_correct?" "cached correct") (typepred "cached") (assert) (flatten) (assert) (flatten) (spread (split "cached correct") ((then (expand "length") (assert)) (then (replace "varac" "varac not single value") (replace -3 "cached correct") (replace "re" "cached correct") (assert) (grind))))) (assert) (assert)))) (then (replaces "varac") (replaces "idx") (assert))))) (then (flatten) (replace -1 2) (spread (split 2) ((spread (typepred "nats(nextfreeidx, newoff - 1)") ((then (expand "varidx_powvar") (assert)) (assert))) (then (flatten) (spread (typepred "nats(nextfreeidx, newoff - 1)") ((spread (inst -5 "0") ((then (expand "nth") (typepred "nextfreeidx") (use "last_idx_box") (assert)) (then (replace -4 1) (replace "newoff" 1) (assert)))) (assert)))) (then (replaces "varac") (expand "varidx_powvar") (replaces -5) (assert)))))))) (then (replaces "newoff") (hide-all-but (1 "pow gt opn" "opw gt opn")) (spread (case "opn(val(cached)`1) < pow") ((then (hide "pow gt opn" "opw gt opn") (spread (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") ((then (replaces -1) (spread (case "0 <= pow - opn(val(cached)`1)") ((then (name-replace "A" "pow - opn(val(cached)`1)") (assert)) (assert)))) (assert)))) (assert))))))) nil nil) ((gt_realorder name-judgement "RealOrder" real_orders reals) (last_idx_box formula-decl nil affine_box nil) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (length_take formula-decl nil more_list_props structures) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (Noise type-eq-decl nil affine nil) (powvar? const-decl "bool" affine_expr nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (varidx_powvar const-decl "nat" affine_expr nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (appendable_ol? const-decl "bool" ordered_list structures) (append_ol const-decl "ordered_list" ordered_list structures) (take def-decl "list[T]" more_list_props structures) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (last_take_nth formula-decl nil ordered_list structures) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (nzBaseType type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (next_idx const-decl "nat" affine nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (idxs_ac const-decl "list[nat]" affine nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (last_idx const-decl "int" indexed_list structures) (first_ol const-decl "T" ordered_list structures) (last_ol def-decl "T" ordered_list structures) (take_ol formula-decl nil ordered_list structures) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC64-1 nil 3632064917 ("" (subtype-tcc) nil nil) nil nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC70 0 (RE2AC_TCC70-1 "" 3803770723 ("" (skeep*) (("" (assert) (("" (hide -10) (("" (apply (then (label "re" -1) (label "varac" -4) (label "cached" -5) (label "newoff" -6) (label "nwidxs" -7) (label "acRes" -8) (label "result" -9) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 6) (label "not in cache 2" 5) (label "not in cache 1" 4))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(: (re, acRes, nwidxs) :)") (("1" (grind) nil nil)) nil) ("2" (with-labels (typepred "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (expand "compatible_pairs?") (("2" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (inst 1 "upd_noise_burst(N, nwidxs, LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (skeep) (("1" (inst "N vars in box" "i_1") (("1" (with-labels (flatten) (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "i_1") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (hide-all-but (1 "pow <= 1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1 1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces "single intervals in box" 1 :dir RL) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "i_1") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (expand "powvar?") (("2" (skeep* 1) (("2" (case "i_1=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "varidx_powvar") (("1" (expand "eval_ACExpr_Env" 1) (("1" (expand "eval" 1) (("1" (expand "vars_in_box_compatible?") (("1" (inst "N vars in box" "idx") (("1" (flatten) (("1" (expand "eval" 1) (("1" (replace -7 :dir RL) (("1" (replace "N vars in box" 1 :dir RL) (("1" (replace "acRes" 1) (("1" (split 1) (("1" (use "containment_pow_var_ac") (("1" (assert) (("1" (split 1) (("1" (hide 2) (("1" (replaces "varac") (("1" (expand "nth_ac") (("1" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 2) (("1" (skolem 1 "k") (("1" (flatten) (("1" (use "idxs_ac_var_ac") (("1" (assert) (("1" (replaces -1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flatten) (("2" (replaces "nwidxs" -1) (("2" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (expand ">") (("1" (replaces "varac") (("1" (use "last_idx_box") (("1" (expand ">=") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (expand "last_ol") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (use "pow_var_compatible_noise") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (use "pow_var_compatible_noise") (("1" (replace "varac" 1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst "cache comp pairs on" "i_1 -1 ") (("1" (inst "cache comp pairs on" "n") (("1" (expand "nth" 2) (("1" (assert) (("1" (flatten) (("1" (replaces "cache comp pairs on" 2 :dir RL) (("1" (split 2) (("1" (use "eval_updb_no_idxs") (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "idxs_bounded") (("2" (inst "cache idxs bound" "i_1 - 1") (("2" (expand "idxs_ac") (("2" (expand "next_idx") (("2" (use "beyond_last_idx_notmember") (("2" (assert) (("2" (replaces "nwidxs" -1) (("2" (use "member_nats") (("1" (assert) nil nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "pow_var_compatible?") (("2" (flatten) (("2" (assert) (("2" (skeep) (("2" (inst?) (("2" (case "get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                                                                                                                                                          upd_noise_burst(N,
                                                                                                                                                                                                          nwidxs,
                                                                                                                                                                                                          LAMBDA
                                                                                                                                                                                                          (i: nat):
                                                                                                                                                                                                          (get_noise_by_idx
                                                                                                                                                                                                           (car(pd(varac))`1, N)
                                                                                                                                                                                                           ^
                                                                                                                                                                                                           (2 + i)))) = get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                                                                                                                                                          N)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))),
                                                                                                                                                                                                                 0)`1,
                                                                                                                                                                                                             upd_noise_burst(N,
                                                                                                                                                                                                                             nwidxs,
                                                                                                                                                                                                                             LAMBDA
                                                                                                                                                                                                                             (i: nat):
                                                                                                                                                                                                                             (get_noise_by_idx
                                                                                                                                                                                                                              (car(pd(varac))`1, N)
                                                                                                                                                                                                                              ^
                                                                                                                                                                                                                              (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))),
                                                                                                                                                                                                                 0)`1,
                                                                                                                                                                                                             N)") (("1" (replaces -1) nil nil) ("2" (hide 2) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replace "nwidxs" -1) (("1" (expand "nth" -1 1) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (lemma "last_idx_box") (("1" (inst? -1 :where -2) (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (case "NOT null?(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))))") (("1" (assert) (("1" (lemma "olidx_car_last[nzBaseType]") (("1" (inst? -1 :where 1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (assert) (("1" (expand "car_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (hide "cache comp pairs on") (("1" (replace "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst? "cache idxs bound") (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (expand "powvar?") (("1" (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand ">=") (("2" (replace -1 "cache idxs bound") (("2" (typepred "i_2") (("2" (hide-all-but (-6 -1 "cache idxs bound")) (("2" (case "i_2 = opn(nth(cache, i_1 - 1)`1) - 2") (("1" (hide -2) (("1" (replaces -1 :dir RL) (("1" (assert) nil nil)) nil)) nil) ("2" (case "i_2 < opn(nth(cache, i_1 - 1)`1) - 2") (("1" (hide -2 1) (("1" (lemma "nth_ol[nat,<]") (("1" (inst -1 "nth(cache, i_1-1)`3" "opn(nth(cache, i_1-1)`1) - 2" "i_2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (use "power_Epsilon_is_Epsilon") (("3" (assert) (("3" (expand "length") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i_1") (("2" (hide-all-but (-1 1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "newoff") (("3" (expand ">=") (("3" (hide-all-but (1 "pow <= 1")) (("3" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (typepred "cache") (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replaces "acRes") (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nwidxs") (("1" (case "length(nwidxs)=0") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replaces "newoff") (("2" (assert) (("2" (expand ">=") (("2" (replaces "nwidxs") (("2" (typepred "nats(nextfreeidx, nextfreeidx - 2 + pow)") (("2" (inst -5 "pow-2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) (("2" (replaces "newoff") (("2" (hide-all-but (2 -3 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC65-3 nil 3767021668 ("" (skeep*) (("" (assert) (("" (hide -10) (("" (apply (then (label "re" -2) (label "varac" -4) (label "cached" -5) (label "newoff" -6) (label "nwidxs" -7) (label "acRes" -8) (label "result" -9) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(: (re, acRes, nwidxs) :)") (("1" (grind) nil nil)) nil) ("2" (with-labels (typepred "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (expand "compatible_pairs?") (("2" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (inst 1 "upd_noise_burst(N, nwidxs, LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (skeep) (("1" (inst "N vars in box" "i_1") (("1" (with-labels (flatten) (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "i_1") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (hide-all-but (1 "pow <= 1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1 1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces "single intervals in box" 1 :dir RL) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "i_1") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (expand "powvar?") (("2" (skeep* 1) (("2" (case "i_1=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "varidx_powvar") (("1" (expand "eval_ACExpr_Env" 1) (("1" (expand "eval" 1) (("1" (expand "vars_in_box_compatible?") (("1" (inst "N vars in box" "idx") (("1" (flatten) (("1" (expand "eval" 1) (("1" (replace -7 :dir RL) (("1" (replace "N vars in box" 1 :dir RL) (("1" (replace "acRes" 1) (("1" (split 1) (("1" (use "containment_pow_var_ac") (("1" (assert) (("1" (split 1) (("1" (hide 2) (("1" (replaces "varac") (("1" (expand "nth_ac") (("1" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 2) (("1" (skolem 1 "k") (("1" (flatten) (("1" (use "idxs_ac_var_ac") (("1" (assert) (("1" (replaces -1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flatten) (("2" (replaces "nwidxs" -1) (("2" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (expand ">") (("1" (replaces "varac") (("1" (use "last_idx_box") (("1" (expand ">=") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (expand "last_ol") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (use "pow_var_compatible_noise") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (use "pow_var_compatible_noise") (("1" (replace "varac" 1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst "cache comp pairs on" "i_1 -1 ") (("1" (inst "cache comp pairs on" "n") (("1" (expand "nth" 2) (("1" (assert) (("1" (flatten) (("1" (replaces "cache comp pairs on" 2 :dir RL) (("1" (split 2) (("1" (use "eval_updb_no_idxs") (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "idxs_bounded") (("2" (inst "cache idxs bound" "i_1 - 1") (("2" (expand "idxs_ac") (("2" (expand "next_idx") (("2" (use "beyond_last_idx_notmember") (("2" (assert) (("2" (replaces "nwidxs" -1) (("2" (use "member_nats") (("1" (assert) nil nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "pow_var_compatible?") (("2" (flatten) (("2" (assert) (("2" (skeep) (("2" (inst?) (("2" (case "get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                                                                                                                                       upd_noise_burst(N,
                                                                                                                                                                                       nwidxs,
                                                                                                                                                                                       LAMBDA
                                                                                                                                                                                       (i: nat):
                                                                                                                                                                                       (get_noise_by_idx
                                                                                                                                                                                        (car(pd(varac))`1, N)
                                                                                                                                                                                        ^
                                                                                                                                                                                        (2 + i)))) = get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                                                                                                                                       N)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))),
                                                                                                                                                                                            0)`1,
                                                                                                                                                                                        upd_noise_burst(N,
                                                                                                                                                                                                        nwidxs,
                                                                                                                                                                                                        LAMBDA
                                                                                                                                                                                                        (i: nat):
                                                                                                                                                                                                        (get_noise_by_idx
                                                                                                                                                                                                         (car(pd(varac))`1, N)
                                                                                                                                                                                                         ^
                                                                                                                                                                                                         (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))),
                                                                                                                                                                                            0)`1,
                                                                                                                                                                                        N)") (("1" (replaces -1) nil nil) ("2" (hide 2) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replace "nwidxs" -1) (("1" (expand "nth" -1 1) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (lemma "last_idx_box") (("1" (inst? -1 :where -2) (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (case "NOT null?(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))))") (("1" (assert) (("1" (lemma "olidx_car_last[nzBaseType]") (("1" (inst? -1 :where 1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (assert) (("1" (expand "car_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (hide "cache comp pairs on") (("1" (replace "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst? "cache idxs bound") (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (expand "powvar?") (("1" (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand ">=") (("2" (replace -1 "cache idxs bound") (("2" (typepred "i_2") (("2" (hide-all-but (-6 -1 "cache idxs bound")) (("2" (case "i_2 = opn(nth(cache, i_1 - 1)`1) - 2") (("1" (hide -2) (("1" (replaces -1 :dir RL) (("1" (assert) nil nil)) nil)) nil) ("2" (case "i_2 < opn(nth(cache, i_1 - 1)`1) - 2") (("1" (hide -2 1) (("1" (lemma "nth_ol[nat,<]") (("1" (inst -1 "nth(cache, i_1-1)`3" "opn(nth(cache, i_1-1)`1) - 2" "i_2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("2" (assert) (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (use "power_Epsilon_is_Epsilon") (("3" (assert) (("3" (expand "length") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i_1") (("2" (hide-all-but (-1 1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "newoff") (("3" (expand ">=") (("3" (hide-all-but (1 "pow <= 1")) (("3" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (typepred "cache") (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replaces "acRes") (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nwidxs") (("1" (case "length(nwidxs)=0") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replaces "newoff") (("2" (assert) (("2" (expand ">=") (("2" (replaces "nwidxs") (("2" (typepred "nats(nextfreeidx, nextfreeidx - 2 + pow)") (("2" (inst -5 "pow-2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) (("2" (replaces "newoff") (("2" (hide-all-but (2 -3 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (append def-decl "list[T]" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (> const-decl "bool" reals nil) (car_ol const-decl "T" ordered_list structures) (= const-decl "[T, T -> boolean]" equalities nil) (null_ol? const-decl "bool" ordered_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (nzBaseType type-eq-decl nil affine nil) (varac skolem-const-decl "AffineCombination" affine_expr_Eval_fnd nil) (N skolem-const-decl "Noise" affine_expr_Eval_fnd nil) (upd_noise_burst const-decl "Noise" affine nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (pow skolem-const-decl "nat" affine_expr_Eval_fnd nil) (acRes skolem-const-decl "AffineCombination" affine_expr_Eval_fnd nil) (nwidxs skolem-const-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) =
     nextfreeidx
     AND
     length(r) = newoff - nextfreeidx AND
      FORALL (i: below(length(r))): nth(r, i) = i + nextfreeidx}" affine_expr_Eval_fnd nil) (i_1 skolem-const-decl "below(length(cons((POW(re1, pow), acRes, nwidxs), cache)))" affine_expr_Eval_fnd nil) (beyond_last_idx_notmember formula-decl nil affine nil) (idxs_ac const-decl "list[nat]" affine nil) (olidx_car_last formula-decl nil indexed_list structures) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (nth_ol formula-decl nil ordered_list structures) (i_2 skolem-const-decl "below(opn(nth(cache, i_1 - 1)`1) - 1)" affine_expr_Eval_fnd nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (cache_powvar_correct formula-decl nil affine_expr_Eval_fnd nil) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (varidx_powvar const-decl "nat" affine_expr nil) (eval def-decl "real" interval_expr interval_arith) (pow_var_compatible_noise formula-decl nil affine_pow nil) (last_idx_box formula-decl nil affine_box nil) (last_ol def-decl "T" ordered_list structures) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nat_expt application-judgement "nat" exponentiation nil) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (re1 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_times_even_is_even application-judgement "even_int" integers nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (expt def-decl "real" exponentiation nil) (SingInterval? const-decl "bool" affine nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (last_idx const-decl "int" indexed_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (idxs_ac_var_ac formula-decl nil affine nil) (idx skolem-const-decl "nat" affine_expr_Eval_fnd nil) (eval_updb_no_idxs formula-decl nil affine nil) (next_idx const-decl "nat" affine nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (represents_var? const-decl "bool" affine nil) (containment_pow_var_ac formula-decl nil affine_pow nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (powvar? const-decl "bool" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (real_minus_real_is_real application-judgement "real" reals nil) (var_ac const-decl "AffineCombination" affine nil) (real_plus_real_is_real application-judgement "real" reals nil) (eval_ac_noise const-decl "real" affine nil) (ac_proj_pd formula-decl nil affine nil) (gnbi_updb_2 formula-decl nil affine nil) (member_nats formula-decl nil affine_pow nil) (newoff skolem-const-decl "int" affine_expr_Eval_fnd nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (power_Epsilon_is_Epsilon formula-decl nil affine_pow nil) (null adt-constructor-decl "(null?)" list_adt nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (real_div_nzreal_is_real application-judgement "real" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (i_1 skolem-const-decl "below(length(box))" affine_expr_Eval_fnd nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) ({\|\|} const-decl "AffineCombination" affine nil) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (lt_idx_strict_order formula-decl nil indexed_list structures) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC65-2 nil 3637401898 ("" (then (skeep*) (assert) (apply (then (label "re" -2) (label "varac" -4) (label "cached some" -5) (label "cached" -6) (label "idxs" -7) (label "pownoises" -8) (label "newoff" -9) (label "nwidxs" -10) (label "acRes" -11) (label "result" -12) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "cv not 0" 4) (label "pow gt opn" 5) (label "opw gt opn" 6))) (hide -13) (replaces "result") (assert) (spread (split 7) ((spread (inst 1 "(:(re, acRes, nwidxs):)") ((then (expand "append" 1) (grind)) (grind))) (then (lift-if "nwidxs") (spread (split nwidxs) ((then (with-labels (name "opn" "opn(val(cached)`1)") (("opn name"))) (hide "opn name") (with-labels (flatten "nwidxs") (("opn >= 2" "nwidxs"))) (with-labels (typepred "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (expand "compatible_pairs?") (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (spread (inst 1 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+1+opn)))") ((spread (split 1) ((then (expand "vars_in_box_compatible?") (skolem 1 "k") (inst "N vars in box" "k") (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (spread (split 1) ((then (replace "eval box is vs" 1 :dir RL) (expand "var_ac" 1) (lift-if 1) (spread (split 1) ((then (flatten) (expand "eval_ac_noise" 2) (spread (use "eval_pd_noise_rec_pds_def") ((then (assert) (expand_ol) (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1 2) (assert) (typepred "nextfreeidx") (spread (use "gnbi_updb_2") ((then (assert) (hide 2) (use "member_nats") (assert) (flatten) (typepred "k") (typepred "nextfreeidx") (expand "last_idx_in_box") (assert)) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "varac not single value")) (skeep) (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert))))) (assert)))) (then (flatten) (expand "eval_ac_noise" 1) (use "eval_pd_noise_rec_pds_def") (assert) (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((expand_ol) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert)))))))) (then (flatten) (assert) (replace "single intervals in box" 1 :dir RL :hide? t) (spread (use "gnbi_updb_2") ((then (assert) (hide 1) (replaces "nwidxs" -1) (use "member_nats") (assert) (flatten) (typepred "k") (typepred "nextfreeidx") (grind)) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert)))))))) (then (expand "compatible_pairs_on?") (skolem 1 "k") (skeep) (spread (split 1) ((spread (case "k=0") ((then (replaces -1) (expand "nth" 1) (expand "eval_ACExpr_Env" 1) (replaces "acRes") (typepred "cached") (assert) (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (skolem "cached cache idx" "i") (inst "cache comp pairs on" "i") (inst "cache comp pairs on" "n") (with-labels (flatten) (("cache eval" "cache if powvar" "UNKNOWN"))) (replace "cached cache idx") (expand "eval_ACExpr_Env" "cache eval") (assert) (use "cache_powvar_correct") (replace "cached cache idx") (expand "CacheData_correct?") (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (replace "cached as AC" "cache eval") (replace "re") (assert) (replace "cached idx re") (replace "varac" 1) (lemma "containment_pow_var_ac") (expand "eval" 1) (expand "eval" 1) (spread (inst? -1 :where 1) ((then (assert) (hide 2) (spread (split 1) ((then (expand "vars_in_box_compatible?") (inst "N vars in box" "idx") (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (replace -17) (replace "eval box is vs" 1 :dir RL) (expand "nth_ac") (expand "var_ac" 1) (lift-if 1) (spread (split 1) ((then (flatten) (expand "eval_ac_noise" 2) (spread (use "eval_pd_noise_rec_pds_def") ((then (assert) (expand_ol) (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1 2) (assert) (typepred "nextfreeidx") (spread (use "gnbi_updb_2") ((then (assert) (hide 2) (use "member_nats") (assert) (flatten) (expand "last_idx_in_box") (assert)) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert))))) (flatten)))) (then (flatten) (expand "eval_ac_noise" 1) (use "eval_pd_noise_rec_pds_def") (assert) (expand_ol) (replaces -1) (lemma "eval_pd_noise_rec_pds_def") (grind))))) (then (expand "nth_ac") (replace "varac" :dir RL) (flatten) (replace "nwidxs" -1 :hide? t) (use "member_append_fi[nat]") (assert) (hide -2) (spread (split -1) ((spread (split "cached cond ok") ((then (expand "next_idx") (expand "last_idx") (replace "pownoises") (hide-all-but (-1 -2 "varac" "varac not single value")) (replaces "varac") (use "olidx_car_last[nzBaseType]") (assert) (expand "car_ol") (spread (use "notmember_ol_nat") ((then (assert) (grind)) (use "take_ol[nat,<]")))) (grind))) (then (use "member_nats") (assert) (hide -2) (flatten) (typepred "nextfreeidx") (replace "varac") (use "last_idx_box") (expand "next_idx") (expand "last_idx") (hide-all-but (-1 -2 -3 "varac not single value")) (use "olidx_car_last[nzBaseType]") (spread (split -1) ((then (expand "car_ol") (assert)) (then (expand "length") (assert)))))))) (then (reveal "cache comp pairs on") (hide -1) (inst "cache comp pairs on" "i") (assert) (lemma "powvar_comp_noise_extension") (spread (inst -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") ((then (assert) (replace "varac" -1) (replaces "cached cache idx" :dir RL) (replace "pownoises" -1) (replace "nwidxs" 1) (replace "pownoises" 1) (replace "re" (-1 1)) (replace "newoff" 1) (reveal "opn name") (assert) (grind)) (then (hide 2) (replace "pownoises" 1) (expand "idxs_bounded" "cache idxs bound") (inst "cache idxs bound" "i") (spread (case "next_idx(pd(nth(cache, i)`2)) = nth(nth(cache, i)`3, opn(val(cached)`1)-2)+1") ((then (replace -1 "cache idxs bound" :hide? t) (spread (use "last_take_nth[nat,<]") ((then (replace -1 1 :hide? t) (assert)) (grind)))) (then (replace "cached cache idx") (replace "cached as AC" 1) (use "next_idx_pow_var_ac") (assert) (grind)) (then (replace "varac" "varac not single value") (assert) (expand "varidx_powvar") (assert))))) (then (expand "varidx_powvar") (replace "varac" "varac not single value") (replace "pownoises" 1) (replace "varac" 1) (flatten) (assert) (flatten) (assert)) (then (expand "length" "varac not single value") (replace "varac") (spread (split 1) ((then (expand "nth_ac") (hide-all-but 1) (grind)) (then (hide-all-but (-1 "varac not single value")) (assert))))) (then (replace "re" 1) (assert)))))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (reveal "varac") (grind))))) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert)) (then (hide-all-but (1 "varac" "varac not single value")) (expand "length") (grind))))) (then (expand "nth" 2) (assert) (inst "cache comp pairs on" "k-1") (inst "cache comp pairs on" "n") (with-labels (flatten "cache comp pairs on") (("cache eval" "cache if powvar" "UNKNOWN"))) (replace "cache eval" 2 :dir RL) (spread (use "eval_updb_no_idxs") ((then (assert) (hide 3) (skeep) (use "member_nats") (assert) (flatten) (expand "idxs_bounded" "cache idxs bound") (inst?) (expand "idxs_ac") (use "beyond_last_idx_notmember") (assert) (expand "next_idx") (assert)) (then (hide-all-but (1 "varac not single value")) (skeep) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert)) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert))))))) (spread (case "k=0") ((then (replaces -1) (flatten) (expand "nth" (-1 -2)) (expand "nth" 1) (typepred "cached") (assert) (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached in cache"))) (skolem "cached in cache" "j") (inst "cache comp pairs on" "j") (inst "cache comp pairs on" "n") (with-labels (flatten "cache comp pairs on") (("cached eval noise vs" "cached N compatible"))) (assert) (lemma "powvar_comp_noise_extension") (spread (inst -1 "N" "opn(val(cached)`1)" "opn(re)" "varac" "pownoises" "nextfreeidx") ((then (assert) (replace "varac" -1) (replaces "cached in cache" :dir RL) (replace "pownoises" -1) (replace "cached idx re" "cached N compatible") (replace "re" "cached N compatible") (replace "nwidxs" 1) (replace "pownoises" 1) (replace "re" (-1 1)) (replace "newoff" 1) (reveal "opn name") (assert) (expand "varidx_powvar") (assert)) (then (replace "pownoises" 1) (expand "idxs_bounded" "cache idxs bound") (inst "cache idxs bound" "j") (spread (case "next_idx(pd(nth(cache, j)`2)) = nth(nth(cache, j)`3, opn(val(cached)`1)-2)+1") ((then (replace -1 "cache idxs bound" :hide? t) (spread (use "last_take_nth[nat,<]") ((then (replace -1 1 :hide? t) (assert)) (then (use "cache_powvar_correct") (expand "CacheData_correct?") (replace "cached in cache") (assert) (flatten) (replace "varac") (replace "cached idx re") (replace "re") (assert) (expand "varidx_powvar") (assert))))) (then (replace "cached in cache") (use "cache_powvar_correct") (replace "cached in cache") (expand "CacheData_correct?") (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (replace "cached as AC" 1) (use "next_idx_pow_var_ac") (replace "cached idx re" -1) (replace "re" -1) (replace "varac" "varac not single value") (assert) (replace "cached idx re" 1) (replace "re" 1) (assert) (expand "varidx_powvar") (propax)) (then (use "cache_powvar_correct") (replace "cached in cache") (expand "CacheData_correct?") (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (assert) (replace "varac" "varac not single value") (replace "cached idx re" -1) (replace "re" -1) (assert) (expand "varidx_powvar") (assert))))) (then (use "cache_powvar_correct") (replace "cached in cache") (expand "CacheData_correct?") (with-labels (flatten -1) (("cached cond ok" "cached as AC" "UNKNOWN"))) (assert) (replace "varac" "varac not single value") (replace "pownoises" 1) (replace "varac" 1) (replace "cached idx re" "cached cond ok") (replace "re" "cached cond ok") (assert) (expand "varidx_powvar") (assert) (flatten) (assert) (flatten) (assert)) (then (expand "length" "varac not single value") (assert)) (then (replace "re" 1) (assert))))) (then (flatten) (spread (inst "cache comp pairs on" "k-1") ((then (inst "cache comp pairs on" "n") (expand "nth" 2) (assert) (flatten) (expand "nth" (-1 -2)) (assert) (expand "pow_var_compatible?") (flatten) (skolem 2 "i") (assert) (inst "cache comp pairs on" "i") (spread (case "get_noise_by_idx( nth(nth(cache, k - 1)`3, i)
                                                                                                                	                              , upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i: nat): (get_noise_by_idx(car(pd(varac))`1, N)^(1 + i +opn)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, i),N)") ((then (replaces -1) (spread (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                  0)`1,
                                                                                                                                                                                                                                              upd_noise_burst(N,
                                                                                                                                                                                                                                                              nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                                              LAMBDA
                                                                                                                                                                                                                                                              (i: nat):
                                                                                                                                                                                                                                                              (get_noise_by_idx
                                                                                                                                                                                                                                                               (car(pd(varac))`1, N)
                                                                                                                                                                                                                                                               ^
                                                                                                                                                                                                                                                               (1 + i +opn))))
                                                                                                                                                                                                                              ^ (2 + i) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                                                                  0)`1,
                                                                                                                                                                                                                                              N)
                                                                                                                                                                                                                              ^ (2 + i)") ((replaces -1) (spread (use "gnbi_updb_2") ((then (assert) (hide 1) (hide 2) (use "member_nats") (assert) (hide -2) (flatten) (typepred "nextfreeidx") (expand "nth_ac" -2) (expand "idxs_bounded") (inst "cache idxs bound" "k-1") (expand "next_idx") (name-replace "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (use "last_idx_box") (expand "next_idx") (expand "last_idx") (lift-if -1) (spread (split -1) ((then (flatten) (use "olidx_car_last[nzBaseType]") (expand_ol) (expand "nth" -4 1) (assert) (expand "nth_ac") (assert)) (then (assert) (hide-all-but (-1 -7)) (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert)) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert))))))) (then (hide 3) (spread (use "gnbi_updb_2") ((then (assert) (hide 1) (use "member_nats") (assert) (hide -2) (flatten) (expand "idxs_bounded") (inst "cache idxs bound" "k-1") (use "cache_powvar_correct") (expand "CacheData_correct?") (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (lemma "next_idx_pow_var_ac") (inst? -1 :where "cache idxs bound") (lift-if -1) (spread (split -1) ((then (typepred "cached") (assert)) (then (flatten) (spread (split -1) ((grind) (then (flatten) (replace -1 "cache idxs bound" :hide? t) (typepred "i") (hide-all-but (-1 -5 "cache idxs bound")) (expand ">=") (spread (case "i = opn(nth(cache, k - 1)`1) - 2") ((then (replaces -1) (hide -1) (assert)) (spread (case "i < opn(nth(cache, k - 1)`1) - 2") ((then (hide -2) (lemma "nth_ol[nat,<]") (inst -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "i") (assert)) (assert)))))))))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert))))) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert)) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert)) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert))))) (then (typepred "k") (hide-all-but (-1 1 2)) (assert) (grind)))))))))))) (then (hide-all-but (1 "varac not single value")) (skeep) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (then (hide-all-but (1 "opn >= 2")) (skeep) (reveal "opn name") (assert)) (assert)))) (then (with-labels (flatten "nwidxs") (("cached opn < 2" "nwidxs" "UNKNOWN"))) (with-labels (typepred "cache") (("correct cache" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (expand "compatible_pairs?") (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (spread (inst 2 "upd_noise_burst(N, nats(nextfreeidx, newoff - 1), LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(2+i)))") ((spread (split 2) ((then (expand "vars_in_box_compatible?") (skolem 1 "k") (inst "N vars in box" "k") (with-labels (flatten "N vars in box") (("eval box is vs" "single intervals in box" "UNKNOWN"))) (spread (split 1) ((then (replace "eval box is vs" 1 :dir RL) (expand "var_ac" 1) (lift-if 1) (spread (split 1) ((then (flatten) (expand "eval_ac_noise" 2) (spread (use "eval_pd_noise_rec_pds_def") ((then (assert) (expand_ol) (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1) (assert) (typepred "nextfreeidx") (spread (use "gnbi_updb_2") ((then (assert) (hide 2) (use "member_nats") (assert) (flatten) (typepred "k") (typepred "nextfreeidx") (expand "last_idx_in_box") (assert)) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert))))) (assert)))) (then (flatten) (expand "eval_ac_noise" 1) (use "eval_pd_noise_rec_pds_def") (assert) (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((expand_ol) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)))))))) (then (flatten) (assert) (replaces "single intervals in box" 1 :dir RL) (spread (use "gnbi_updb_2") ((then (assert) (hide 1) (replaces "nwidxs" -1) (use "member_nats") (assert) (flatten) (typepred "k") (typepred "nextfreeidx") (grind)) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)))))))) (then (expand "compatible_pairs_on?") (skolem 1 "k") (skeep) (spread (split 1) ((spread (case "k=0") ((then (replaces -1) (expand "nth" 1) (expand "eval_ACExpr_Env" 1) (replaces "acRes") (expand "eval") (lemma "containment_pow_var_ac") (expand "eval" 1) (replace "re" 1) (assert) (spread (inst -1 "upd_noise_burst(N,
                                                                                                                                                                       nats(nextfreeidx, newoff - 1),
                                                                                                                                                                       LAMBDA
                                                                                                                                                                       (i: nat):
                                                                                                                                                                       (get_noise_by_idx(car(pd(varac))`1, N)
                                                                                                                                                                        ^
                                                                                                                                                                        (2+i)))" "vs(varidx(re1))" "varac" "pow" "nwidxs") ((then (assert) (hide 2) (spread (split 1) ((then (expand "vars_in_box_compatible?") (inst "N vars in box" "idx") (replace "varac" 1) (expand "nth_ac" 1) (with-labels (flatten "N vars in box") (("box eval" "box sing int" "UNKNOWN"))) (spread (use "eval_updb_no_idxs") ((then (assert) (hide 2) (skolem 1 "j") (flatten) (use "member_nats") (assert) (flatten) (typepred "nextfreeidx") (use "last_idx_box") (grind)) (then (hide-all-but (1 "varac not single value")) (skeep) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (reveal "varac") (replaces "varac") (expand "nth_ac") (expand "length") (assert))))) (then (replaces "varac") (expand "length") (expand "nth_ac") (assert))))) (then (flatten) (replaces "nwidxs" -1) (use "member_nats") (assert) (flatten) (replaces "varac") (typepred "nextfreeidx") (use "last_idx_box") (grind)) (spread (use "pow_var_compatible_noise") ((assert) (then (replaces "varac") (hide-all-but 1) (grind))))))) (then (hide-all-but (1 "varac not single value" "varac")) (replaces "varac") (skeep) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value" "varac")) (replaces "varac") (expand "length") (assert))))) (then (expand "nth" 2) (assert) (inst "cache comp pairs on" "k-1") (inst "cache comp pairs on" "n") (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (replaces "eval cache" 2 :dir RL) (spread (use "eval_updb_no_idxs") ((then (assert) (hide 3) (skolem 1 "i") (flatten) (use "member_nats") (assert) (flatten) (expand "idxs_bounded") (inst "cache idxs bound" "k-1") (expand "next_idx") (lemma "beyond_last_idx_notmember") (inst -1 "i" "pd(nth(cache, k - 1)`2)") (assert) (expand "idxs_ac") (propax)) (then (hide-all-but (1 "varac not single value" "varac")) (replaces "varac") (skeep) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value" "varac")) (replaces "varac") (expand "length") (assert))))))) (spread (case "k=0") ((then (replaces -1) (expand "nth" 1) (replace "re" 1) (assert) (spread (use "pow_var_compatible_noise") ((then (replaces "nwidxs") (replaces "varac") (expand "powvar?") (expand "varidx_powvar") (assert)) (then (expand "nth_ac") (replaces "varac") (hide-all-but (1 "varac not single value")) (expand "varidx_powvar") (grind))))) (then (expand "nth" 2) (expand "varidx_powvar") (assert) (flatten) (inst "cache comp pairs on" "k-1") (inst "cache comp pairs on" "n") (with-labels (flatten "cache comp pairs on") (("eval cache" "cache if powvar" "UNKNOWN"))) (assert) (expand "pow_var_compatible?") (flatten) (assert) (skolem 2 "j") (inst "cache if powvar" "j") (spread (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                            0)`1,
                                                                                                                                                                                                        upd_noise_burst(N,
                                                                                                                                                                                                                        nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                        LAMBDA
                                                                                                                                                                                                                        (i: nat):
                                                                                                                                                                                                                        (get_noise_by_idx
                                                                                                                                                                                                                         (car(pd(varac))`1, N)
                                                                                                                                                                                                                         ^
                                                                                                                                                                                                                         (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, k - 1)`1))),
                                                                                                                                                                                                            0)`1,
                                                                                                                                                                                                        N)") ((then (replaces -1) (spread (case "get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                          upd_noise_burst(N,
                                                                                                                                                                                                                                          nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                                          LAMBDA
                                                                                                                                                                                                                                          (i: nat):
                                                                                                                                                                                                                                          (get_noise_by_idx
                                                                                                                                                                                                                                           (car(pd(varac))`1, N)
                                                                                                                                                                                                                                           ^
                                                                                                                                                                                                                                           (2 + i)))) = get_noise_by_idx(nth(nth(cache, k - 1)`3, j),
                                                                                                                                                                                                                          N)") ((then (replaces -1) (grind)) (then (hide 3) (spread (use "gnbi_updb_2") ((then (assert) (hide 1) (use "member_nats") (assert) (flatten) (expand "idxs_bounded") (inst?) (use "cache_powvar_correct") (expand "CacheData_correct?") (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (lemma "next_idx_pow_var_ac") (inst? -1 :where "cache idxs bound") (lift-if -1) (spread (split -1) ((then (flatten) (grind)) (then (flatten) (spread (split -1) ((grind) (then (flatten) (replace -1 "cache idxs bound" :hide? t) (typepred "j") (hide-all-but (-1 -5 "cache idxs bound")) (expand ">=") (spread (case "j = opn(nth(cache, k - 1)`1) - 2 ") ((then (hide -2) (replaces -1) (assert)) (spread (case "j < opn(nth(cache, k - 1)`1) - 2") ((then (hide (-2 1)) (lemma "nth_ol[nat,<]") (inst -1 "nth(cache, k - 1)`3" "opn(nth(cache, k - 1)`1) - 2" "j") (assert)) (assert)))))))))))) (then (hide-all-but (1 "varac not single value")) (skeep) (spread (use "power_Epsilon_is_Epsilon") ((then (assert) (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert)))))))) (then (hide 3) (spread (use "gnbi_updb_2") ((then (assert) (hide 1) (use "member_nats") (assert) (flatten) (typepred "nextfreeidx") (expand "nth_ac" -2) (expand "idxs_bounded") (inst "cache idxs bound" "k-1") (expand "next_idx") (name-replace "somevidx" "varidx_powvar(nth(cache, k - 1)`1)") (use "last_idx_box") (expand "next_idx") (expand "last_idx") (lift-if -1) (spread (split -1) ((then (flatten) (use "olidx_car_last[nzBaseType]") (expand_ol) (expand "nth" -4 1) (assert) (expand "nth_ac") (assert)) (then (flatten) (expand "last_idx_in_box") (assert) (expand "somevidx") (expand "varidx_powvar") (assert) (grind))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert)) (then (expand "varidx_powvar") (assert)) (then (expand "varidx_powvar") (propax)))))))))))) (then (hide-all-but (1 "varac not single value")) (skeep) (use "power_Epsilon_is_Epsilon") (flatten) (assert)) (assert))))))) (then (replace "newoff" 1) (expand ">=") (spread (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") ((then (replaces -1) (spread (case "0 < pow - opn(val(cached)`1)") ((then (hide-all-but (1 -1)) (name-replace "A" "pow - opn(val(cached)`1)") (assert)) (grind)))) (assert)))) (then (replace "newoff" 1) (expand "idxs_bounded" 1) (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (replace "acRes" 1) (use "next_idx_pow_var_ac") (replaces -1) (lift-if 1) (spread (split 1) ((then (flatten) (grind)) (then (flatten) (spread (split 3) ((then (flatten) (grind)) (then (flatten) (replace "nwidxs" 2) (lift-if 2) (spread (split 2) ((then (flatten) (spread (case "pow - 1 = opn(val(cached)`1)") ((then (replace -1 1 :dir RL) (assert) (spread (case "nth(append(take[nat](pownoises, pow - 2),
                                                                                                                                                                                                                nats(nextfreeidx, newoff - 1)),
                                                                                                                                                                                                         pow - 2) = nextfreeidx") ((assert) (then (hide 2) (spread (case "nth(append(take[nat](pownoises, pow - 2), nats(nextfreeidx, newoff - 1)), pow - 2) =
                                    nth(nats(nextfreeidx, newoff - 1), pow - 2 - length(take[nat](pownoises, pow - 2)))") ((then (replaces -1 1) (use "length_take[nat]") (replaces -1 1) (expand "min") (lift-if 1) (spread (split 1) ((then (flatten) (grind)) (then (flatten) (spread (case "length(pownoises) = pow - 2") ((then (replaces -1 2) (grind)) (spread (case "length(pownoises) > opn(val(cached)`1) - 2") ((assert) (then (replace "pownoises" 1) (typepred "cached") (use "cache_powvar_correct_result") (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (with-labels (assert) (("cached correct"))) (replace "cached" "cached correct" :dir RL) (expand "CacheData_correct?" "cached correct") (typepred "cached") (assert) (flatten) (assert) (flatten) (replace "varac" "varac not single value") (replace -2 "cached correct") (replace "re" "cached correct") (assert) (expand "varidx_powvar") (assert)))))))))) (then (use "more_list_props[nat].nth_append") (spread (split -1) ((then (replaces -1 1) (lift-if 1) (spread (split 1) ((then (flatten) (use "length_take[nat]") (replace -1 -2) (expand "min") (lift-if -1) (spread (split -1) ((then (flatten) (assert)) (then (flatten) (assert))))) (propax)))) (then (use "length_append[nat]") (use "length_take[nat]") (replace -1 1) (expand "min") (lift-if 1) (spread (split 1) ((then (flatten) (assert)) (then (flatten) (replace "pownoises" 1) (hide -1 -2) (typepred "cached") (assert) (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (skolem "cached cache idx" "j") (replace "cached cache idx" :dir RL) (use "cache_powvar_correct") (expand "CacheData_correct?") (assert) (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (replace "cached idx re" "cached cond ok") (replace "re" "cached cond ok") (assert) (expand "varidx_powvar") (assert)))))))) (spread (split 1) ((then (use "length_take[nat]") (replaces -1 1) (grind)) (then (use "length_append[nat]") (use "length_take[nat]") (replace -1 1) (expand "min") (lift-if 1) (spread (split 1) ((then (flatten) (assert)) (then (flatten) (replace "pownoises" 1) (hide -1 -2) (typepred "cached") (assert) (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (skolem "cached cache idx" "j") (replace "cached cache idx" :dir RL) (use "cache_powvar_correct") (expand "CacheData_correct?") (assert) (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (replace "cached idx re" "cached cond ok") (replace "re" "cached cond ok") (assert) (expand "varidx_powvar") (assert))))))))))))) (spread (case "nth(append(take[nat](pownoises, opn(val(cached)`1) - 1), nats(nextfreeidx, newoff - 1)), pow - 2)
                                =
                                nth(nats(nextfreeidx, newoff - 1),
                                    pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1)))") ((then (replaces -1 2) (spread (case "nth(nats(nextfreeidx, newoff - 1),
                                                                                                                                                                                                                            pow - 2 - length(take[nat](pownoises, opn(val(cached)`1) - 1))) = newoff -1 ") ((then (replaces -1 2) (replace "newoff" 2) (assert)) (spread (case "length(take[nat](pownoises, opn(val(cached)`1) - 1)) = opn(val(cached)`1) - 1") ((then (replaces -1 1) (replaces "newoff" 1) (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (inst? -5) (replace -5 2) (assert)) (spread (use "length_take[nat]") ((then (replace -1 1) (expand "min" 1) (lift-if 1) (spread (split 1) ((propax) (then (flatten) (replaces "pownoises" 1) (use "cache_powvar_correct_result") (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (with-labels (assert) (("cached correct"))) (expand "CacheData_correct?" "cached correct") (typepred "cached") (assert) (flatten) (assert) (flatten) (replace "cached" "cached correct" :dir RL) (replace -2 "cached correct") (replace "re" "cached correct") (assert) (expand "varidx_powvar") (assert))))) (assert))))) (spread (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") ((then (replace -1 1) (assert)) (spread (use "length_take[nat]") ((then (replace -1 1) (expand "min" 1) (lift-if 1) (spread (split 1) ((propax) (then (flatten) (replaces "pownoises" 1) (use "cache_powvar_correct_result") (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (with-labels (assert) (("cached correct"))))))) (assert)))))))) (spread (use "more_list_props[nat].nth_append") ((spread (split -1) ((then (replaces -1 1) (lift-if 1) (spread (split 1) ((then (flatten) (spread (use "length_take[nat]") ((then (replace -1 -2) (expand "min") (lift-if -2) (spread (split -2) ((assert) (then (assert) (flatten) (assert))))) (assert)))) (propax)))) (spread (use "length_take[nat]") ((then (replaces -1 1) (expand "min") (lift-if 1) (spread (split 1) ((assert) (then (flatten) (replaces "pownoises" 1) (typepred "cached") (assert) (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (skolem "cached cache idx" "j") (replace "cached cache idx" :dir RL) (use "cache_powvar_correct") (expand "CacheData_correct?") (assert) (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (replace "varac") (replace "cached idx re" "cached cond ok") (replace "re") (assert) (expand "varidx_powvar") (assert))))) (assert))))) (assert) (assert))) (spread (case "length[nat](take[nat](pownoises, opn(val[CacheData](cached)`1) - 1)) = opn(val[CacheData](cached)`1) - 1") ((spread (split 1) ((then (replaces -1 1) (assert)) (spread (use "length_append[nat]") ((then (replaces -1 1) (spread (use "length_take[nat]") ((then (replaces -1 1) (expand "min") (lift-if 1) (spread (split 1) ((assert) (then (flatten) (replaces "pownoises" 1) (typepred "cached") (assert) (with-labels (flatten -1) (("cached powvar" "cached idx re" "cached cache idx" "UNKNOWN"))) (skolem "cached cache idx" "j") (replace "cached cache idx" :dir RL) (use "cache_powvar_correct") (expand "CacheData_correct?") (assert) (with-labels (flatten -1) (("chached varidx < box" "cached cond ok" "cached as AC" "UNKNOWN"))) (replace "varac") (replace "cached idx re" "cached cond ok") (replace "re") (assert) (expand "varidx_powvar") (assert))))) (assert)))) (assert) (assert))))) (then (hide 2) (spread (use "length_take[nat]") ((then (replace -1 1) (expand "min" 1) (lift-if 1) (spread (split 1) ((propax) (then (flatten) (replaces "pownoises" 1) (use "cache_powvar_correct_result") (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (with-labels (assert) (("cached correct"))) (expand "CacheData_correct?" "cached correct") (typepred "cached") (assert) (flatten) (assert) (flatten) (replace "cached" "cached correct" :dir RL) (replace -2 "cached correct") (replace "re" "cached correct") (assert) (expand "varidx_powvar") (assert))))) (assert)))) (assert))) (assert) (assert)))))) (then (flatten) (replace "newoff" 2) (typepred "nats(nextfreeidx, nextfreeidx - opn(val(cached)`1) + pow - 1)") (inst? -5) (replaces -5 3) (assert))))))))))) (then (with-labels (typepred "cache") (("correct cache" "cache compatible pairs" "cache idxs bounded" "UNKNOWN"))) (expand "idxs_bounded" "cache idxs bounded") (expand "nth" 2) (assert) (inst "cache idxs bounded" "i-1") (expand ">=") (spread (case "nextfreeidx - opn(val(cached)`1) + pow = nextfreeidx + (pow - opn(val(cached)`1))") ((then (replaces -1) (spread (case "0 < pow - opn(val(cached)`1)") ((then (hide-all-but (-1 2 "cache idxs bounded")) (name-replace "A" "pow - opn(val(cached)`1)") (assert)) (grind)))) (grind)))))))))) nil nil) ((ordered_list type-eq-decl nil ordered_list structures) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (lt_idx_strict_order formula-decl nil indexed_list structures) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (power_Epsilon_is_Epsilon formula-decl nil affine_pow nil) (member_nats formula-decl nil affine_pow nil) (gnbi_updb_2 formula-decl nil affine nil) (ac_proj_pd formula-decl nil affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_updb_no_idxs formula-decl nil affine nil) (beyond_last_idx_notmember formula-decl nil affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (eval def-decl "real" interval_expr interval_arith) (nth_ac const-decl "AffineCombination" affine_box nil) (next_idx const-decl "nat" affine nil) (represents_var? const-decl "bool" affine nil) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (powvar_comp_noise_extension formula-decl nil affine_pow nil) (last_take_nth formula-decl nil ordered_list structures) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (member_append_fi formula-decl nil more_list_props structures) (last_idx_box formula-decl nil affine_box nil) (olidx_car_last formula-decl nil indexed_list structures) (take_ol formula-decl nil ordered_list structures) (last_ol def-decl "T" ordered_list structures) (notmember_ol_nat formula-decl nil affine_pow nil) (idxs_ac const-decl "list[nat]" affine nil) (idxs_pd def-decl "list[nat]" affine nil) (take def-decl "list[T]" more_list_props structures) (last_idx const-decl "int" indexed_list structures) (pow_var_compatible? const-decl "bool" affine_pow nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (SingInterval? const-decl "bool" affine nil) (containment_pow_var_ac formula-decl nil affine_pow nil) (nth_ol formula-decl nil ordered_list structures) (upd_noise_burst const-decl "Noise" affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (nzBaseType type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (pow_var_compatible_noise formula-decl nil affine_pow nil) (length_take formula-decl nil more_list_props structures) (nth_append formula-decl nil more_list_props structures) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC65-1 nil 3632064917 ("" (skeep*) (("" (assert) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached" -3) (label "newoff" -4) (label "nwidxs" -5) (label "acRes" -6) (label "result" -7) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (expand "correct_cache?") (("1" (expand "CacheData_correct?") (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (replaces "nwidxs" 2) (("1" (expand "nats" 2) (("1" (lift-if 2) (("1" (split 2) (("1" (assert) (("1" (flatten) (("1" (replaces -1 1 :dir RL) (("1" (use "last_idx_box") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand_ol) (("2" (use "last_idx_box") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff") (("2" (hide-all-but (1 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow-1)") (("1" (replaces -1) (("1" (case "0<=pow - 1") (("1" (name-replace "A" "pow -1 ") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial reals) (cdr_ol const-decl "ordered_list" ordered_list structures) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (last_idx_box formula-decl nil affine_box nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC71 0 (RE2AC_TCC71-1 nil 3789916158 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length_singleton formula-decl nil more_list_props structures) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC72 0 (RE2AC_TCC66-3 nil 3637402164 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (restrict const-decl "R" restrict nil)) nil (RE2AC termination "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re1, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.nextfreeidx, affine_expr_Eval_fnd.cache)" "nil")) (RE2AC_TCC66-2 nil 3632080585 ("" (skeep*) (("" (assert) (("" (hide -8) (("" (apply (then (label "re" -1) (label "varac" -2) (label "cached" -3) (label "newoff" -4) (label "nwidxs" -5) (label "acRes" -6) (label "result" -7) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (("" (replaces "re") (("" (replaces "result") (("" (assert) (("" (split 7) (("1" (inst 1 "(: (POWVAR(idx, pow), acRes, nwidxs) :)") (("1" (grind) nil nil)) nil) ("2" (with-labels (typepred "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (("2" (expand "compatible_pairs?") (("2" (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (("2" (inst 1 "upd_noise_burst(N, nwidxs, LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") (("1" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (skeep) (("1" (inst "N vars in box" "i_1") (("1" (with-labels (flatten) (("eval box is vs" "single intervals in box" "UNKNOWN"))) (("1" (split 1) (("1" (replace "eval box is vs" 1 :dir RL) (("1" (expand "var_ac" 1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "eval_ac_noise" 2) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (assert) (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) (("1" (replaces -1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 2) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "i_1") (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (hide-all-but (1 "pow <= 1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "eval_ac_noise" 1) (("2" (use "eval_pd_noise_rec_pds_def") (("2" (assert) (("2" (expand_ol) (("2" (replaces -1 1) (("2" (use "eval_pd_noise_rec_pds_def") (("1" (expand_ol) nil nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replaces "single intervals in box" 1 :dir RL) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "i_1") (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skeep 1) (("2" (case "i_1=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "eval_ACExpr_Env" 1) (("1" (expand "vars_in_box_compatible?") (("1" (inst "N vars in box" "idx") (("1" (flatten) (("1" (replace "N vars in box" 1 :dir RL) (("1" (replace "acRes" 1) (("1" (split 1) (("1" (use "containment_pow_var_ac") (("1" (assert) (("1" (split 1) (("1" (hide 2) (("1" (replaces "varac") (("1" (expand "nth_ac") (("1" (use "eval_updb_no_idxs") (("1" (assert) (("1" (hide 2) (("1" (skolem 1 "k") (("1" (flatten) (("1" (use "idxs_ac_var_ac") (("1" (assert) (("1" (replaces -1) (("1" (replaces "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flatten) (("2" (replaces "nwidxs" -1) (("2" (use "member_nats") (("1" (assert) (("1" (flatten) (("1" (typepred "nextfreeidx") (("1" (expand "last_idx_in_box") (("1" (expand ">") (("1" (replaces "varac") (("1" (use "last_idx_box") (("1" (expand ">=") (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (expand "last_ol") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (use "pow_var_compatible_noise") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (use "pow_var_compatible_noise") (("1" (replace "varac" 1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst "cache comp pairs on" "i_1 -1 ") (("1" (expand "nth" 2) (("1" (assert) (("1" (flatten) (("1" (replaces "cache comp pairs on" 2 :dir RL) (("1" (split 2) (("1" (use "eval_updb_no_idxs") (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "idxs_bounded") (("2" (inst "cache idxs bound" "i_1 - 1") (("2" (expand "idxs_ac") (("2" (expand "next_idx") (("2" (use "beyond_last_idx_notmember") (("2" (assert) (("2" (replaces "nwidxs" -1) (("2" (use "member_nats") (("1" (assert) nil nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "pow_var_compatible?") (("2" (flatten) (("2" (assert) (("2" (skeep) (("2" (inst?) (("2" (case "get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                                                upd_noise_burst(N,
                                                                                                nwidxs,
                                                                                                LAMBDA
                                                                                                (i: nat):
                                                                                                (get_noise_by_idx
                                                                                                 (car(pd(varac))`1, N)
                                                                                                 ^
                                                                                                 (2 + i)))) = get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                                                N)") (("1" (replaces -1) (("1" (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))),
                                                                                           0)`1,
                                                                                       upd_noise_burst(N,
                                                                                                       nwidxs,
                                                                                                       LAMBDA
                                                                                                       (i: nat):
                                                                                                       (get_noise_by_idx
                                                                                                        (car(pd(varac))`1, N)
                                                                                                        ^
                                                                                                        (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))),
                                                                                           0)`1,
                                                                                       N)") (("1" (replaces -1) nil nil) ("2" (hide 2) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (replace "nwidxs" -1) (("1" (expand "nth" -1 1) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (lemma "last_idx_box") (("1" (inst? -1 :where -2) (("1" (expand "next_idx") (("1" (expand "last_idx") (("1" (case "NOT null?(pd(nth_ac(box, varidx(nth(cache, i_1 - 1)`1))))") (("1" (assert) (("1" (lemma "olidx_car_last[nzBaseType]") (("1" (inst? -1 :where 1) (("1" (assert) (("1" (typepred "nextfreeidx") (("1" (assert) (("1" (expand "car_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "gnbi_updb_2") (("1" (assert) (("1" (hide 1) (("1" (hide "cache comp pairs on") (("1" (replace "nwidxs" -1) (("1" (use "member_nats") (("1" (assert) (("1" (hide -2) (("1" (flatten) (("1" (expand "idxs_bounded") (("1" (inst? "cache idxs bound") (("1" (use "cache_powvar_correct") (("1" (expand "CacheData_correct?") (("1" (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (("1" (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (("1" (lemma "next_idx_pow_var_ac") (("1" (inst? -1 :where "cache idxs bound") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand ">=") (("2" (replace -1 "cache idxs bound") (("2" (typepred "i_2") (("2" (hide-all-but (-6 -1 "cache idxs bound")) (("2" (case "i_2 = opn(nth(cache, i_1 - 1)`1) - 2") (("1" (hide -2) (("1" (replaces -1 :dir RL) (("1" (assert) nil nil)) nil)) nil) ("2" (case "i_2 < opn(nth(cache, i_1 - 1)`1) - 2") (("1" (hide -2 1) (("1" (lemma "nth_ol[nat,<]") (("1" (inst -1 "nth(cache, i_1-1)`3" "opn(nth(cache, i_1-1)`1) - 2" "i_2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces "newoff") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (expand "length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 "varac not single value")) (("3" (skeep) (("3" (use "power_Epsilon_is_Epsilon") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 "varac not single value")) (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i_1") (("2" (hide-all-but (-1 1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 "varac not single value")) (("2" (skeep) (("2" (assert) (("2" (use "power_Epsilon_is_Epsilon") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replaces "newoff") (("3" (expand ">=") (("3" (hide-all-but (1 "pow <= 1")) (("3" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (typepred "cache") (("4" (expand "idxs_bounded") (("4" (skeep) (("4" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (replaces "acRes") (("1" (use "next_idx_pow_var_ac") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (typepred "nwidxs") (("1" (case "length(nwidxs)=0") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replaces "newoff") (("2" (assert) (("2" (expand ">=") (("2" (replaces "nwidxs") (("2" (typepred "nats(nextfreeidx, nextfreeidx - 2 + pow)") (("2" (inst -5 "pow-2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst?) (("2" (replaces "newoff") (("2" (hide-all-but (2 -3 "pow <= 1")) (("2" (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") (("1" (replaces -1) (("1" (case "1<=(pow - 1)") (("1" (name-replace "A" "pow-1") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (nzBaseType type-eq-decl nil affine nil) (upd_noise_burst const-decl "Noise" affine nil) (containment_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (next_idx const-decl "nat" affine nil) (eval_updb_no_idxs formula-decl nil affine nil) (idxs_ac_var_ac formula-decl nil affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_idx const-decl "int" indexed_list structures) (SingInterval? const-decl "bool" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (last_ol def-decl "T" ordered_list structures) (last_idx_box formula-decl nil affine_box nil) (pow_var_compatible_noise formula-decl nil affine_pow nil) (beyond_last_idx_notmember formula-decl nil affine nil) (idxs_ac const-decl "list[nat]" affine nil) (olidx_car_last formula-decl nil indexed_list structures) (nth_ol formula-decl nil ordered_list structures) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (ac_proj_pd formula-decl nil affine nil) (gnbi_updb_2 formula-decl nil affine nil) (member_nats formula-decl nil affine_pow nil) (power_Epsilon_is_Epsilon formula-decl nil affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil)) nil (RE2AC termination "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re1, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.nextfreeidx, affine_expr_Eval_fnd.cache)" "nil")) (RE2AC_TCC66-1 nil 3632064917 ("" (subtype-tcc) nil nil) nil nil (RE2AC termination "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re1, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.nextfreeidx, affine_expr_Eval_fnd.cache)" "nil"))) (RE2AC_TCC73 0 (RE2AC_TCC73-1 nil 3789916158 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length_singleton formula-decl nil more_list_props structures) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC74 0 (RE2AC_TCC74-1 "" 3789917959 ("" (skeep*) (("" (assert) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)")) (RE2AC_TCC67-2 nil 3637402446 ("" (then (skeep*) (replace -4 7) (expand "nth_ac") (expand "represents_var?") (expand "var_ac") (assert) (hide-all-but 7) (lift-if 1) (expand_ol) (assert)) nil nil) nil nil (RE2AC subtype "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)")) (RE2AC_TCC67-1 nil 3632064917 ("" (subtype-tcc) nil nil) ((Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Env type-eq-decl nil affine_box nil) (next_idx const-decl "nat" affine nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (nth_ac const-decl "AffineCombination" affine_box nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)"))) (RE2AC_TCC75 0 (RE2AC_TCC68-1 nil 3632064917 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length_singleton formula-decl nil more_list_props structures) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (next_idx const-decl "nat" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "affine_expr_Eval_fnd.cache1" "(list_adt[CacheData].cons?)"))) (RE2AC_TCC76 0 (RE2AC_TCC76-1 "" 3789917962 ("" (skeep*) (("" (typepred "res1") (("" (assert) nil nil)) nil)) nil) ((compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box))}")) (RE2AC_TCC69-2 nil 3767022173 ("" (skeep*) (("" (replaces -1) (("" (typepred "res1") (("" (assert) nil nil)) nil)) nil)) nil) ((vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (gt_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "affine_expr_Eval_fnd.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box))}")) (RE2AC_TCC69-1 nil 3632130329 ("" (then (skeep*) (assert) (apply (then (label "re" -2) (label "varac" -4) (label "cached" -5) (label "newoff" -6) (label "nwidxs" -7) (label "acRes" -8) (label "result" -9) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (replaces "re") (replaces "result") (assert) (spread (split 7) ((then (expand "correct_cache?") (expand "CacheData_correct?") (expand "powvar?") (expand "varidx_powvar") (flatten) (typepred "nextfreeidx") (replaces "nwidxs" 2) (expand "nats" 2) (lift-if 2) (spread (split 2) ((then (assert) (flatten) (replaces -1 1 :dir RL) (use "last_idx_box") (grind)) (then (flatten) (expand_ol) (use "last_idx_box") (grind))))) (then (replaces "newoff") (hide-all-but (1 "pow <= 1")) (spread (case "nextfreeidx - 1 + pow = nextfreeidx + (pow-1)") ((then (replaces -1) (spread (case "0<=pow - 1") ((then (name-replace "A" "pow -1 ") (assert)) (assert)))) (assert))))))) nil nil) ((varidx_powvar const-decl "nat" affine_expr nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (last_idx_box formula-decl nil affine_box nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (powvar? const-decl "bool" affine_expr nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.newid1" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box))}"))) (RE2AC_TCC77 0 (RE2AC_TCC77-1 "" 3789917963 ("" (skeep*) (("" (typepred "res1") (("" (assert) (("" (replaces -5 :dir RL) (("" (flatten) (("" (assert) (("" (expand "compatible_pairs?") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (RE2AC subtype "affine_expr_Eval_fnd.cache1" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.newid1)(cache)}")) (RE2AC_TCC70-2 nil 3767022221 ("" (skeep*) (("" (replaces -1) (("" (typepred "res1") (("" (assert) (("" (replaces -5 :dir RL) (("" (flatten) (("" (assert) (("" (expand "compatible_pairs?") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "affine_expr_Eval_fnd.cache1" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.newid1)(cache)}")) (RE2AC_TCC70-1 nil 3632130329 ("" (then (skeep*) (assert) (hide -10) (apply (then (label "re" -2) (label "varac" -4) (label "cached" -5) (label "newoff" -6) (label "nwidxs" -7) (label "acRes" -8) (label "result" -9) (label "idx" 1) (label "pow <= 1" 2) (label "varac not single value" 3) (label "not in cache 3" 4) (label "not in cache 2" 5) (label "not in cache 1" 6))) (replaces "re") (replaces "result") (assert) (spread (split 7) ((then (inst 1 "(: (re, acRes, nwidxs) :)") (grind)) (then (with-labels (typepred "cache") (("cache correct" "cache comp pairs" "cache idxs bound" "UNKNOWN"))) (expand "compatible_pairs?") (with-labels (skeep "cache comp pairs") (("N vars in box" "cache comp pairs on" "UNKNOWN"))) (spread (inst 1 "upd_noise_burst(N, nwidxs, LAMBDA(i:nat): (get_noise_by_idx(nth(pd(varac),0)`1, N)^(i+2)))") ((spread (split 1) ((then (expand "vars_in_box_compatible?") (skeep) (inst "N vars in box" "i_1") (with-labels (flatten) (("eval box is vs" "single intervals in box" "UNKNOWN"))) (spread (split 1) ((then (replace "eval box is vs" 1 :dir RL) (expand "var_ac" 1) (lift-if 1) (spread (split 1) ((then (flatten) (expand "eval_ac_noise" 2) (spread (use "eval_pd_noise_rec_pds_def") ((then (assert) (expand_ol) (replaces -1) (use "eval_pd_noise_rec_pds_def") (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1) (spread (use "eval_pd_noise_rec_pds_def") ((then (expand_ol) (replaces -1) (assert) (typepred "nextfreeidx") (spread (use "gnbi_updb_2") ((then (assert) (hide 2) (replaces "nwidxs" -1) (spread (use "member_nats") ((then (assert) (flatten) (typepred "i_1") (typepred "nextfreeidx") (expand "last_idx_in_box") (assert)) (then (replaces "newoff" 1) (hide-all-but (1 "pow <= 1")) (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert))))) (assert)))) (then (flatten) (expand "eval_ac_noise" 1) (use "eval_pd_noise_rec_pds_def") (assert) (expand_ol) (replaces -1 1) (spread (use "eval_pd_noise_rec_pds_def") ((expand_ol) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)))))))) (then (flatten) (assert) (replaces "single intervals in box" 1 :dir RL) (spread (use "gnbi_updb_2") ((then (assert) (hide 1) (replaces "nwidxs" -1) (spread (use "member_nats") ((then (assert) (flatten) (typepred "i_1") (typepred "nextfreeidx") (grind)) (then (replaces "newoff" 1) (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert)))))))) (then (expand "compatible_pairs_on?") (expand "powvar?") (skeep* 1) (spread (case "i_1=0") ((then (replaces -1) (expand "nth" 1) (expand "varidx_powvar") (expand "eval_ACExpr_Env" 1) (expand "eval" 1) (expand "vars_in_box_compatible?") (inst "N vars in box" "idx") (flatten) (expand "eval" 1) (replace -7 :dir RL) (replace "N vars in box" 1 :dir RL) (replace "acRes" 1) (spread (split 1) ((spread (use "containment_pow_var_ac") ((then (assert) (spread (split 1) ((then (hide 2) (replaces "varac") (expand "nth_ac") (spread (use "eval_updb_no_idxs") ((then (assert) (hide 2) (skolem 1 "k") (flatten) (use "idxs_ac_var_ac") (assert) (replaces -1) (replaces "nwidxs" -1) (spread (use "member_nats") ((then (assert) (typepred "nextfreeidx") (grind)) (then (replaces "newoff" 1) (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (grind)))) (then (hide-all-but (1 "varac not single value")) (grind))))) (then (hide 2) (flatten) (replaces "nwidxs" -1) (spread (use "member_nats") ((then (assert) (flatten) (typepred "nextfreeidx") (expand "last_idx_in_box") (expand ">") (replaces "varac") (use "last_idx_box") (expand ">=") (expand "next_idx") (expand "last_idx") (expand "last_ol") (assert) (grind)) (then (replaces "newoff" 1) (assert))))) (then (hide 2) (use "pow_var_compatible_noise") (grind))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (grind)))) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert)))) (spread (use "pow_var_compatible_noise") ((then (replace "varac" 1) (propax)) (then (hide-all-but 1) (grind))))))) (spread (inst "cache comp pairs on" "i_1 -1 ") ((then (inst "cache comp pairs on" "n") (expand "nth" 2) (assert) (flatten) (replaces "cache comp pairs on" 2 :dir RL) (spread (split 2) ((spread (use "eval_updb_no_idxs") ((spread (split -1) ((propax) (then (hide 2) (skeep) (expand "idxs_bounded") (inst "cache idxs bound" "i_1 - 1") (expand "idxs_ac") (expand "next_idx") (use "beyond_last_idx_notmember") (assert) (replaces "nwidxs" -1) (spread (use "member_nats") ((assert) (then (replaces "newoff" 1) (assert))))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (grind)))) (then (hide-all-but (1 "varac not single value")) (grind)))) (then (flatten) (assert) (expand "pow_var_compatible?") (flatten) (assert) (skeep) (inst?) (spread (case "get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                                                                                                              upd_noise_burst(N,
                                                                                                                                                              nwidxs,
                                                                                                                                                              LAMBDA
                                                                                                                                                              (i: nat):
                                                                                                                                                              (get_noise_by_idx
                                                                                                                                                               (car(pd(varac))`1, N)
                                                                                                                                                               ^
                                                                                                                                                               (2 + i)))) = get_noise_by_idx(nth(nth(cache, i_1 - 1)`3, i_2),
                                                                                                                                              N)") ((then (replaces -1) (spread (case "get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))),
                                                                                                                                                                0)`1,
                                                                                                                                                            upd_noise_burst(N,
                                                                                                                                                                            nwidxs,
                                                                                                                                                                            LAMBDA
                                                                                                                                                                            (i: nat):
                                                                                                                                                                            (get_noise_by_idx
                                                                                                                                                                             (car(pd(varac))`1, N)
                                                                                                                                                                             ^
                                                                                                                                                                             (2 + i)))) = get_noise_by_idx(nth(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))),
                                                                                                                                                                0)`1,
                                                                                                                                                            N)") ((replaces -1) (then (hide 2) (spread (use "gnbi_updb_2") ((then (assert) (hide 1) (replace "nwidxs" -1) (expand "nth" -1 1) (spread (use "member_nats") ((then (assert) (hide -2) (flatten) (lemma "last_idx_box") (inst? -1 :where -2) (expand "next_idx") (expand "last_idx") (spread (case "NOT null?(pd(nth_ac(box, varidx_powvar(nth(cache, i_1 - 1)`1))))") ((then (assert) (lemma "olidx_car_last[nzBaseType]") (inst? -1 :where 1) (assert) (typepred "nextfreeidx") (assert) (expand "car_ol") (assert)) (grind)))) (then (replaces "newoff" 1) (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert)))))))) (then (hide 2) (spread (use "gnbi_updb_2") ((then (assert) (hide 1) (hide "cache comp pairs on") (replace "nwidxs" -1) (spread (use "member_nats") ((then (assert) (hide -2) (flatten) (expand "idxs_bounded") (inst? "cache idxs bound") (use "cache_powvar_correct") (expand "CacheData_correct?") (expand "powvar?") (with-labels (flatten -1) (("cache_k-1`3 length" "cache_k-1`3 precond hold" "cache_k-1`2 pow_var_ac" "UNKNOWN"))) (replace "cache_k-1`2 pow_var_ac" "cache idxs bound") (lemma "next_idx_pow_var_ac") (inst? -1 :where "cache idxs bound") (lift-if -1) (spread (split -1) ((then (flatten) (grind)) (then (flatten) (spread (split -1) ((grind) (then (flatten) (expand ">=") (replace -1 "cache idxs bound") (typepred "i_2") (hide-all-but (-6 -1 "cache idxs bound")) (spread (case "i_2 = opn(nth(cache, i_1 - 1)`1) - 2") ((then (hide -2) (replaces -1 :dir RL) (assert)) (spread (case "i_2 < opn(nth(cache, i_1 - 1)`1) - 2") ((then (hide -2 1) (lemma "nth_ol[nat,<]") (inst -1 "nth(cache, i_1-1)`3" "opn(nth(cache, i_1-1)`1) - 2" "i_2") (assert)) (assert)))))))))))) (then (replaces "newoff") (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value")) (skeep) (spread (use "power_Epsilon_is_Epsilon") ((then (flatten) (assert)) (then (expand "length") (assert))))) (then (hide-all-but (1 "varac not single value")) (expand "length") (assert)))))))) (then (typepred "i_1") (hide-all-but (-1 1 2)) (grind))))))))) (then (hide-all-but (1 "varac not single value")) (skeep) (assert) (use "power_Epsilon_is_Epsilon") (flatten) (assert))))) (then (replaces "newoff") (expand ">=") (hide-all-but (1 "pow <= 1")) (spread (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") ((then (replaces -1) (spread (case "1<=(pow - 1)") ((then (name-replace "A" "pow-1") (assert)) (grind)))) (grind)))) (then (typepred "cache") (expand "idxs_bounded") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (replaces "acRes") (use "next_idx_pow_var_ac") (replaces -1) (lift-if 1) (spread (split 1) ((then (flatten) (typepred "nwidxs") (spread (case "length(nwidxs)=0") ((assert) (grind)))) (then (flatten) (replaces "newoff") (assert) (expand ">=") (replaces "nwidxs") (typepred "nats(nextfreeidx, nextfreeidx - 2 + pow)") (inst -5 "pow-2") (assert))))) (then (expand "nth" 2) (assert) (inst?) (replaces "newoff") (hide-all-but (2 -3 "pow <= 1")) (spread (case "nextfreeidx - 1 + pow = nextfreeidx + (pow - 1)") ((then (replaces -1) (spread (case "1<=(pow - 1)") ((then (name-replace "A" "pow-1") (assert)) (grind)))) (grind)))))))))) nil nil) ((nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (Env type-eq-decl nil affine_box nil) (lt_idx_strict_order formula-decl nil indexed_list structures) (eval_pd_noise_rec_pds_def formula-decl nil affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (power_Epsilon_is_Epsilon formula-decl nil affine_pow nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (member_nats formula-decl nil affine_pow nil) (gnbi_updb_2 formula-decl nil affine nil) (ac_proj_pd formula-decl nil affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (powvar? const-decl "bool" affine_expr nil) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (containment_pow_var_ac formula-decl nil affine_pow nil) (represents_var? const-decl "bool" affine nil) (next_idx const-decl "nat" affine nil) (eval_updb_no_idxs formula-decl nil affine nil) (idxs_ac_var_ac formula-decl nil affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_idx const-decl "int" indexed_list structures) (SingInterval? const-decl "bool" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (last_ol def-decl "T" ordered_list structures) (last_idx_box formula-decl nil affine_box nil) (pow_var_compatible_noise formula-decl nil affine_pow nil) (eval def-decl "real" interval_expr interval_arith) (varidx_powvar const-decl "nat" affine_expr nil) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (nth_ol formula-decl nil ordered_list structures) (next_idx_pow_var_ac formula-decl nil affine_pow nil) (olidx_car_last formula-decl nil indexed_list structures) (idxs_ac const-decl "list[nat]" affine nil) (beyond_last_idx_notmember formula-decl nil affine nil) (upd_noise_burst const-decl "Noise" affine nil) (nzBaseType type-eq-decl nil affine nil) (get_noise_by_idx def-decl "Epsilon" affine nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.cache1" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.newid1)(cache)}"))) (RE2AC_TCC78 0 (RE2AC_TCC71-1 nil 3632130329 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (null_ol? const-decl "bool" ordered_list structures) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith) (real_minus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (restrict const-decl "R" restrict nil)) nil (RE2AC termination "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re2, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.newid1, affine_expr_Eval_fnd.cache1)" "nil"))) (RE2AC_TCC79 0 (RE2AC_TCC79-1 nil 3789916158 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length_singleton formula-decl nil more_list_props structures) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC80 0 (RE2AC_TCC72-2 nil 3632130837 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length_singleton formula-decl nil more_list_props structures) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (next_idx const-decl "nat" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "affine_expr_Eval_fnd.res2" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)")) (RE2AC_TCC72-1 nil 3632130329 ("" (subtype-tcc) nil nil) nil nil (RE2AC subtype "affine_expr_Eval_fnd.res2" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)"))) (RE2AC_TCC81 0 (RE2AC_TCC73-2 nil 3637403131 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (next_idx const-decl "nat" affine nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (length_singleton formula-decl nil more_list_props structures) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.cache2" "(list_adt[CacheData].cons?)")) (RE2AC_TCC73-1 nil 3632130329 ("" (termination-tcc) nil nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Env type-eq-decl nil affine_box nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (pow_var_compatible? const-decl "bool" affine_pow nil) (nth_ac const-decl "AffineCombination" affine_box nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.cache2" "(list_adt[CacheData].cons?)"))) (RE2AC_TCC82 0 (RE2AC_TCC74-1 nil 3632130329 ("" (termination-tcc) nil nil) ((ordered_list? def-decl "bool" ordered_list structures)) nil (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC83 0 (RE2AC_TCC75-2 nil 3767022444 ("" (skeep*) (("" (assert) (("" (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (with-labels (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten)) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (("" (deftactic typepred_res1 nil (with-labels (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten)) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (nth def-decl "T" list_props nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (length def-decl "nat" list_props nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (last_ol def-decl "T" ordered_list structures) (nth_ac const-decl "AffineCombination" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (sub_ac_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (sub_pd_pd const-decl "ErrorTerms" affine nil) (null_ol? const-decl "bool" ordered_list structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]")) (RE2AC_TCC75-1 nil 3632130329 ("" (then (skeep*) (replaces -1) (typepred "res1") (assert) (replaces -5 :dir RL) (flatten) (assert) (expand "compatible_pairs?") (propax)) nil nil) ((vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (gt_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC84 0 (RE2AC_TCC76-2 nil 3767022805 ("" (skeep*) (("" (assert) (("" (hide -11) (("" (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (("" (deftactic typepred_res2 nil (with-labels (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten)) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (("" (deftactic typepred_res1 nil (with-labels (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten)) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (split 3) (("1" (grind) nil nil) ("2" (replaces "result") (("2" (assert) (("2" (typepred_res1) (("2" (typepred_res2) (("2" (skolem "cache2-form" "l2") (("2" (skolem "cache1-form" "l1") (("2" (replace "cache1-form" "cache2-form") (("2" (replace "cache2-form" 3) (("2" (inst 3 "cons((re, sub_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") (("1" (hide-all-but 3) (("1" (expand "append" 1 3) (("1" (use "append_assoc[CacheData]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred_res2) (("3" (skolem "N2" "N2") (("3" (with-labels (flatten) (("N2 vars in box comp" "N2 compatible pairs"))) (("3" (inst 2 "N2") (("3" (assert) (("3" (expand "compatible_pairs_on?") (("3" (skeep) (("3" (case "i=0") (("1" (skeep 2) (("1" (replaces -1) (("1" (expand "nth" 2) (("1" (replace "result") (("1" (assert) (("1" (expand "powvar?" 2) (("1" (expand "eval_ACExpr_Env" 2) (("1" (expand "eval" 2) (("1" (replaces "re") (("1" (assert) (("1" (use "containment_sub") (("1" (assert) (("1" (hide 3) (("1" (split 1) (("1" (typepred_res1) (("1" (replaces "re1" :dir RL) (("1" (skolem "N1" "N1") (("1" (with-labels (flatten) (("N1 vars in box comp" "N1 compatible pairs"))) (("1" (case "FORALL (i: below(length(cache1))):
                                                                                                                                                                                                                                                      eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                                                                                                       eval_ac_noise(nth(cache1, i)`2, N1)") (("1" (replace "ac1") (("1" (inst -1 "0") (("1" (expand "nth" -1) (("1" (replaces -1) (("1" (expand "compatible_pairs_on?" "N1 compatible pairs") (("1" (inst "N1 compatible pairs" "0") (("1" (inst "N1 compatible pairs" "n") (("1" (expand "nth" "N1 compatible pairs") (("1" (flatten) (("1" (expand "varidx_powvar") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?" "N1 compatible pairs") (("2" (skeep) (("2" (inst "N1 compatible pairs" "i!1") (("2" (inst "N1 compatible pairs" "n") (("2" (skolem "cache2-form" "l2") (("2" (replace "cache2-form" "N2 compatible pairs") (("2" (inst "N2 compatible pairs" "length(l2)+i!1") (("1" (inst "N2 compatible pairs" "n") (("1" (case "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") (("1" (flatten) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (assert) (("2" (use "more_list_props[CacheData].nth_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace "cache2-form" 1) (("2" (use "length_append[CacheData]") (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst "N2 compatible pairs" "0") (("1" (inst "N2 compatible pairs" "n") (("1" (expand "nth" "N2 compatible pairs") (("1" (assert) (("1" (expand "varidx_powvar") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "j" "i-1") (("2" (typepred "i") (("2" (expand "length") (("2" (expand "nth" 3) (("2" (assert) (("2" (replace -2) (("2" (replace "result") (("2" (assert) (("2" (inst "N2 compatible pairs" "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replaces "result") (("4" (assert) (("4" (typepred_res2) (("4" (typepred_res1) nil nil)) nil)) nil)) nil) ("5" (replaces "result") (("5" (assert) (("5" (expand "idxs_bounded") (("5" (skeep) (("5" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (use "next_idx_sub_ac_ac") (("1" (expand ">=") (("1" (typepred_res2) (("1" (typepred_res1) (("1" (expand "idxs_bounded") (("1" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (inst "cache2-idxs_bound" "0") (("1" (expand "nth" "cache2-idxs_bound") (("1" (replace "ac2" :dir RL) (("1" (hide-all-but (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -11)) (("1" (expand "max") (("1" (lift-if -4) (("1" (split -4) (("1" (flatten) (("1" (expand ">=") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred_res2) (("2" (expand "idxs_bounded") (("2" (inst "cache2-idxs_bound" "i-1") (("1" (expand "nth" 3) (("1" (propax) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (next_idx_sub_ac_ac formula-decl nil affine nil) (i skolem-const-decl "below(length(cons((re, sub_ac_ac(ac1, ac2), null), cache2)))" affine_expr_Eval_fnd nil) (ac2 skolem-const-decl "AffineCombination" affine_expr_Eval_fnd nil) (ac1 skolem-const-decl "AffineCombination" affine_expr_Eval_fnd nil) (re skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nth def-decl "T" list_props nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (containment_sub formula-decl nil affine nil) (Env type-eq-decl nil box interval_arith) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (eval_ac_noise const-decl "real" affine nil) (below type-eq-decl nil nat_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (cache1 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval_fnd nil) (varidx_powvar const-decl "nat" affine_expr nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nth_ac const-decl "AffineCombination" affine_box nil) (SingInterval? const-decl "bool" affine nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length_append formula-decl nil list_props nil) (nth_append formula-decl nil more_list_props structures) (cache2 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval_fnd nil) (i!1 skolem-const-decl "below(length(cache1))" affine_expr_Eval_fnd nil) (l2 skolem-const-decl "list[CacheData]" affine_expr_Eval_fnd nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (eval def-decl "real" interval_expr interval_arith) (powvar? const-decl "bool" affine_expr nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (null adt-constructor-decl "(null?)" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (append_assoc formula-decl nil list_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (null_ol? const-decl "bool" ordered_list structures) (sub_pd_pd const-decl "ErrorTerms" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (sub_ac_ac const-decl "AffineCombination" affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC76-1 nil 3632130329 ("" (then (skeep*) (replaces -1) (typepred "res1") (assert) (replaces -5 :dir RL) (flatten) (assert) (expand "compatible_pairs?") (propax)) nil nil) ((vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC85 0 (RE2AC_TCC77-1 nil 3632130329 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (<< adt-def-decl "(strict_well_founded?[IntervalExpr])" IntervalExpr_adt interval_arith) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (restrict const-decl "R" restrict nil)) nil (RE2AC termination "affine_expr_Eval_fnd.RE2AC(affine_expr_Eval_fnd.re1, affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs, affine_expr_Eval_fnd.nextfreeidx, affine_expr_Eval_fnd.cache)" "nil"))) (RE2AC_TCC86 0 (RE2AC_TCC86-1 nil 3789916158 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length_singleton formula-decl nil more_list_props structures) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC87 0 (RE2AC_TCC78-2 nil 3767022785 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (next_idx const-decl "nat" affine nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (length_singleton formula-decl nil more_list_props structures) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)")) (RE2AC_TCC78-1 nil 3632130329 ("" (subtype-tcc) nil nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Env type-eq-decl nil affine_box nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length_singleton formula-decl nil more_list_props structures) (pow_var_compatible? const-decl "bool" affine_pow nil) (next_idx const-decl "nat" affine nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures)) nil (RE2AC subtype "affine_expr_Eval_fnd.res1" "(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?)"))) (RE2AC_TCC88 0 (RE2AC_TCC79-2 nil 3632131028 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length_singleton formula-decl nil more_list_props structures) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (next_idx const-decl "nat" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "affine_expr_Eval_fnd.cache1" "(list_adt[CacheData].cons?)")) (RE2AC_TCC79-1 nil 3632130329 ("" (subtype-tcc) nil nil) nil nil (RE2AC subtype "affine_expr_Eval_fnd.cache1" "(list_adt[CacheData].cons?)"))) (RE2AC_TCC89 0 (RE2AC_TCC80-2 nil 3637403250 ("" (grind) nil nil) ((ordered_list? def-decl "bool" ordered_list structures)) nil (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]")) (RE2AC_TCC80-1 nil 3632130329 ("" (termination-tcc) nil nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Env type-eq-decl nil affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (last_ol def-decl "T" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Epsilon type-eq-decl nil affine nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (null_ol? const-decl "bool" ordered_list structures) (sub_pd_pd const-decl "ErrorTerms" affine nil) (sub_ac_ac const-decl "AffineCombination" affine nil)) nil (RE2AC subtype "list_adt[nat].null" "ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)]"))) (RE2AC_TCC90 0 (RE2AC_TCC81-1 nil 3632130329 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (last_ol def-decl "T" ordered_list structures) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (minus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (null_ol? const-decl "bool" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (neg_ac const-decl "AffineCombination" affine nil)) nil (RE2AC subtype "affine_expr_Eval_fnd.result" "[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]"))) (RE2AC_TCC91 0 (RE2AC_TCC82-2 nil 3767022969 ("" (skeep*) (("" (assert) (("" (hide -7) (("" (apply (then (label "result" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (("" (deftactic typepred_res1 nil (with-labels (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten)) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (("" (split 2) (("1" (grind) nil nil) ("2" (replaces "result") (("2" (assert) (("2" (typepred_res1) (("2" (skolem "cache1-form" "l1") (("2" (replace "cache1-form" 2) (("2" (inst 2 "cons((re, neg_ac(ac1), null)::CacheData, l1)") (("1" (hide-all-but 2) (("1" (expand "append" 1 2) (("1" (propax) nil nil)) nil)) nil) ("2" (expand "ordered_list?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred_res1) (("3" (skolem "N1" "N1") (("3" (inst 2 "N1") (("3" (with-labels (flatten "N1") (("N1 vars in box" "N1 comp on pairs"))) (("3" (assert) (("3" (expand "compatible_pairs_on?") (("3" (skeep* 2) (("3" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 2) (("1" (replace "result") (("1" (assert) (("1" (expand "powvar?") (("1" (expand "eval_ACExpr_Env" 2) (("1" (expand "eval" 2) (("1" (replaces "re") (("1" (assert) (("1" (use "containment_neg") (("1" (assert) (("1" (hide 3) (("1" (inst "N1 comp on pairs" "0") (("1" (inst "N1 comp on pairs" "n") (("1" (with-labels (flatten "N1 comp on pairs") (("eval" "powvar"))) (("1" (expand "nth" "eval") (("1" (assert) (("1" (expand "varidx_powvar") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 3) (("2" (assert) (("2" (inst "N1 comp on pairs" "i-1") (("1" (inst "N1 comp on pairs" "n") (("1" (replaces "result") (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replaces "result") (("4" (assert) (("4" (typepred_res1) nil nil)) nil)) nil) ("5" (replaces "result") (("5" (assert) (("5" (expand "idxs_bounded") (("5" (skeep) (("5" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (use "next_idx_neg_ac") (("1" (expand ">=") (("1" (typepred_res1) (("1" (expand "idxs_bounded") (("1" (inst "cache1-idxs_bound" "0") (("1" (expand "nth" "cache1-idxs_bound") (("1" (replace "ac1" :dir RL) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred_res1) (("2" (expand "idxs_bounded") (("2" (inst "cache1-idxs_bound" "i-1") (("1" (expand "nth" 3) (("1" (propax) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((neg_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (null_ol? const-decl "bool" ordered_list structures) (minus_real_is_real application-judgement "real" reals nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null adt-constructor-decl "(null?)" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (containment_neg formula-decl nil affine nil) (Env type-eq-decl nil box interval_arith) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (varidx_powvar const-decl "nat" affine_expr nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (SingInterval? const-decl "bool" affine nil) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (eval_ac_noise const-decl "real" affine nil) (cache1 skolem-const-decl "(correct_cache?(box))" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (eval def-decl "real" interval_expr interval_arith) (powvar? const-decl "bool" affine_expr nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (i skolem-const-decl "below(length(result`2))" affine_expr_Eval_fnd nil) (result skolem-const-decl "[nat, (cons?)]" affine_expr_Eval_fnd nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (re skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (ac1 skolem-const-decl "AffineCombination" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(cons((re, neg_ac(ac1), null), cache1)))" affine_expr_Eval_fnd nil) (next_idx_neg_ac formula-decl nil affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}")) (RE2AC_TCC82-1 nil 3632131428 ("" (then (skeep*) (assert) (hide -11) (apply (then (label "result" -10) (label "ac2" -9) (label "cache2" -8) (label "newid2" -7) (label "res2" -6) (label "ac1" -5) (label "cache1" -4) (label "newid1" -3) (label "res1" -2) (label "re" -1))) (deftactic typepred_res2 nil (with-labels (then (typepred "res2") (replace "cache2" -1 :dir RL) (replace "newid2" -1 :dir RL) (assert) (flatten)) (("cache2 not null" "re2" "cache2-form" "N2" "newid2-prop" "cache2-idxs_bound" "UNKNOWN")))) (deftactic typepred_res1 nil (with-labels (then (typepred "res1") (replace "cache1" -1 :dir RL) (replace "newid1" -1 :dir RL) (assert) (flatten)) (("cache1 not null" "re1" "cache1-form" "N1" "newid1-prop" "cache1-idxs_bound" "UNKNOWN")))) (spread (split 3) ((grind) (then (replaces "result") (assert) (typepred_res1) (typepred_res2) (skolem "cache2-form" "l2") (skolem "cache1-form" "l1") (replace "cache1-form" "cache2-form") (replace "cache2-form" 3) (spread (inst 3 "cons((re, sub_ac_ac(ac1, ac2), null)::CacheData, append(l2,l1))") ((then (hide-all-but 3) (expand "append" 1 3) (use "append_assoc[CacheData]") (assert)) (grind)))) (then (typepred_res2) (skolem "N2" "N2") (with-labels (flatten) (("N2 vars in box comp" "N2 compatible pairs"))) (inst 2 "N2") (assert) (expand "compatible_pairs_on?") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 2) (replace "result") (assert) (expand "eval_ACExpr_Env" 2) (replaces "re") (assert) (use "containment_sub") (assert) (hide 3) (spread (split 1) ((then (typepred_res1) (replaces "re1" :dir RL) (skolem "N1" "N1") (with-labels (flatten) (("N1 vars in box comp" "N1 compatible pairs"))) (spread (case "FORALL (i: below(length(cache1))):
                                                                                                                                                                                                          eval_ac_noise(nth(cache1, i)`2, N2) =
                                                                                                                                                                                                           eval_ac_noise(nth(cache1, i)`2, N1)") ((then (replace "ac1") (spread (inst -1 "0") ((then (expand "nth" -1) (replaces -1) (expand "compatible_pairs_on?" "N1 compatible pairs") (spread (inst "N1 compatible pairs" "0") ((then (expand "nth" "N1 compatible pairs") (flatten)) (then (expand "length") (assert))))) (then (expand "length") (assert))))) (then (expand "compatible_pairs_on?" "N1 compatible pairs") (skeep) (inst "N1 compatible pairs" "i!1") (skolem "cache2-form" "l2") (replace "cache2-form" "N2 compatible pairs") (spread (inst "N2 compatible pairs" "length(l2)+i!1") ((spread (case "nth(append(l2, cache1), length(l2) + i!1) = nth(cache1, i!1)") ((then (flatten) (replaces -1) (assert)) (then (hide-all-but 1) (spread (use "nth_append[CacheData]") ((assert) (then (use "length_append[CacheData]") (replaces -1) (typepred "i!1") (assert))))))) (then (replace "cache2-form" 1) (use "length_append[CacheData]") (replaces -1) (assert)))))))) (spread (inst "N2 compatible pairs" "0") ((then (expand "nth" "N2 compatible pairs") (assert)) (then (expand "length") (assert))))))) (then (name "j" "i-1") (typepred "i") (expand "length") (expand "nth" 3) (assert) (replace -2) (replace "result") (assert) (inst "N2 compatible pairs" "j"))))) (then (replaces "result") (assert) (typepred_res2) (typepred_res1)) (then (replaces "result") (assert) (expand "idxs_bounded") (skeep) (spread (case "i=0") ((then (replaces -1) (expand "nth" 1) (use "next_idx_sub_ac_ac") (expand ">=") (typepred_res2) (typepred_res1) (expand "idxs_bounded") (spread (inst "cache1-idxs_bound" "0") ((then (expand "nth" "cache1-idxs_bound") (replace "ac1" :dir RL) (spread (inst "cache2-idxs_bound" "0") ((then (expand "nth" "cache2-idxs_bound") (replace "ac2" :dir RL) (hide-all-but (3 "cache2-idxs_bound" "newid2-prop" "cache1-idxs_bound" -11)) (expand "max") (lift-if -4) (spread (split -4) ((then (flatten) (expand ">=") (assert)) (then (flatten) (assert))))) (grind)))) (grind)))) (then (typepred_res2) (expand "idxs_bounded") (spread (inst "cache2-idxs_bound" "i-1") ((then (expand "nth" 3) (propax)) (then (typepred "i") (grind))))))))))) nil nil) ((null_ol? const-decl "bool" ordered_list structures) (sub_pd_pd const-decl "ErrorTerms" affine nil) (sub_ac_ac const-decl "AffineCombination" affine nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (nth_ac const-decl "AffineCombination" affine_box nil) (last_ol def-decl "T" ordered_list structures) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Some(affine_expr_Eval_fnd.result)" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (RE2AC_TCC92 0 (RE2AC_TCC92-1 nil 3789916158 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (var_ac const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (SingInterval? const-decl "bool" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (length_singleton formula-decl nil more_list_props structures) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (next_idx const-decl "nat" affine nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (RE2AC subtype "Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].None" "{result: Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].Maybe | booleans.IMPLIES(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].some?(result),      ((booleans.NOT)(list_adt[CacheData].null?(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (list_adt[CacheData].car(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2)`1 = affine_expr_Eval_fnd.re) AND (EXISTS (l: list_adt[CacheData].list): Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2 = list_props[CacheData].append(l, affine_expr_Eval_fnd.cache)) AND (EXISTS (N: affine.Noise): booleans.AND(affine_box.vars_in_box_compatible?(N)(affine_expr_Eval_fnd.box)(affine_expr_Eval_fnd.vs), affine_expr_Eval_fnd.compatible_pairs_on?(affine_expr_Eval_fnd.box, affine_expr_Eval_fnd.vs)(N)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))) AND (reals.>=(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1, affine_expr_Eval_fnd.nextfreeidx)) AND affine_expr_Eval_fnd.idxs_bounded(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`1)(Maybe[[nat, (affine_expr_Eval_fnd.correct_cache?(affine_expr_Eval_fnd.box))]].val(result)`2))}"))) (iacniig_RE2AC_preservation_TCC1 0 (iacniig_RE2AC_preservation_TCC1-1 nil 3638728665 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (length_singleton formula-decl nil more_list_props structures) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil)) nil (iacniig_RE2AC_preservation subtype "affine_expr_Eval_fnd.nextfreeidx" "nat"))) (iacniig_RE2AC_preservation_TCC2 0 (iacniig_RE2AC_preservation_TCC2-1 nil 3639415198 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (next_idx const-decl "nat" affine nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (length_singleton formula-decl nil more_list_props structures) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (iacniig_RE2AC_preservation subtype "affine_expr_Eval_fnd.nextfreeidx" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box))}"))) (iacniig_RE2AC_preservation 0 (iacniig_RE2AC_preservation-1 nil 3638722505 ("" (skolem 1 ("box" "vs" "_")) (("" (induct "re") (("1" (assert) nil nil) ("2" (typepred "re!1") (("2" (assert) nil nil)) nil) ("3" (skeep*) (("3" (hide -1) (("3" (expand "idxs_ac_cache_not_in_idx_gap") (("3" (expand "RE2AC") (("3" (skeep :preds? t) (("3" (expand "RE2AC") (("3" (case "i = 0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "idxs_ac") (("1" (expand "idxs_pd") (("1" (expand "const_ac") (("1" (expand_ol) (("1" (assert) (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep*) (("4" (hide -1) (("4" (expand "RE2AC") (("4" (lift-if -2) (("4" (assert) (("4" (split -2) (("1" (expand "idxs_ac_cache_not_in_idx_gap" 1) (("1" (expand "nth" 1) (("1" (skeep) (("1" (case "i=0") (("1" (assert) (("1" (typepred "cache_get(cache)(VARIDX(VARIDX1_var))") (("1" (assert) (("1" (skolem -1 "cidx") (("1" (flatten) (("1" (replace -2 :dir RL :hide? t) (("1" (expand "idxs_ac_cache_not_in_idx_gap" -4) (("1" (inst -4 "cidx") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "idxs_ac_cache_not_in_idx_gap" -2) (("2" (inst -2 "i-1") (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split -1) (("1" (propax) nil nil) ("2" (assert) (("2" (expand "idxs_ac_cache_not_in_idx_gap") (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 3) (("1" (expand "nth_ac") (("1" (expand "var_ac") (("1" (expand "idxs_ac") (("1" (expand "idxs_pd") (("1" (assert) (("1" (expand_ol) (("1" (assert) (("1" (skeep) (("1" (lift-if -2) (("1" (expand "member") (("1" (split -2) (("1" (flatten) (("1" (expand "idxs_pd") (("1" (expand "null_ol?") (("1" (expand "member") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 4) (("2" (assert) (("2" (inst -1 "i-1") (("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (hide -3) (("5" (split -1) (("1" (split -2) (("1" (skeep*) (("1" (expand "RE2AC" -4) (("1" (lift-if -4) (("1" (assert) (("1" (split -4) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand "RE2AC" 3) (("2" (assert) (("2" (inst -1 "first_added_idx" "val
                                                      (RE2AC
                                                       (ADD1_var,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`1" "val
                                                      (RE2AC
                                                       (ADD1_var,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`2") (("1" (inst -2 "first_added_idx" "nextfreeidx" "cache") (("1" (assert) (("1" (assert) (("1" (expand "idxs_ac_cache_not_in_idx_gap" 3) (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 3) (("1" (skeep) (("1" (use "idxs_ac_add_ac_ac") (("1" (assert) (("1" (split -1) (("1" (expand "idxs_ac_cache_not_in_idx_gap" -3) (("1" (inst -3 "0") (("1" (inst -3 "j") (("1" (expand "nth" -3) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "RE2AC(ADD1_var, box, vs, nextfreeidx, cache)") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "idxs_ac_cache_not_in_idx_gap" -2) (("2" (inst -2 "0") (("1" (expand "nth" -2) (("1" (inst -2 "j") (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "RE2AC(ADD2_var, box, vs,
                                         val[[nat, (correct_cache?(box))]]
                                             (RE2AC(ADD1_var, box, vs, nextfreeidx,
                                                    cache))`1,
                                         val[[nat, (correct_cache?(box))]]
                                             (RE2AC(ADD1_var, box, vs, nextfreeidx,
                                                    cache))`2)") (("2" (assert) (("2" (flatten) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 4) (("2" (assert) (("2" (expand "idxs_ac_cache_not_in_idx_gap" -1) (("2" (inst -1 "i-1") (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "nextfreeidx") (("2" (grind) nil nil)) nil) ("3" (typepred "RE2AC(ADD1_var, box, vs, nextfreeidx, cache)") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "ADD2_var") (("2" (propax) nil nil)) nil)) nil) ("2" (typepred "ADD1_var") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("6" (expand "RE2AC") (("6" (propax) nil nil)) nil) ("7" (skeep) (("7" (hide -2) (("7" (split -1) (("1" (skeep*) (("1" (expand "RE2AC" -3) (("1" (lift-if -3) (("1" (split -3) (("1" (assert) nil nil) ("2" (assert) (("2" (expand "RE2AC" 2) (("2" (assert) (("2" (expand "idxs_ac_cache_not_in_idx_gap" 2) (("2" (skolem 2 "i") (("2" (case "i=0") (("1" (hide -2) (("1" (expand "nth" 2) (("1" (assert) (("1" (skolem 2 "j") (("1" (flatten) (("1" (lemma "idxs_ac_neg_ac") (("1" (inst -1 "car(val(RE2AC
                                    (NEG1_var,
                                     box,
                                     vs,
                                     nextfreeidx,
                                     cache))`2)`2" "j") (("1" (assert) (("1" (reveal -2) (("1" (inst -1 "first_added_idx" "nextfreeidx" "cache") (("1" (assert) (("1" (expand "idxs_ac_cache_not_in_idx_gap" -1) (("1" (inst -1 "0") (("1" (inst -1 "j") (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "RE2AC(NEG1_var, box, vs, nextfreeidx, cache)") (("2" (assert) (("2" (flatten) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "nth" 3) (("2" (assert) (("2" (inst -1 "first_added_idx" "nextfreeidx" "cache") (("2" (assert) (("2" (expand "idxs_ac_cache_not_in_idx_gap") (("2" (inst -1 "i-1") (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "NEG1_var") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("8" (skeep) (("8" (hide -3) (("8" (split -1) (("1" (split -2) (("1" (skeep*) (("1" (expand "RE2AC" -4) (("1" (lift-if -4) (("1" (assert) (("1" (split -4) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand "RE2AC" 3) (("2" (assert) (("2" (inst -1 "first_added_idx" "val
                                                                  (RE2AC
                                                                   (SUB1_var,
                                                                    box,
                                                                    vs,
                                                                    nextfreeidx,
                                                                    cache))`1" "val
                                                                  (RE2AC
                                                                   (SUB1_var,
                                                                    box,
                                                                    vs,
                                                                    nextfreeidx,
                                                                    cache))`2") (("1" (inst -2 "first_added_idx" "nextfreeidx" "cache") (("1" (assert) (("1" (assert) (("1" (expand "idxs_ac_cache_not_in_idx_gap" 3) (("1" (skeep) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 3) (("1" (skeep) (("1" (use "idxs_ac_sub_ac_ac") (("1" (assert) (("1" (split -1) (("1" (expand "idxs_ac_cache_not_in_idx_gap" -3) (("1" (inst -3 "0") (("1" (inst -3 "j") (("1" (expand "nth" -3) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "RE2AC(SUB1_var, box, vs, nextfreeidx, cache)") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "idxs_ac_cache_not_in_idx_gap" -2) (("2" (inst -2 "0") (("1" (expand "nth" -2) (("1" (inst -2 "j") (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "RE2AC(SUB2_var, box, vs,
                                                               val[[nat, (correct_cache?(box))]]
                                                                   (RE2AC(SUB1_var, box, vs, nextfreeidx,
                                                                          cache))`1,
                                                               val[[nat, (correct_cache?(box))]]
                                                                   (RE2AC(SUB1_var, box, vs, nextfreeidx,
                                                                          cache))`2)") (("2" (assert) (("2" (flatten) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 4) (("2" (assert) (("2" (expand "idxs_ac_cache_not_in_idx_gap" -1) (("2" (inst -1 "i-1") (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "nextfreeidx") (("2" (grind) nil nil)) nil) ("3" (typepred "RE2AC(SUB1_var, box, vs, nextfreeidx, cache)") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "SUB2_var") (("2" (propax) nil nil)) nil)) nil) ("2" (typepred "SUB1_var") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("9" (skeep*) (("9" (hide -3) (("9" (split -1) (("1" (split -2) (("1" (expand "RE2AC" -4) (("1" (lift-if -4) (("1" (assert) (("1" (split -4) (("1" (expand "RE2AC" 1) (("1" (assert) (("1" (expand "idxs_ac_cache_not_in_idx_gap" 1) (("1" (expand "nth" 1) (("1" (skeep) (("1" (case "i=0") (("1" (assert) (("1" (typepred "cache_get(cache)(MULT(MULT1_var, MULT2_var))") (("1" (assert) (("1" (skolem -1 "cidx") (("1" (flatten) (("1" (replace -2 :dir RL :hide? t) (("1" (expand "idxs_ac_cache_not_in_idx_gap" -6) (("1" (inst -6 "cidx") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "idxs_ac_cache_not_in_idx_gap" -4) (("2" (inst -4 "i-1") (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand "RE2AC" 4) (("2" (assert) (("2" (expand "idxs_ac_cache_not_in_idx_gap" 4) (("2" (skolem 4 "i") (("2" (case "i=0") (("1" (expand "nth" 4) (("1" (assert) (("1" (skolem 4 "j") (("1" (flatten) (("1" (use "idxs_ac_mult_ac_ac") (("1" (assert) (("1" (split -1) (("1" (hide -6) (("1" (inst -4 "first_added_idx" "nextfreeidx" "cache") (("1" (assert) (("1" (expand "idxs_ac_cache_not_in_idx_gap" -4) (("1" (inst -4 "0") (("1" (inst -4 "j") (("1" (expand "nth" -4) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "RE2AC(MULT1_var, box, vs, nextfreeidx, cache)") (("2" (assert) (("2" (flatten) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -6) (("2" (inst -3 "first_added_idx" "val
                                                            (RE2AC
                                                             (MULT1_var,
                                                              box,
                                                              vs,
                                                              nextfreeidx,
                                                              cache))`1" "val
                                                            (RE2AC
                                                             (MULT1_var,
                                                              box,
                                                              vs,
                                                              nextfreeidx,
                                                              cache))`2") (("1" (assert) (("1" (inst -4 "first_added_idx" "nextfreeidx" "cache") (("1" (assert) (("1" (assert) (("1" (expand "idxs_ac_cache_not_in_idx_gap" -3) (("1" (inst -3 "0") (("1" (inst -3 "j") (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "RE2AC(MULT2_var, box, vs,
                                           val[[nat, (correct_cache?(box))]]
                                               (RE2AC(MULT1_var, box, vs, nextfreeidx,
                                                      cache))`1,
                                           val[[nat, (correct_cache?(box))]]
                                               (RE2AC(MULT1_var, box, vs, nextfreeidx,
                                                      cache))`2)") (("2" (assert) (("2" (flatten) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "RE2AC(MULT1_var, box, vs, nextfreeidx, cache)") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (typepred "RE2AC(MULT2_var, box, vs,
                                   val(RE2AC(MULT1_var, box, vs, nextfreeidx, cache))`1,
                                   val(RE2AC(MULT1_var, box, vs, nextfreeidx, cache))`2)") (("3" (assert) (("3" (flatten) (("3" (typepred "RE2AC(MULT1_var, box, vs, nextfreeidx, cache)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 5) (("2" (assert) (("2" (skolem 5 "j") (("2" (inst -1 "first_added_idx" "val
                                                            (RE2AC
                                                             (MULT1_var,
                                                              box,
                                                              vs,
                                                              nextfreeidx,
                                                              cache))`1" "val
                                                            (RE2AC
                                                             (MULT1_var,
                                                              box,
                                                              vs,
                                                              nextfreeidx,
                                                              cache))`2") (("1" (assert) (("1" (inst -2 "first_added_idx" "nextfreeidx" "cache") (("1" (assert) (("1" (assert) (("1" (expand "idxs_ac_cache_not_in_idx_gap" -1) (("1" (inst -1 "i-1") (("1" (inst -1 "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil) ("3" (typepred "RE2AC(MULT1_var, box, vs, nextfreeidx, cache)") (("1" (assert) nil nil) ("2" (ground) nil nil)) nil) ("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "MULT2_var") (("2" (propax) nil nil)) nil)) nil) ("2" (typepred "MULT1_var") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("10" (expand "RE2AC") (("10" (propax) nil nil)) nil) ("11" (skeep*) (("11" (split -1) (("1" (hide -2) (("1" (expand "RE2AC" -3) (("1" (lift-if -3) (("1" (assert) (("1" (split -3) (("1" (flatten) (("1" (split -2) (("1" (propax) nil nil) ("2" (expand "RE2AC" 2) (("2" (assert) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (expand "idxs_ac_cache_not_in_idx_gap" 1) (("1" (skolem 1 "i") (("1" (case "i=0") (("1" (expand "nth" 1) (("1" (assert) (("1" (expand "null_ol") (("1" (skolem 1 "j") (("1" (flatten) (("1" (use "idxs_ac_pow_var_ac") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (expand "idxs_ac_cache_not_in_idx_gap" -4) (("2" (inst -4 "i-1") (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (expand "idxs_ac_cache_not_in_idx_gap" 1) (("1" (skolem 1 "i") (("1" (case "i=0") (("1" (expand "nth" 1) (("1" (assert) (("1" (typepred "cache_get_powvar(cache)
                                           (POW(POW1_var, POW2_var))") (("1" (assert) (("1" (flatten) (("1" (skolem -3 "cidx") (("1" (replace -3 :dir RL :hide? t) (("1" (expand "idxs_ac_cache_not_in_idx_gap" -8) (("1" (inst -8 "cidx") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (expand "idxs_ac_cache_not_in_idx_gap" -5) (("2" (inst -5 "i-1") (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "idxs_ac_cache_not_in_idx_gap" 2) (("1" (skolem 2 "i") (("1" (case "i=0") (("1" (expand "nth" 2) (("1" (assert) (("1" (skolem 2 "j") (("1" (flatten) (("1" (use "idxs_ac_pow_var_ac") (("1" (assert) (("1" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (typepred "cache_get_powvar(cache)(POW(POW1_var, POW2_var))") (("2" (assert) (("2" (flatten) (("2" (skolem -3 "cidx") (("2" (replace -3 :dir RL :hide? t) (("2" (expand "idxs_ac_cache_not_in_idx_gap" -10) (("2" (inst -10 "cidx") (("2" (inst -10 "j") (("2" (assert) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (flatten) (("2" (replace -3 :hide? t) (("2" (split -2) (("1" (flatten) (("1" (lemma "idxs_ac_pow_var_ac_2") (("1" (inst? -1 :where 8) (("1" (assert) (("1" (replace -5 1) (("1" (expand "varidx_powvar" 1) (("1" (lemma "member_take_1[nat]") (("1" (inst -1 "nth(cache, cidx)`3" "POW2_var - 1" "opn(nth(cache, cidx)`1) - 1" "j") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -4) (("2" (expand "varidx_powvar" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 3) (("2" (assert) (("2" (expand "idxs_ac_cache_not_in_idx_gap" -5) (("2" (inst -5 "i-1") (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (split 2) (("1" (flatten) (("1" (expand "idxs_ac_cache_not_in_idx_gap" 1) (("1" (skeep) (("1" (case "i=0") (("1" (expand "nth" 1) (("1" (assert) (("1" (skolem 1 "j") (("1" (flatten) (("1" (use "idxs_ac_pow_var_ac") (("1" (assert) (("1" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (hide -7) (("2" (typepred "cache_get_powvar(cache)(POW(POW1_var, POW2_var))") (("2" (assert) (("2" (flatten) (("2" (skolem -3 "cidx") (("2" (replace -3 :dir RL :hide? t) (("2" (expand "idxs_ac_cache_not_in_idx_gap" -9) (("2" (inst -9 "cidx") (("2" (inst -9 "j") (("2" (assert) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (flatten) (("2" (replace -3 :hide? t) (("2" (case "member(j, take[nat]
                             (nth(cache, cidx)`3,
                              opn(nth(cache, cidx)`1) - 1)) OR
             member(j, nats(nextfreeidx,
                              POW2_var - 1 - opn(nth(cache, cidx)`1) +
                               nextfreeidx))") (("1" (split -1) (("1" (lemma "idxs_ac_pow_var_ac_2") (("1" (inst? -1 :where 10) (("1" (assert) (("1" (replace -5 1) (("1" (expand "varidx_powvar" 1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "member_nats") (("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (split -2) (("1" (flatten) (("1" (hide-all-but (-1 -6 1 2)) (("1" (case "length(append(take[nat]
                             (nth(cache, cidx)`3,
                              opn(nth(cache, cidx)`1) - 1),
                         nats(nextfreeidx,
                              POW2_var - 1 - opn(nth(cache, cidx)`1) +
                               nextfreeidx))) = 
                  POW2_var - 1") (("1" (name-replace "app" "append(take[nat]
                             (nth(cache, cidx)`3,
                              opn(nth(cache, cidx)`1) - 1),
                         nats(nextfreeidx,
                              POW2_var - 1 - opn(nth(cache, cidx)`1) +
                               nextfreeidx))") (("1" (replace -1 -3 :dir RL :hide? t) (("1" (use "take_prop_2[nat]") (("1" (replace -1 -3 :hide? t) (("1" (expand "app") (("1" (use "member_append_fi[nat]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (replace -1 :hide? t) (("2" (typepred "nats(nextfreeidx,
                 POW2_var - 1 - opn(nth(cache, cidx)`1) + nextfreeidx)") (("2" (replace -4 :hide? t) (("2" (use "length_take[nat]") (("2" (replace -1 :hide? t) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (expand "idxs_ac_cache_not_in_idx_gap" -5) (("2" (inst -5 "i-1") (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "idxs_ac_cache_not_in_idx_gap" 2) (("2" (skeep) (("2" (case "i=0") (("1" (expand "nth" 2) (("1" (assert) (("1" (skolem 2 "j") (("1" (flatten) (("1" (use "idxs_ac_pow_var_ac") (("1" (assert) (("1" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (hide -6) (("2" (use "take_nats") (("2" (replace -1 -2 :hide? t) (("2" (use "member_nats") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 3) (("2" (assert) (("2" (expand "idxs_ac_cache_not_in_idx_gap" -4) (("2" (inst -4 "i-1") (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "idxs_ac_cache_not_in_idx_gap" 2) (("2" (skeep) (("2" (case "i=0") (("1" (expand "nth" 2) (("1" (assert) (("1" (skolem 2 "j") (("1" (flatten) (("1" (use "idxs_ac_pow_var_ac") (("1" (assert) (("1" (split -1) (("1" (grind) nil nil) ("2" (flatten) (("2" (hide -5) (("2" (use "take_nats") (("2" (replace -1 -2 :hide? t) (("2" (use "member_nats") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 3) (("2" (assert) (("2" (expand "idxs_ac_cache_not_in_idx_gap" -3) (("2" (inst -3 "i-1") (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "POW1_var") (("2" (propax) nil nil)) nil)) nil)) nil) ("12" (expand "RE2AC") (("12" (propax) nil nil)) nil) ("13" (expand "RE2AC") (("13" (propax) nil nil)) nil) ("14" (expand "RE2AC") (("14" (propax) nil nil)) nil) ("15" (expand "RE2AC") (("15" (propax) nil nil)) nil) ("16" (assert) nil nil) ("17" (assert) nil nil) ("18" (assert) nil nil) ("19" (assert) nil nil) ("20" (assert) nil nil) ("21" (assert) nil nil) ("22" (assert) nil nil) ("23" (assert) nil nil) ("24" (skeep* :preds? t) (("24" (assert) nil nil)) nil) ("25" (expand "RE2AC") (("25" (propax) nil nil)) nil) ("26" (skeep* :preds? t) (("26" (assert) nil nil)) nil) ("27" (skeep* :preds? t) (("27" (assert) nil nil)) nil)) nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_ac_cache_not_in_idx_gap const-decl "bool" affine_expr_Eval_fnd nil) (> const-decl "bool" reals nil) (RE2AC def-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
    LET res = val(result)`2, newnidx = val(result)`1 IN
           (NOT null?(res)) AND (car(res)`1 = re)
       AND (EXISTS (l: list[CacheData]): res = append(l, cache))
       AND (EXISTS (N: Noise):
              vars_in_box_compatible?(N)(box)(vs) AND
               compatible_pairs_on?(box, vs)(N)(res))
       AND (newnidx >= nextfreeidx) AND idxs_bounded(newnidx)(res)
       AND correct_cache?(box)(res)}" affine_expr_Eval_fnd nil) (IntervalExpr_induction formula-decl nil IntervalExpr_adt interval_arith) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (CONST1_var skolem-const-decl "[Unit -> real]" affine_expr_Eval_fnd nil) (CONST2_var skolem-const-decl "(Includes?(CONST1_var(unit)))" affine_expr_Eval_fnd nil) (first_added_idx skolem-const-decl "upfrom(1 + last_idx_in_box(box))" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "upfrom(first_added_idx)" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(val(RE2AC(CONST(CONST1_var, CONST2_var), box, vs, nextfreeidx,
                       cache))`2))" affine_expr_Eval_fnd nil) ({\|\|} const-decl "AffineCombination" affine nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (idxs_ac const-decl "list[nat]" affine nil) (const_ac const-decl "AffineCombination" affine nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (ac_proj_pd formula-decl nil affine nil) (member def-decl "bool" list_props nil) (car_ol const-decl "T" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cdr_ol const-decl "ordered_list" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (idxs_pd def-decl "list[nat]" affine nil) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (Unit type-decl nil Unit_adt structures) (Includes? const-decl "bool" interval interval_arith) (unit? adt-recognizer-decl "[Unit -> boolean]" Unit_adt structures) (unit adt-constructor-decl "(unit?)" Unit_adt structures) (CONST adt-constructor-decl "[[opc: [Unit -> real], (Includes?(opc(unit)))] -> (const?)]" IntervalExpr_adt interval_arith) (below type-eq-decl nil naturalnumbers nil) (TRUE const-decl "bool" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (below type-eq-decl nil nat_types nil) (cache_get def-decl "{res: Maybe[AffineCombination] |
   some?(res) IMPLIES
    EXISTS (i: below(length(cache))):
      nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res)}" affine_expr_Eval_fnd nil) (VARIDX adt-constructor-decl "[nat -> (varidx?)]" IntervalExpr_adt interval_arith) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (None adt-constructor-decl "(none?)" Maybe structures) (nth_ac const-decl "AffineCombination" affine_box nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (i skolem-const-decl "below(IF some?(cache_get(cache)(VARIDX(VARIDX1_var)))
        THEN length(cons((VARIDX(VARIDX1_var),
                          val(cache_get(cache)(VARIDX(VARIDX1_var))),
                          null),
                         cache))
      ELSE IF VARIDX1_var >= length(box) THEN length(val(None)`2)
           ELSE length(cons((VARIDX(VARIDX1_var), nth_ac(box, VARIDX1_var),
                             null),
                            cache))
           ENDIF
      ENDIF)" affine_expr_Eval_fnd nil) (VARIDX1_var skolem-const-decl "nat" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "upfrom(first_added_idx)" affine_expr_Eval_fnd nil) (first_added_idx skolem-const-decl "upfrom(1 + last_idx_in_box(box))" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(cons((VARIDX(VARIDX1_var), nth_ac(box, VARIDX1_var), null),
                  cache)))" affine_expr_Eval_fnd nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (real_minus_real_is_real application-judgement "real" reals nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (ADD1_var skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "upfrom(first_added_idx)" affine_expr_Eval_fnd nil) (first_added_idx skolem-const-decl "upfrom(1 + last_idx_in_box(box))" affine_expr_Eval_fnd nil) (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]" IntervalExpr_adt interval_arith) (add_ac_ac const-decl "AffineCombination" affine nil) (idxs_ac_add_ac_ac formula-decl nil affine nil) (ADD2_var skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(cons((ADD(ADD1_var, ADD2_var),
                   add_ac_ac(car(val(RE2AC
                                     (ADD1_var,
                                      box,
                                      vs,
                                      nextfreeidx,
                                      cache))`2)`2,
                             car(val(RE2AC
                                     (ADD2_var,
                                      box,
                                      vs,
                                      val
                                      (RE2AC
                                       (ADD1_var,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`1,
                                      val
                                      (RE2AC
                                       (ADD1_var,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`2))`2)`2),
                   null),
                  val(RE2AC(ADD2_var, box, vs,
                            val(RE2AC(ADD1_var,
                                      box,
                                      vs,
                                      nextfreeidx,
                                      cache))`1,
                            val(RE2AC(ADD1_var,
                                      box,
                                      vs,
                                      nextfreeidx,
                                      cache))`2))`2)))" affine_expr_Eval_fnd nil) (add_pd_pd const-decl "ErrorTerms" affine nil) (i skolem-const-decl "below(length(cons((NEG(NEG1_var),
                   neg_ac(car(val(RE2AC(NEG1_var,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`2)`2),
                   null),
                  val(RE2AC(NEG1_var, box, vs, nextfreeidx, cache))`2)))" affine_expr_Eval_fnd nil) (first_added_idx skolem-const-decl "upfrom(1 + last_idx_in_box(box))" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "upfrom(first_added_idx)" affine_expr_Eval_fnd nil) (NEG1_var skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (minus_real_is_real application-judgement "real" reals nil) (idxs_ac_neg_ac formula-decl nil affine nil) (neg_ac const-decl "AffineCombination" affine nil) (NEG adt-constructor-decl "[RealExpr -> (neg?)]" IntervalExpr_adt interval_arith) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (SUB1_var skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "upfrom(first_added_idx)" affine_expr_Eval_fnd nil) (first_added_idx skolem-const-decl "upfrom(1 + last_idx_in_box(box))" affine_expr_Eval_fnd nil) (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]" IntervalExpr_adt interval_arith) (sub_ac_ac const-decl "AffineCombination" affine nil) (idxs_ac_sub_ac_ac formula-decl nil affine nil) (SUB2_var skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(cons((SUB(SUB1_var, SUB2_var),
                   sub_ac_ac(car(val(RE2AC
                                     (SUB1_var,
                                      box,
                                      vs,
                                      nextfreeidx,
                                      cache))`2)`2,
                             car(val(RE2AC
                                     (SUB2_var,
                                      box,
                                      vs,
                                      val
                                      (RE2AC
                                       (SUB1_var,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`1,
                                      val
                                      (RE2AC
                                       (SUB1_var,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`2))`2)`2),
                   null),
                  val(RE2AC(SUB2_var, box, vs,
                            val(RE2AC(SUB1_var,
                                      box,
                                      vs,
                                      nextfreeidx,
                                      cache))`1,
                            val(RE2AC(SUB1_var,
                                      box,
                                      vs,
                                      nextfreeidx,
                                      cache))`2))`2)))" affine_expr_Eval_fnd nil) (sub_pd_pd const-decl "ErrorTerms" affine nil) (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]" IntervalExpr_adt interval_arith) (i skolem-const-decl "below(length(cons((MULT(MULT1_var, MULT2_var),
                   val(cache_get(cache)(MULT(MULT1_var, MULT2_var))),
                   null),
                  cache)))" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "upfrom(first_added_idx)" affine_expr_Eval_fnd nil) (first_added_idx skolem-const-decl "upfrom(1 + last_idx_in_box(box))" affine_expr_Eval_fnd nil) (MULT2_var skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (MULT1_var skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (idxs_ac_mult_ac_ac formula-decl nil affine nil) (real_times_real_is_real application-judgement "real" reals nil) (append_ol const-decl "ordered_list" ordered_list structures) (add_ET const-decl "ErrorTerms" affine nil) (nzBaseType type-eq-decl nil affine nil) (next_idx_2 const-decl "nat" affine nil) (mult_ac_ac const-decl "AffineCombination" affine nil) (i skolem-const-decl "below(length(cons((POW(POW1_var, POW2_var),
                   pow_var_ac(nth_ac(box, varidx(POW1_var)), POW2_var,
                              nats(nextfreeidx,
                                   POW2_var - 2 + nextfreeidx)),
                   nats(nextfreeidx, POW2_var - 2 + nextfreeidx)),
                  cache)))" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(cons((POW(POW1_var, POW2_var),
                   pow_var_ac(nth_ac(box, varidx(POW1_var)), POW2_var,
                              nats(nextfreeidx,
                                   POW2_var - 1 -
                                    opn
                                    (val
                                     (cache_get_powvar
                                      (cache)(POW(POW1_var, POW2_var)))`1)
                                    + nextfreeidx)),
                   nats(nextfreeidx,
                        POW2_var - 1 -
                         opn(val(cache_get_powvar(cache)
                                                 (POW
                                                  (POW1_var, POW2_var)))`1)
                         + nextfreeidx)),
                  cache)))" affine_expr_Eval_fnd nil) (take_nats formula-decl nil affine_pow nil) (i skolem-const-decl "below(length(cons((POW(POW1_var, POW2_var),
                   pow_var_ac(nth_ac(box, varidx(POW1_var)), POW2_var,
                              append(take[nat]
                                     (val
                                      (cache_get_powvar
                                       (cache)(POW(POW1_var, POW2_var)))`3,
                                      opn
                                      (val
                                       (cache_get_powvar
                                        (cache)
                                        (POW(POW1_var, POW2_var)))`1)
                                      -
                                      1),
                                     nats
                                     (nextfreeidx,
                                      POW2_var - 1
                                      -
                                      opn
                                      (val
                                       (cache_get_powvar
                                        (cache)
                                        (POW(POW1_var, POW2_var)))`1)
                                      +
                                      nextfreeidx))),
                   append(take[nat]
                              (val(cache_get_powvar(cache)
                                                   (POW
                                                    (POW1_var,
                                                     POW2_var)))`3,
                               opn(val(cache_get_powvar
                                       (cache)(POW(POW1_var, POW2_var)))`1)
                                - 1),
                          nats(nextfreeidx,
                               POW2_var - 1 -
                                opn(val
                                    (cache_get_powvar
                                     (cache)(POW(POW1_var, POW2_var)))`1)
                                + nextfreeidx))),
                  cache)))" affine_expr_Eval_fnd nil) (pow_var_pd def-decl "{pds: ErrorTerms | NOT null?(pds) AND car(pds)`1 >= car(idxs)}" affine_pow nil) (C const-decl "posnat" binomial reals) (factorial def-decl "posnat" factorial ints) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (member_nats formula-decl nil affine_pow nil) (length_append formula-decl nil list_props nil) (length_take formula-decl nil more_list_props structures) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cidx skolem-const-decl "below(length(cache))" affine_expr_Eval_fnd nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (take_prop_2 formula-decl nil more_list_props structures) (app skolem-const-decl "list[nat]" affine_expr_Eval_fnd nil) (member_append_fi formula-decl nil more_list_props structures) (take def-decl "list[T]" more_list_props structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (i skolem-const-decl "below(length(cons((POW(POW1_var, POW2_var),
                   pow_var_ac(nth_ac(box, varidx(POW1_var)), POW2_var,
                              val(cache_get_powvar(cache)
                                                  (POW
                                                   (POW1_var,
                                                    POW2_var)))`3),
                   val(cache_get_powvar(cache)
                                       (POW(POW1_var, POW2_var)))`3),
                  cache)))" affine_expr_Eval_fnd nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (member_take_1 formula-decl nil more_list_props structures) (above nonempty-type-eq-decl nil integers nil) (idxs_ac_pow_var_ac_2 formula-decl nil affine_pow nil) (cache_powvar_correct formula-decl nil affine_expr_Eval_fnd nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (i skolem-const-decl "below(length(cons((POW(POW1_var, POW2_var),
                   val(cache_get_powvar(cache)(POW(POW1_var, POW2_var)))`2,
                   val(cache_get_powvar(cache)
                                       (POW(POW1_var, POW2_var)))`3),
                  cache)))" affine_expr_Eval_fnd nil) (cache_get_powvar def-decl "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" affine_expr_Eval_fnd nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (i skolem-const-decl "below(length(cons((POW(POW1_var, POW2_var),
                   pow_var_ac(nth_ac(box, varidx(POW1_var)), POW2_var,
                              null_ol
                                  [nat,
                                   restrict[[real, real], [nat, nat], bool]
                                       (<)]),
                   null),
                  cache)))" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "upfrom(first_added_idx)" affine_expr_Eval_fnd nil) (first_added_idx skolem-const-decl "upfrom(1 + last_idx_in_box(box))" affine_expr_Eval_fnd nil) (POW2_var skolem-const-decl "nat" affine_expr_Eval_fnd nil) (POW1_var skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (minus_int_is_int application-judgement "int" integers nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (idxs_ac_pow_var_ac formula-decl nil affine_pow nil) (null_ol const-decl "ordered_list" ordered_list structures) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (next_idx const-decl "nat" affine nil) (represents_var? const-decl "bool" affine nil) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (iacniig_box_growing_preservation_TCC1 0 (iacniig_box_growing_preservation_TCC1-1 nil 3638720158 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (>= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (iacniig_box_growing_preservation subtype "affine_expr_Eval_fnd.first_added_idx" "integers.upfrom((number_fields.+)(1, affine_box.last_idx_in_box(affine_expr_Eval_fnd.box)))"))) (iacniig_box_growing_preservation_TCC2 0 (iacniig_box_growing_preservation_TCC2-1 nil 3638720158 ("" (skeep :preds? t) (("" (expand "last_idx_in_box") (("" (use "length_append[Interval]") (("" (assert) nil nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (length_singleton formula-decl nil more_list_props structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (boolean nonempty-type-decl nil booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (length_append formula-decl nil list_props nil)) nil (iacniig_box_growing_preservation subtype "affine_expr_Eval_fnd.first_added_idx" "integers.upfrom((number_fields.+)(1, affine_box.last_idx_in_box(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :)))))"))) (iacniig_box_growing_preservation 0 (iacniig_box_growing_preservation-1 nil 3638721845 ("" (skeep*) (("" (expand "idxs_ac_cache_not_in_idx_gap") (("" (skeep) (("" (inst?) (("" (skeep) (("" (inst?) (("" (assert) (("" (use "length_append[Interval]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((idxs_ac_cache_not_in_idx_gap const-decl "bool" affine_expr_Eval_fnd nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (length_append formula-decl nil list_props nil) (Box type-eq-decl nil box interval_arith) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_singleton formula-decl nil more_list_props structures) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (nicniig_RE2AC_preservation 0 (nicniig_RE2AC_preservation-1 nil 3638809473 ("" (induct "re") (("1" (assert) nil nil) ("2" (typepred "re!1") (("2" (assert) nil nil)) nil) ("3" (skeep*) (("3" (expand "RE2AC") (("3" (hide -1 -3) (("3" (expand "new_idxs_cache_not_in_idx_gap" 1) (("3" (skeep :preds? t) (("3" (expand "length" -1) (("3" (case "i=0") (("1" (expand "nth" 1) (("1" (assert) (("1" (expand "length") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2 1) (("2" (assert) (("2" (expand "nth" 2 3) (("2" (expand "new_idxs_cache_not_in_idx_gap" -2) (("2" (inst -2 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep*) (("4" (hide -1) (("4" (expand RE2AC) (("4" (lift-if -2) (("4" (assert) (("4" (split -2) (("1" (expand "new_idxs_cache_not_in_idx_gap" 1) (("1" (skeep :preds? t) (("1" (expand "length" -1) (("1" (expand "nth" 1 1) (("1" (assert) (("1" (case "i=0") (("1" (assert) (("1" (expand "length") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "nth" 2 3) (("2" (expand "new_idxs_cache_not_in_idx_gap" -3) (("2" (inst -3 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (split -1) (("1" (propax) nil nil) ("2" (assert) (("2" (expand "new_idxs_cache_not_in_idx_gap" 3) (("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (case "i=0") (("1" (expand "nth" 3 1) (("1" (assert) (("1" (expand "length") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 4 1) (("2" (assert) (("2" (expand "nth" 4 3) (("2" (expand "new_idxs_cache_not_in_idx_gap" -2) (("2" (inst -2 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skolem 1 ("re1" "re2")) (("5" (flatten) (("5" (hide -3) (("5" (split -1) (("1" (split -2) (("1" (skeep*) (("1" (inst -1 "box" "vs") (("1" (inst -2 "box" "vs") (("1" (expand RE2AC -4) (("1" (lift-if -4) (("1" (assert) (("1" (split -4) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand RE2AC 3) (("2" (assert) (("2" (expand "new_idxs_cache_not_in_idx_gap" 3) (("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (expand "nth" 3 1) (("2" (case "i=0") (("1" (assert) (("1" (expand "length") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "nth" 4 3) (("2" (inst -2 "first_added_idx" "val(RE2AC(re1,
                                                      box,
                                                      vs,
                                                      nextfreeidx,
                                                      cache))`1" "val(RE2AC(re1,
                                                      box,
                                                      vs,
                                                      nextfreeidx,
                                                      cache))`2") (("1" (inst -3 "first_added_idx" "nextfreeidx" "cache") (("1" (assert) (("1" (assert) (("1" (expand "new_idxs_cache_not_in_idx_gap" -2) (("1" (inst -2 "i-1") nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (grind) nil nil)) nil) ("3" (typepred "RE2AC(re1, box, vs, nextfreeidx, cache)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "re2") (("2" (propax) nil nil)) nil)) nil) ("2" (typepred "re1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand RE2AC) (("6" (propax) nil nil)) nil) ("7" (skolem 1 "op") (("7" (flatten) (("7" (split -1) (("1" (hide -2) (("1" (skeep*) (("1" (inst -1 "box" "vs") (("1" (inst -1 "first_added_idx" "nextfreeidx" "cache") (("1" (expand RE2AC -3) (("1" (lift-if -3) (("1" (assert) (("1" (split -3) (("1" (propax) nil nil) ("2" (expand RE2AC 2) (("2" (assert) (("2" (expand "new_idxs_cache_not_in_idx_gap" 2) (("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (expand "nth" 2 1) (("2" (case "i=0") (("1" (assert) (("1" (expand "length") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "nth" 3 3) (("2" (expand "new_idxs_cache_not_in_idx_gap" -2) (("2" (inst -2 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "op") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("8" (skolem 1 ("re1" "re2")) (("8" (flatten) (("8" (hide -3) (("8" (split -1) (("1" (split -2) (("1" (skeep*) (("1" (inst -1 "box" "vs") (("1" (inst -2 "box" "vs") (("1" (expand RE2AC -4) (("1" (lift-if -4) (("1" (assert) (("1" (split -4) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand RE2AC 3) (("2" (assert) (("2" (expand "new_idxs_cache_not_in_idx_gap" 3) (("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (expand "nth" 3 1) (("2" (case "i=0") (("1" (assert) (("1" (expand "length") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "nth" 4 3) (("2" (inst -2 "first_added_idx" "val(RE2AC(re1,
                                                                    box,
                                                                    vs,
                                                                    nextfreeidx,
                                                                    cache))`1" "val(RE2AC(re1,
                                                                    box,
                                                                    vs,
                                                                    nextfreeidx,
                                                                    cache))`2") (("1" (inst -3 "first_added_idx" "nextfreeidx" "cache") (("1" (assert) (("1" (assert) (("1" (expand "new_idxs_cache_not_in_idx_gap" -2) (("1" (inst -2 "i-1") nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (grind) nil nil)) nil) ("3" (typepred "RE2AC(re1, box, vs, nextfreeidx, cache)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "re2") (("2" (propax) nil nil)) nil)) nil) ("2" (typepred "re1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("9" (skolem 1 ("re1" "re2")) (("9" (flatten) (("9" (split -1) (("1" (split -2) (("1" (hide -3) (("1" (skeep*) (("1" (expand RE2AC -4) (("1" (lift-if -4) (("1" (assert) (("1" (split -4) (("1" (expand RE2AC 1) (("1" (assert) (("1" (expand "new_idxs_cache_not_in_idx_gap" 1) (("1" (skeep :preds? t) (("1" (expand "length" -1) (("1" (expand "nth" 1 1) (("1" (assert) (("1" (case "i=0") (("1" (assert) (("1" (expand "length") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "nth" 2 3) (("2" (expand "new_idxs_cache_not_in_idx_gap" -5) (("2" (inst -5 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand RE2AC 4) (("2" (assert) (("2" (expand "new_idxs_cache_not_in_idx_gap" 4) (("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (expand "nth" 4 1) (("2" (case "i=0") (("1" (assert) (("1" (expand "length") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "nth" 5 3) (("2" (inst -2 "box" "vs" "first_added_idx" "val(RE2AC(re1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`1" "val(RE2AC(re1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`2") (("1" (inst -3 "box" "vs" "first_added_idx" "nextfreeidx" "cache") (("1" (assert) (("1" (assert) (("1" (expand "new_idxs_cache_not_in_idx_gap" -2) (("1" (inst -2 "i-1") nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (typepred "RE2AC(re1, box, vs, nextfreeidx, cache)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("4" (assert) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "re2") (("2" (propax) nil nil)) nil)) nil) ("2" (typepred "re1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("10" (skeep*) (("10" (expand RE2AC) (("10" (propax) nil nil)) nil)) nil) ("11" (skeep*) (("11" (hide -2) (("11" (split -1) (("1" (inst -1 "box" "vs") (("1" (expand RE2AC -3) (("1" (lift-if -3) (("1" (assert) (("1" (split -3) (("1" (flatten) (("1" (expand "RE2AC" 1) (("1" (assert) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (split -3) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil) ("2" (split -2) (("1" (propax) nil nil) ("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (expand "new_idxs_cache_not_in_idx_gap" 1) (("1" (skolem 1 "i") (("1" (case "i=0") (("1" (expand "nth" 1 1) (("1" (assert) (("1" (expand "length") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2 1) (("2" (assert) (("2" (expand "nth" 2 3) (("2" (hide -3) (("2" (expand "new_idxs_cache_not_in_idx_gap" -3) (("2" (inst -3 "i-1") (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (expand "new_idxs_cache_not_in_idx_gap" 1) (("1" (skeep :preds? t) (("1" (expand "length" -1) (("1" (case "i=0") (("1" (expand "nth" 1 1) (("1" (assert) (("1" (expand "nth" 1 2) (("1" (hide -6) (("1" (typepred "cache_get_powvar(cache)(POW(POW1_var, POW2_var))") (("1" (assert) (("1" (flatten) (("1" (skolem -3 "cidx") (("1" (replace -3 :dir RL :hide? t) (("1" (expand "new_idxs_cache_not_in_idx_gap" -8) (("1" (inst -8 "cidx") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2 1) (("2" (assert) (("2" (expand "nth" 2 3) (("2" (hide -5) (("2" (expand "new_idxs_cache_not_in_idx_gap" -5) (("2" (inst -5 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "new_idxs_cache_not_in_idx_gap" 2) (("1" (skeep :preds? t) (("1" (expand "length" -1) (("1" (case "i=0") (("1" (expand "nth" 2 1) (("1" (assert) (("1" (expand "nth" 2 2) (("1" (assert) (("1" (hide -6) (("1" (typepred "cache_get_powvar(cache)(POW(POW1_var, POW2_var))") (("1" (assert) (("1" (flatten) (("1" (skolem -3 "cidx") (("1" (replace -3 :dir RL :hide? t) (("1" (expand "new_idxs_cache_not_in_idx_gap" -8) (("1" (inst -8 "cidx") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 3 1) (("2" (assert) (("2" (expand "nth" 3 3) (("2" (hide -5) (("2" (expand "new_idxs_cache_not_in_idx_gap" -5) (("2" (inst -5 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (split 2) (("1" (flatten) (("1" (expand "new_idxs_cache_not_in_idx_gap" 1) (("1" (skeep :preds? t) (("1" (expand "length" -1) (("1" (expand "nth" 1 1) (("1" (case "i=0") (("1" (assert) (("1" (expand "nth" 1 2) (("1" (typepred "cache_get_powvar
                                                            (cache)(POW(POW1_var, POW2_var))") (("1" (assert) (("1" (flatten) (("1" (skolem -3 "cidx") (("1" (replace -3 :dir RL :hide? t) (("1" (hide -8) (("1" (expand "new_idxs_cache_not_in_idx_gap" -8) (("1" (inst -8 "cidx") (("1" (skeep 1) (("1" (case "j<length(take[nat]
                                                  (nth(cache, cidx)`3, opn(nth(cache, cidx)`1) - 1))") (("1" (case "nth(append(take[nat](nth(cache, cidx)`3, opn(nth(cache, cidx)`1) - 1),
                 nats(nextfreeidx, POW2_var - 1 - opn(nth(cache, cidx)`1) + nextfreeidx)),
          j)
       = nth(take[nat](nth(cache, cidx)`3, opn(nth(cache, cidx)`1) - 1), j)") (("1" (replace -1 :hide? t) (("1" (inst -10 "j") (("1" (split -10) (("1" (use "nth_take2[nat]") (("1" (assert) nil nil) ("2" (use "length_take[nat]") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil) ("2" (use "length_take[nat]") (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (use "more_list_props[nat].nth_append") (("1" (assert) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil) ("3" (propax) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil) ("2" (case "nth(append(take[nat](nth(cache, cidx)`3, opn(nth(cache, cidx)`1) - 1),
                 nats(nextfreeidx, POW2_var - 1 - opn(nth(cache, cidx)`1) + nextfreeidx)),
          j)
       =
       nth(nats(nextfreeidx, POW2_var - 1 - opn(nth(cache, cidx)`1) + nextfreeidx),
           j - length(take[nat](nth(cache, cidx)`3, opn(nth(cache, cidx)`1) - 1)))") (("1" (replace -1 :hide? t) (("1" (typepred "nats(nextfreeidx,
                                           POW2_var - 1 - opn(nth(cache, cidx)`1) + nextfreeidx)") (("1" (inst? -5 :where 3) (("1" (replace -5 :hide? t) (("1" (typepred "nextfreeidx") (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (use "more_list_props[nat].nth_append") (("1" (assert) (("1" (use "length_append[nat]") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil) ("3" (assert) (("3" (use "length_append[nat]") (("3" (assert) nil nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "nth" 2 3) (("2" (hide -5) (("2" (expand "new_idxs_cache_not_in_idx_gap" -5) (("2" (inst -5 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "new_idxs_cache_not_in_idx_gap" 2) (("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (assert) (("2" (expand "nth" 2 1) (("2" (case "i=0") (("1" (assert) (("1" (expand "nth" 2 2) (("1" (hide -5) (("1" (typepred "cache_get_powvar(cache)
                                                                      (POW(POW1_var, POW2_var))") (("1" (assert) (("1" (flatten) (("1" (skolem -3 "cidx") (("1" (replace -3 :dir RL :hide? t) (("1" (skolem 2 "j") (("1" (flatten) (("1" (typepred "nats(nextfreeidx,
                                       POW2_var - 1 - opn(nth(cache, cidx)`1) + nextfreeidx)") (("1" (inst? -5 :where 3) (("1" (replace -5 :hide? t) (("1" (typepred nextfreeidx) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "nth" 3 3) (("2" (hide -4) (("2" (expand "new_idxs_cache_not_in_idx_gap" -4) (("2" (inst -4 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "new_idxs_cache_not_in_idx_gap" 2) (("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (expand "nth" 2 1) (("2" (case "i=0") (("1" (assert) (("1" (expand "nth" 2 2) (("1" (skolem 2 "j") (("1" (flatten) (("1" (typepred "nats(nextfreeidx, POW2_var - 2 + nextfreeidx)") (("1" (inst? -5 :where 3) (("1" (replace -5 :hide? t) (("1" (typepred "nextfreeidx") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "nth" 3 3) (("2" (hide -3) (("2" (expand "new_idxs_cache_not_in_idx_gap" -3) (("2" (inst -3 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "POW1_var") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("12" (skeep*) (("12" (expand RE2AC) (("12" (propax) nil nil)) nil)) nil) ("13" (skeep*) (("13" (hide-all-but -4) (("13" (expand RE2AC) (("13" (propax) nil nil)) nil)) nil)) nil) ("14" (skeep*) (("14" (hide-all-but -5) (("14" (expand RE2AC) (("14" (propax) nil nil)) nil)) nil)) nil) ("15" (skeep*) (("15" (hide-all-but -5) (("15" (expand RE2AC) (("15" (propax) nil nil)) nil)) nil)) nil) ("16" (assert) nil nil) ("17" (assert) nil nil) ("18" (assert) nil nil) ("19" (assert) nil nil) ("20" (assert) nil nil) ("21" (assert) nil nil) ("22" (assert) nil nil) ("23" (assert) nil nil) ("24" (grind) nil nil) ("25" (grind) nil nil) ("26" (hide 2) (("26" (skeep* :preds? t) (("26" (expand "last_idx_in_box") (("26" (typepred "length(box)") (("26" (assert) nil nil)) nil)) nil)) nil)) nil) ("27" (hide 2) (("27" (skeep* :preds? t) (("27" (expand "last_idx_in_box") (("27" (typepred "length(box)") (("27" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((length_append formula-decl nil list_props nil) (nth_take2 formula-decl nil more_list_props structures) (j skolem-const-decl "nat" affine_expr_Eval_fnd nil) (cidx skolem-const-decl "below(length(cache))" affine_expr_Eval_fnd nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (length_take formula-decl nil more_list_props structures) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nth_append formula-decl nil more_list_props structures) (take def-decl "list[T]" more_list_props structures) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (cache_get_powvar def-decl "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" affine_expr_Eval_fnd nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (i skolem-const-decl "below(length(cons((POW(POW1_var, POW2_var),
                   pow_var_ac(nth_ac(box, varidx(POW1_var)), POW2_var,
                              null_ol
                                  [nat,
                                   restrict[[real, real], [nat, nat], bool]
                                       (<)]),
                   null),
                  cache)))" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "upfrom(first_added_idx)" affine_expr_Eval_fnd nil) (first_added_idx skolem-const-decl "upfrom(1 + last_idx_in_box(box))" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (POW2_var skolem-const-decl "nat" affine_expr_Eval_fnd nil) (POW1_var skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null_ol const-decl "ordered_list" ordered_list structures) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (next_idx const-decl "nat" affine nil) (represents_var? const-decl "bool" affine nil) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (mult_ac_ac const-decl "AffineCombination" affine nil) (next_idx_2 const-decl "nat" affine nil) (nzBaseType type-eq-decl nil affine nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (re1 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "upfrom(first_added_idx)" affine_expr_Eval_fnd nil) (first_added_idx skolem-const-decl "upfrom(1 + last_idx_in_box(box))" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]" IntervalExpr_adt interval_arith) (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]" IntervalExpr_adt interval_arith) (sub_ac_ac const-decl "AffineCombination" affine nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (first_added_idx skolem-const-decl "upfrom(1 + last_idx_in_box(box))" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "upfrom(first_added_idx)" affine_expr_Eval_fnd nil) (re1 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (neg_ac const-decl "AffineCombination" affine nil) (NEG adt-constructor-decl "[RealExpr -> (neg?)]" IntervalExpr_adt interval_arith) (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]" IntervalExpr_adt interval_arith) (add_ac_ac const-decl "AffineCombination" affine nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (first_added_idx skolem-const-decl "upfrom(1 + last_idx_in_box(box))" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "upfrom(first_added_idx)" affine_expr_Eval_fnd nil) (re1 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (nth_ac const-decl "AffineCombination" affine_box nil) (None adt-constructor-decl "(none?)" Maybe structures) (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (VARIDX adt-constructor-decl "[nat -> (varidx?)]" IntervalExpr_adt interval_arith) (cache_get def-decl "{res: Maybe[AffineCombination] |
   some?(res) IMPLIES
    EXISTS (i: below(length(cache))):
      nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res)}" affine_expr_Eval_fnd nil) (below type-eq-decl nil nat_types nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (TRUE const-decl "bool" booleans nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (Unit type-decl nil Unit_adt structures) (Includes? const-decl "bool" interval interval_arith) (unit? adt-recognizer-decl "[Unit -> boolean]" Unit_adt structures) (unit adt-constructor-decl "(unit?)" Unit_adt structures) (CONST adt-constructor-decl "[[opc: [Unit -> real], (Includes?(opc(unit)))] -> (const?)]" IntervalExpr_adt interval_arith) (const_ac const-decl "AffineCombination" affine nil) (null adt-constructor-decl "(null?)" list_adt nil) (below type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (nth def-decl "T" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (length def-decl "nat" list_props nil) (IntervalExpr_induction formula-decl nil IntervalExpr_adt interval_arith) (RE2AC def-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
    LET res = val(result)`2, newnidx = val(result)`1 IN
           (NOT null?(res)) AND (car(res)`1 = re)
       AND (EXISTS (l: list[CacheData]): res = append(l, cache))
       AND (EXISTS (N: Noise):
              vars_in_box_compatible?(N)(box)(vs) AND
               compatible_pairs_on?(box, vs)(N)(res))
       AND (newnidx >= nextfreeidx) AND idxs_bounded(newnidx)(res)
       AND correct_cache?(box)(res)}" affine_expr_Eval_fnd nil) (> const-decl "bool" reals nil) (new_idxs_cache_not_in_idx_gap const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (append def-decl "list[T]" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (BaseType type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak)) (nicniig_box_growing_preservation_TCC1 0 (nicniig_box_growing_preservation_TCC1-1 nil 3638720158 ("" (skeep :preds? t) (("" (expand "last_idx_in_box") (("" (use "length_append[Interval]") (("" (assert) nil nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (length_singleton formula-decl nil more_list_props structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (boolean nonempty-type-decl nil booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (length_append formula-decl nil list_props nil)) nil (nicniig_box_growing_preservation subtype "affine_expr_Eval_fnd.first_added_idx" "integers.upfrom((number_fields.+)(1, affine_box.last_idx_in_box(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :)))))"))) (nicniig_box_growing_preservation 0 (nicniig_box_growing_preservation-1 nil 3638721912 ("" (skeep*) (("" (expand "new_idxs_cache_not_in_idx_gap") (("" (propax) nil nil)) nil)) nil) ((new_idxs_cache_not_in_idx_gap const-decl "bool" affine_expr_Eval_fnd nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (vrcib_RE2AC_preservation 0 (vrcib_RE2AC_preservation-1 nil 3638893564 ("" (assert) (("" (induct "re") (("1" (typepred "re!1") (("1" (assert) nil nil)) nil) ("2" (skeep*) (("2" (hide -1) (("2" (expand "varidxs_re_cache_in_box") (("2" (skolem 1 "i") (("2" (expand "RE2AC") (("2" (expand "nth" 1) (("2" (case "i=0") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (inst -1 "i-1") (("2" (typepred "i") (("2" (expand "RE2AC") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep*) (("3" (hide -1) (("3" (expand RE2AC) (("3" (lift-if -2) (("3" (assert) (("3" (split -2) (("1" (expand "varidxs_re_cache_in_box" 1) (("1" (skeep :preds? t) (("1" (expand "length" -1) (("1" (expand "nth" 1) (("1" (case "i=0") (("1" (assert) (("1" (typepred "cache_get(cache)(VARIDX(VARIDX1_var))") (("1" (assert) (("1" (skeep -1) (("1" (expand "varidxs_re_cache_in_box" -6) (("1" (inst -6 "i!1") (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "varidxs_re_cache_in_box" -3) (("2" (inst -3 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (assert) (("2" (expand "varidxs_re_cache_in_box" 3) (("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (expand "nth" 3) (("2" (case "i=0") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (expand "varidxs_re_cache_in_box" -2) (("2" (inst -2 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skolem 1 ("op1" "op2")) (("4" (flatten) (("4" (hide -3) (("4" (split -1) (("1" (split -2) (("1" (skeep*) (("1" (expand RE2AC -4) (("1" (lift-if -4) (("1" (assert) (("1" (split -4) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand RE2AC 3) (("2" (assert) (("2" (expand "varidxs_re_cache_in_box" 3) (("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (expand "nth" 3) (("2" (case "i=0") (("1" (assert) (("1" (inst -3 "box" "vs" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`1" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`2") (("1" (inst -4 "box" "vs" "nextfreeidx" "cache") (("1" (assert) (("1" (assert) (("1" (expand "varidxs_re_cache_in_box" -3) (("1" (skeep) (("1" (expand "subterm" -6) (("1" (inst -3 "0") (("1" (expand "nth" -3) (("1" (typepred "RE2AC(op2, box, vs,
                              val(RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`1,
                              val(RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`2)") (("1" (assert) (("1" (name-replace "eval2" "RE2AC(op2, box, vs,
                              val(RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`1,
                              val(RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`2)") (("1" (flatten) (("1" (replaces -1) (("1" (name-replace "eval1" "RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache)") (("1" (typepred "eval1") (("1" (assert) (("1" (flatten) (("1" (expand "varidxs_re_cache_in_box" -13) (("1" (inst -13 "0") (("1" (expand "nth" -13) (("1" (inst -12 "subexpr") (("1" (inst -13 "subexpr") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "RE2AC(op2, box, vs,
                              val(RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`1,
                              val(RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst -2 "box" "vs" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`1" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`2") (("2" (inst -3 "box" "vs" "nextfreeidx" "cache") (("2" (assert) (("2" (assert) (("2" (name-replace "eval2" "RE2AC(op2, box, vs,
                              val(RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`1,
                              val(RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`2)") (("2" (expand "varidxs_re_cache_in_box" -2) (("2" (inst -2 "i-1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "op2") (("2" (propax) nil nil)) nil)) nil) ("2" (typepred "op1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep*) (("5" (expand RE2AC) (("5" (propax) nil nil)) nil)) nil) ("6" (skolem 1 "op") (("6" (flatten) (("6" (hide -2) (("6" (split -1) (("1" (skeep*) (("1" (inst -1 "box" "vs" "nextfreeidx" "cache") (("1" (expand RE2AC -3) (("1" (lift-if -3) (("1" (assert) (("1" (split -3) (("1" (propax) nil nil) ("2" (assert) (("2" (expand RE2AC 2) (("2" (assert) (("2" (expand "varidxs_re_cache_in_box" 2) (("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (expand "nth" 2) (("2" (case "i=0") (("1" (assert) (("1" (expand "varidxs_re_cache_in_box" -3) (("1" (inst -3 "0") (("1" (expand "nth" -3) (("1" (typepred "RE2AC(op, box, vs, nextfreeidx, cache)") (("1" (assert) (("1" (flatten) (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "RE2AC(op, box, vs, nextfreeidx, cache)") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "varidxs_re_cache_in_box" -2) (("2" (inst -2 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "op") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (skolem 1 ("op1" "op2")) (("7" (flatten) (("7" (hide -3) (("7" (split -1) (("1" (split -2) (("1" (skeep*) (("1" (expand RE2AC -4) (("1" (lift-if -4) (("1" (assert) (("1" (split -4) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand RE2AC 3) (("2" (assert) (("2" (expand "varidxs_re_cache_in_box" 3) (("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (expand "nth" 3) (("2" (case "i=0") (("1" (assert) (("1" (inst -3 "box" "vs" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`1" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`2") (("1" (inst -4 "box" "vs" "nextfreeidx" "cache") (("1" (assert) (("1" (assert) (("1" (expand "varidxs_re_cache_in_box" -3) (("1" (skeep) (("1" (expand "subterm" -6) (("1" (inst -3 "0") (("1" (expand "nth" -3) (("1" (typepred "RE2AC(op2, box, vs,
                                              val(RE2AC(op1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`1,
                                              val(RE2AC(op1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`2)") (("1" (assert) (("1" (name-replace "eval2" "RE2AC(op2, box, vs,
                                              val(RE2AC(op1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`1,
                                              val(RE2AC(op1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`2)") (("1" (flatten) (("1" (replaces -1) (("1" (name-replace "eval1" "RE2AC(op1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache)") (("1" (typepred "eval1") (("1" (assert) (("1" (flatten) (("1" (expand "varidxs_re_cache_in_box" -13) (("1" (inst -13 "0") (("1" (expand "nth" -13) (("1" (inst -12 "subexpr") (("1" (inst -13 "subexpr") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "RE2AC(op2, box, vs,
                                              val(RE2AC(op1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`1,
                                              val(RE2AC(op1,
                                                        box,
                                                        vs,
                                                        nextfreeidx,
                                                        cache))`2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst -2 "box" "vs" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`1" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`2") (("2" (inst -3 "box" "vs" "nextfreeidx" "cache") (("2" (assert) (("2" (assert) (("2" (name-replace "eval2" "RE2AC(op2, box, vs,
                                            val(RE2AC(op1,
                                                      box,
                                                      vs,
                                                      nextfreeidx,
                                                      cache))`1,
                                            val(RE2AC(op1,
                                                      box,
                                                      vs,
                                                      nextfreeidx,
                                                      cache))`2)") (("2" (expand "varidxs_re_cache_in_box" -2) (("2" (inst -2 "i-1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "op2") (("2" (propax) nil nil)) nil)) nil) ("2" (typepred "op1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("8" (skolem 1 ("op1" "op2")) (("8" (flatten) (("8" (hide -3) (("8" (split -1) (("1" (split -2) (("1" (skeep*) (("1" (expand RE2AC -4) (("1" (lift-if -4) (("1" (assert) (("1" (split -4) (("1" (expand RE2AC 1) (("1" (assert) (("1" (expand "varidxs_re_cache_in_box" 1) (("1" (skeep :preds? t) (("1" (expand "length" -1) (("1" (expand "nth" 1) (("1" (case "i=0") (("1" (assert) (("1" (typepred "cache_get(cache)(MULT(op1, op2))") (("1" (assert) (("1" (skeep -1) (("1" (expand "varidxs_re_cache_in_box" -8) (("1" (inst -8 "i!1") (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "varidxs_re_cache_in_box" -5) (("2" (inst -5 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand RE2AC 4) (("2" (assert) (("2" (expand "varidxs_re_cache_in_box" 4) (("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (expand "nth" 4) (("2" (case "i=0") (("1" (assert) (("1" (inst -3 "box" "vs" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`1" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`2") (("1" (inst -4 "box" "vs" "nextfreeidx" "cache") (("1" (assert) (("1" (assert) (("1" (name-replace "eval2" "RE2AC(op2,
                                        box,
                                        vs,
                                        val
                                        (RE2AC
                                         (op1,
                                          box,
                                          vs,
                                          nextfreeidx,
                                          cache))`1,
                                        val
                                        (RE2AC
                                         (op1,
                                          box,
                                          vs,
                                          nextfreeidx,
                                          cache))`2)") (("1" (name-replace "eval1" "RE2AC(op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache)") (("1" (typepred "eval1") (("1" (assert) (("1" (flatten) (("1" (typepred "eval2") (("1" (assert) (("1" (flatten) (("1" (expand "varidxs_re_cache_in_box" -13) (("1" (inst -13 "0") (("1" (expand "varidxs_re_cache_in_box" -14) (("1" (inst -14 "0") (("1" (expand "nth" (-13 -14)) (("1" (skeep 6) (("1" (inst -13 "subexpr") (("1" (inst -14 "subexpr") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst -2 "box" "vs" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`1" "val(RE2AC(op1, box, vs, nextfreeidx, cache))`2") (("2" (inst -3 "box" "vs" "nextfreeidx" "cache") (("2" (assert) (("2" (assert) (("2" (expand "varidxs_re_cache_in_box" -2) (("2" (inst -2 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "op2") (("2" (propax) nil nil)) nil)) nil) ("2" (typepred "op1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("9" (skeep*) (("9" (expand RE2AC) (("9" (propax) nil nil)) nil)) nil) ("10" (skolem 1 ("op" "power")) (("10" (flatten) (("10" (hide -2) (("10" (split -1) (("1" (skeep*) (("1" (inst -1 "box" "vs" "nextfreeidx" "cache") (("1" (expand RE2AC -3) (("1" (lift-if -3) (("1" (assert) (("1" (split -3) (("1" (flatten) (("1" (split -2) (("1" (propax) nil nil) ("2" (expand RE2AC 2) (("2" (assert) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (expand "varidxs_re_cache_in_box" 1) (("1" (skeep :preds? t) (("1" (expand "length" -1) (("1" (expand "nth" 1) (("1" (case "i=0") (("1" (assert) (("1" (hide -5) (("1" (skeep) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "varidxs_re_cache_in_box" -5) (("2" (inst -5 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (expand "varidxs_re_cache_in_box" 1) (("1" (skeep :preds? t) (("1" (expand "length" -1) (("1" (expand "nth" 1) (("1" (case "i=0") (("1" (assert) (("1" (skeep) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "varidxs_re_cache_in_box" -6) (("2" (inst -6 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "varidxs_re_cache_in_box" 2) (("1" (skeep :preds? t) (("1" (expand "length" -1) (("1" (expand "nth" 2) (("1" (case "i=0") (("1" (assert) (("1" (skeep) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "varidxs_re_cache_in_box" -6) (("2" (inst -6 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (split 2) (("1" (flatten) (("1" (expand "varidxs_re_cache_in_box" 1) (("1" (skeep :preds? t) (("1" (expand "length" -1) (("1" (expand "nth" 1) (("1" (case "i=0") (("1" (assert) (("1" (skeep) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "varidxs_re_cache_in_box" -6) (("2" (inst -6 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "varidxs_re_cache_in_box" 2) (("2" (skeep :preds? t) (("2" (expand "nth" 2) (("2" (case "i=0") (("1" (assert) (("1" (skeep) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "varidxs_re_cache_in_box" -5) (("2" (inst -5 "i-1") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "varidxs_re_cache_in_box" 2) (("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (expand "nth" 2) (("2" (case "i=0") (("1" (assert) (("1" (skeep) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "varidxs_re_cache_in_box" -4) (("2" (inst -4 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "op") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("11" (skeep*) (("11" (expand RE2AC) (("11" (propax) nil nil)) nil)) nil) ("12" (skeep*) (("12" (expand RE2AC) (("12" (propax) nil nil)) nil)) nil) ("13" (skeep*) (("13" (expand RE2AC) (("13" (propax) nil nil)) nil)) nil) ("14" (skeep*) (("14" (expand "RE2AC") (("14" (propax) nil nil)) nil)) nil) ("15" (assert) nil nil) ("16" (assert) nil nil) ("17" (assert) nil nil) ("18" (assert) nil nil) ("19" (assert) nil nil) ("20" (assert) nil nil) ("21" (assert) nil nil) ("22" (assert) nil nil) ("23" (assert) nil nil) ("24" (skeep*) (("24" (expand "RE2AC") (("24" (propax) nil nil)) nil)) nil)) nil)) nil) ((IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (BaseType type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (varidxs_re_cache_in_box const-decl "bool" affine_expr_Eval_fnd nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (append def-decl "list[T]" list_props nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (/= const-decl "boolean" notequal nil) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (RE2AC def-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
    LET res = val(result)`2, newnidx = val(result)`1 IN
           (NOT null?(res)) AND (car(res)`1 = re)
       AND (EXISTS (l: list[CacheData]): res = append(l, cache))
       AND (EXISTS (N: Noise):
              vars_in_box_compatible?(N)(box)(vs) AND
               compatible_pairs_on?(box, vs)(N)(res))
       AND (newnidx >= nextfreeidx) AND idxs_bounded(newnidx)(res)
       AND correct_cache?(box)(res)}" affine_expr_Eval_fnd nil) (IntervalExpr_induction formula-decl nil IntervalExpr_adt interval_arith) (nth def-decl "T" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (i skolem-const-decl "below(length(val(RE2AC(CONST(CONST1_var, CONST2_var), box, vs, nextfreeidx,
                       cache))`2))" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (CONST2_var skolem-const-decl "(Includes?(CONST1_var(unit)))" affine_expr_Eval_fnd nil) (CONST1_var skolem-const-decl "[Unit -> real]" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (subterm adt-def-decl "boolean" IntervalExpr_adt interval_arith) (const_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (length def-decl "nat" list_props nil) (Unit type-decl nil Unit_adt structures) (Includes? const-decl "bool" interval interval_arith) (unit? adt-recognizer-decl "[Unit -> boolean]" Unit_adt structures) (unit adt-constructor-decl "(unit?)" Unit_adt structures) (CONST adt-constructor-decl "[[opc: [Unit -> real], (Includes?(opc(unit)))] -> (const?)]" IntervalExpr_adt interval_arith) (below type-eq-decl nil naturalnumbers nil) (TRUE const-decl "bool" booleans nil) (nth_ac const-decl "AffineCombination" affine_box nil) (None adt-constructor-decl "(none?)" Maybe structures) (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null adt-constructor-decl "(null?)" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (VARIDX adt-constructor-decl "[nat -> (varidx?)]" IntervalExpr_adt interval_arith) (cache_get def-decl "{res: Maybe[AffineCombination] |
   some?(res) IMPLIES
    EXISTS (i: below(length(cache))):
      nth(cache, i)`1 = re AND nth(cache, i)`2 = val(res)}" affine_expr_Eval_fnd nil) (below type-eq-decl nil nat_types nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (VARIDX1_var skolem-const-decl "nat" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(cons((VARIDX(VARIDX1_var), nth_ac(box, VARIDX1_var), null),
                  cache)))" affine_expr_Eval_fnd nil) (eval2 skolem-const-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
         (NOT null?(val(result)`2)) AND (car(val(result)`2)`1 = op2)
     AND (EXISTS (l: list[CacheData]):
            val(result)`2 =
             append(l, val(RE2AC(op1, box, vs, nextfreeidx, cache))`2))
     AND (EXISTS (N: Noise):
            vars_in_box_compatible?(N)(box)(vs) AND
             compatible_pairs_on?(box, vs)(N)(val(result)`2))
     AND (val(result)`1 >= val(RE2AC(op1, box, vs, nextfreeidx, cache))`1)
     AND idxs_bounded(val(result)`1)(val(result)`2)}" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(cons((ADD(op1, op2),
                   add_ac_ac(car(val(RE2AC
                                     (op1,
                                      box,
                                      vs,
                                      nextfreeidx,
                                      cache))`2)`2,
                             car(val(RE2AC
                                     (op2,
                                      box,
                                      vs,
                                      val
                                      (RE2AC
                                       (op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`1,
                                      val
                                      (RE2AC
                                       (op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`2))`2)`2),
                   null),
                  val(RE2AC(op2, box, vs,
                            val(RE2AC(op1, box, vs, nextfreeidx, cache))`1,
                            val(RE2AC(op1,
                                      box,
                                      vs,
                                      nextfreeidx,
                                      cache))`2))`2)))" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (op2 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (op1 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (eval1 skolem-const-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
         (NOT null?(val(result)`2)) AND (car(val(result)`2)`1 = op1)
     AND (EXISTS (l: list[CacheData]): val(result)`2 = append(l, cache))
     AND (EXISTS (N: Noise):
            vars_in_box_compatible?(N)(box)(vs) AND
             compatible_pairs_on?(box, vs)(N)(val(result)`2))
     AND (val(result)`1 >= nextfreeidx)
     AND idxs_bounded(val(result)`1)(val(result)`2)}" affine_expr_Eval_fnd nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (ADD adt-constructor-decl "[[RealExpr, RealExpr] -> (add?)]" IntervalExpr_adt interval_arith) (add_ac_ac const-decl "AffineCombination" affine nil) (neg_ac const-decl "AffineCombination" affine nil) (NEG adt-constructor-decl "[RealExpr -> (neg?)]" IntervalExpr_adt interval_arith) (real_minus_real_is_real application-judgement "real" reals nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (op skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (eval2 skolem-const-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
         (NOT null?(val(result)`2)) AND (car(val(result)`2)`1 = op2)
     AND (EXISTS (l: list[CacheData]):
            val(result)`2 =
             append(l, val(RE2AC(op1, box, vs, nextfreeidx, cache))`2))
     AND (EXISTS (N: Noise):
            vars_in_box_compatible?(N)(box)(vs) AND
             compatible_pairs_on?(box, vs)(N)(val(result)`2))
     AND (val(result)`1 >= val(RE2AC(op1, box, vs, nextfreeidx, cache))`1)
     AND idxs_bounded(val(result)`1)(val(result)`2)}" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(cons((SUB(op1, op2),
                   sub_ac_ac(car(val(RE2AC
                                     (op1,
                                      box,
                                      vs,
                                      nextfreeidx,
                                      cache))`2)`2,
                             car(val(RE2AC
                                     (op2,
                                      box,
                                      vs,
                                      val
                                      (RE2AC
                                       (op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`1,
                                      val
                                      (RE2AC
                                       (op1,
                                        box,
                                        vs,
                                        nextfreeidx,
                                        cache))`2))`2)`2),
                   null),
                  val(RE2AC(op2, box, vs,
                            val(RE2AC(op1, box, vs, nextfreeidx, cache))`1,
                            val(RE2AC(op1,
                                      box,
                                      vs,
                                      nextfreeidx,
                                      cache))`2))`2)))" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (op2 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (op1 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (eval1 skolem-const-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
         (NOT null?(val(result)`2)) AND (car(val(result)`2)`1 = op1)
     AND (EXISTS (l: list[CacheData]): val(result)`2 = append(l, cache))
     AND (EXISTS (N: Noise):
            vars_in_box_compatible?(N)(box)(vs) AND
             compatible_pairs_on?(box, vs)(N)(val(result)`2))
     AND (val(result)`1 >= nextfreeidx)
     AND idxs_bounded(val(result)`1)(val(result)`2)}" affine_expr_Eval_fnd nil) (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]" IntervalExpr_adt interval_arith) (sub_ac_ac const-decl "AffineCombination" affine nil) (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]" IntervalExpr_adt interval_arith) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (op2 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (op1 skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (eval2 skolem-const-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
         (NOT null?(val(result)`2)) AND (car(val(result)`2)`1 = op2)
     AND (EXISTS (l: list[CacheData]):
            val(result)`2 =
             append(l, val(RE2AC(op1, box, vs, nextfreeidx, cache))`2))
     AND (EXISTS (N: Noise):
            vars_in_box_compatible?(N)(box)(vs) AND
             compatible_pairs_on?(box, vs)(N)(val(result)`2))
     AND (val(result)`1 >= val(RE2AC(op1, box, vs, nextfreeidx, cache))`1)
     AND idxs_bounded(val(result)`1)(val(result)`2)}" affine_expr_Eval_fnd nil) (eval1 skolem-const-decl "{result: Maybe[[nat, (correct_cache?(box))]] |
   some?(result) IMPLIES
         (NOT null?(val(result)`2)) AND (car(val(result)`2)`1 = op1)
     AND (EXISTS (l: list[CacheData]): val(result)`2 = append(l, cache))
     AND (EXISTS (N: Noise):
            vars_in_box_compatible?(N)(box)(vs) AND
             compatible_pairs_on?(box, vs)(N)(val(result)`2))
     AND (val(result)`1 >= nextfreeidx)
     AND idxs_bounded(val(result)`1)(val(result)`2)}" affine_expr_Eval_fnd nil) (real_plus_real_is_real application-judgement "real" reals nil) (nzBaseType type-eq-decl nil affine nil) (next_idx_2 const-decl "nat" affine nil) (mult_ac_ac const-decl "AffineCombination" affine nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (POW adt-constructor-decl "[[RealExpr, nat] -> (pow?)]" IntervalExpr_adt interval_arith) (represents_var? const-decl "bool" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (null_ol const-decl "ordered_list" ordered_list structures) (real_div_nzreal_is_real application-judgement "real" reals nil) (cache_get_powvar def-decl "{res: Maybe[CacheData] |
   some?(res) IMPLIES
    powvar?(val(res)`1) AND
     varidx_powvar(val(res)`1) = varidx_powvar(re) AND
      EXISTS (i: below(length(cache))): nth(cache, i) = val(res)}" affine_expr_Eval_fnd nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nats def-decl "{r: ordered_list[nat, restrict[[real, real], [nat, nat], bool](<)] |
   NOT null_ol?[nat, restrict[[real, real], [nat, nat], bool](<)](r) AND
    car_ol[nat, restrict[[real, real], [nat, nat], bool](<)](r) = s AND
     length(r) = e - s + 1 AND
      FORALL (i: below(length(r))): nth(r, i) = s + i}" affine_pow nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (car_ol const-decl "T" ordered_list structures) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (take def-decl "list[T]" more_list_props structures) (op skolem-const-decl "RealExpr" affine_expr_Eval_fnd nil) (power skolem-const-decl "nat" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "{nextfreeidx: nat | nextfreeidx > last_idx_in_box(box)}" affine_expr_Eval_fnd nil) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(cons((POW(op, power),
                   pow_var_ac(nth_ac(box, varidx(op)), power,
                              nats(nextfreeidx,
                                   -1 -
                                    opn
                                    (val
                                     (cache_get_powvar
                                      (cache)(POW(op, power)))`1)
                                    + nextfreeidx
                                    + power)),
                   nats(nextfreeidx,
                        -1 -
                         opn(val(cache_get_powvar(cache)
                                                 (POW(op, power)))`1)
                         + nextfreeidx
                         + power)),
                  cache)))" affine_expr_Eval_fnd nil) (real_times_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak)) (vrcib_box_growing_preservation 0 (vrcib_box_growing_preservation-1 nil 3638721939 ("" (skeep*) (("" (expand "varidxs_re_cache_in_box") (("" (skeep) (("" (inst?) (("" (skeep) (("" (inst?) (("" (assert) (("" (use "length_append[Interval]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((varidxs_re_cache_in_box const-decl "bool" affine_expr_Eval_fnd nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (restrict const-decl "R" restrict nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (Interval type-eq-decl nil interval interval_arith) (length_append formula-decl nil list_props nil) (Box type-eq-decl nil box interval_arith) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_singleton formula-decl nil more_list_props structures) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (RE2AC_box_vs_expansion_TCC1 0 (RE2AC_box_vs_expansion_TCC1-2 nil 3638720433 ("" (skeep*) (("" (expand "last_idx_in_box") (("" (use "length_append[Interval]") (("" (replace -1 1 :hide? t) (("" (typepred "added_idx") (("" (expand "last_idx_in_box") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_singleton formula-decl nil more_list_props structures) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (length_append formula-decl nil list_props nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil (RE2AC_box_vs_expansion subtype "affine_expr_Eval_fnd.nextfreeidx" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :))))}")) (RE2AC_box_vs_expansion_TCC1-1 nil 3638607084 ("" (grind) nil nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (le_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (next_idx const-decl "nat" affine nil) (last_idx const-decl "int" indexed_list structures) (pow_var_compatible? const-decl "bool" affine_pow nil) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (null_ol? const-decl "bool" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (Epsilon type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith)) nil (RE2AC_box_vs_expansion subtype "affine_expr_Eval_fnd.nextfreeidx" "{nextfreeidx: naturalnumbers.nat | reals.>(nextfreeidx, affine_box.last_idx_in_box(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :))))}"))) (RE2AC_box_vs_expansion_TCC2 0 (RE2AC_box_vs_expansion_TCC2-4 nil 3644607770 ("" (skeep*) (("" (typepred "cache") (("" (split 1) (("1" (use "correct_cache?_alt_def") (("1" (replace -1 :hide? t) (("1" (use "correct_cache?_alt_def") (("1" (replace -1 :hide? t) (("1" (lemma "every_implies[CacheData]") (("1" (inst? -1 :where 1) (("1" (inst? -1 :where -2) (("1" (assert) (("1" (use "CacheData_correct?_inclusion") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs?") (("2" (skeep -2) (("2" (typepred "x") (("2" (skeep -1) (("2" (inst 1 "upd_noise(N, length(box), IF SingInterval?(I) THEN 0 ELSE e ENDIF)") (("2" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (skeep) (("1" (case "i< length(box)") (("1" (inst -4 "i") (("1" (flatten) (("1" (case "nth(append(box, (: I :)), i) = nth(box, i)") (("1" (replaces -1) (("1" (assert) (("1" (use "updated_noise_on_varac1") (("1" (assert) (("1" (use "gnbi_upd_2") (("1" (assert) (("1" (replaces -1) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (use "more_list_props[Interval].nth_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i = length(box)") (("1" (hide 1) (("1" (replaces -1) (("1" (case "nth(append(box, (: I :)), length(box)) = nth((: I :), length(box) - length(box))") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth" 1) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (use "gnbi_upd") (("1" (replaces -1) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but 1) (("2" (use "more_list_props[Interval].nth_append") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (use "length_append[Interval]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skeep) (("2" (inst -4 "i") (("2" (skeep) (("2" (inst -4 "n") (("1" (flatten) (("1" (split 1) (("1" (expand "idxs_ac_cache_not_in_idx_gap") (("1" (inst -8 "i") (("1" (use "eval_upd_no_idxs_ac") (("1" (split -1) (("1" (replaces -1) (("1" (replace -4 1 :hide? t) (("1" (expand "eval_ACExpr_Env") (("1" (use "eval_vs_idempotence") (("1" (assert) (("1" (hide 2) (("1" (expand "varidxs_re_cache_in_box") (("1" (inst -9 "i") nil nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -9 "length(box)") (("2" (assert) (("2" (typepred "added_idx") (("2" (expand "last_idx_in_box") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (assert) (("1" (case "nth_ac(box, varidx_powvar(nth(cache, i)`1)) = nth_ac(append[Interval](box, (: I :)),
                                                                                                                                       varidx_powvar(nth(cache, i)`1))") (("1" (replaces -1) (("1" (expand "pow_var_compatible?") (("1" (flatten) (("1" (assert) (("1" (skeep) (("1" (inst -9 "i_1") (("1" (use "gnbi_upd_2") (("1" (split -1) (("1" (replaces -1) (("1" (use "gnbi_upd_2") (("1" (split -1) (("1" (replaces -1) nil nil) ("2" (hide 2) (("2" (expand "nth" 1 1 :assert? nil) (("2" (expand "nth_ac" (1 -4)) (("2" (expand "var_ac" -4) (("2" (expand_ol) (("2" (lift-if -4) (("2" (assert) (("2" (split -4) (("1" (assert) (("1" (expand "var_ac" 1) (("1" (assert) (("1" (expand "cons_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i_1") (("2" (hide 2) (("2" (expand "new_idxs_cache_not_in_idx_gap") (("2" (inst -14 "i") (("2" (inst -14 "i_1") (("2" (assert) (("2" (hide 1) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (flatten) (("2" (expand "nth_ac") (("2" (case "nth(append(box, (: I :)), varidx_powvar(nth(cache, i)`1)) =
                            nth(box, varidx_powvar(nth(cache, i)`1))") (("1" (replaces -1) (("1" (assert) (("1" (typepred "added_idx") (("1" (expand "last_idx_in_box") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (name-replace "k" "varidx_powvar(nth(cache, i)`1)") (("2" (hide-all-but (1 -4)) (("2" (use "more_list_props[Interval].nth_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth_ac" 1) (("2" (use "more_list_props[Interval].nth_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "cache") (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (Epsilon type-eq-decl nil affine nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (SingInterval? const-decl "bool" affine nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (length def-decl "nat" list_props nil) (upd_noise def-decl "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" affine nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (n skolem-const-decl "upfrom(length(append[Interval](box, (: I :))))" affine_expr_Eval_fnd nil) (eval_vs_idempotence formula-decl nil interval_expr interval_arith) (Env type-eq-decl nil box interval_arith) (varidxs_re_cache_in_box const-decl "bool" affine_expr_Eval_fnd nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (above nonempty-type-eq-decl nil integers nil) (eval_upd_no_idxs_ac formula-decl nil affine nil) (idxs_ac_cache_not_in_idx_gap const-decl "bool" affine_expr_Eval_fnd nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (nzBaseType type-eq-decl nil affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (ac_proj_pd formula-decl nil affine nil) (var_ac const-decl "AffineCombination" affine nil) (cache_powvar_correct formula-decl nil affine_expr_Eval_fnd nil) (new_idxs_cache_not_in_idx_gap const-decl "bool" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (below type-eq-decl nil naturalnumbers nil) (length_singleton formula-decl nil more_list_props structures) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nth_append formula-decl nil more_list_props structures) (updated_noise_on_varac1 formula-decl nil affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (gnbi_upd_2 formula-decl nil affine nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (i skolem-const-decl "below(length(append[Interval](box, (: I :))))" affine_expr_Eval_fnd nil) (I skolem-const-decl "Interval" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (eval_var_ac formula-decl nil affine nil) (gnbi_upd formula-decl nil affine nil) (length_append formula-decl nil list_props nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (correct_cache?_alt_def formula-decl nil affine_expr_Eval_fnd nil) (append def-decl "list[T]" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (every_implies formula-decl nil more_list_props structures) (CacheData_correct?_inclusion formula-decl nil affine_expr_Eval_fnd nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil (RE2AC_box_vs_expansion subtype "affine_expr_Eval_fnd.cache" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :)), affine_expr_Eval_fnd.vs WITH [(list_props[Interval].length(affine_expr_Eval_fnd.box)) := affine_expr_Eval_fnd.x])) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.nextfreeidx)(cache)}")) (RE2AC_box_vs_expansion_TCC2-3 nil 3638720475 ("" (skeep*) (("" (typepred "cache") (("" (split 1) (("1" (use "correct_cache?_alt_def") (("1" (replace -1 :hide? t) (("1" (use "correct_cache?_alt_def") (("1" (replace -1 :hide? t) (("1" (lemma "every_implies[CacheData]") (("1" (inst? -1 :where 1) (("1" (inst? -1 :where -2) (("1" (assert) (("1" (use "CacheData_correct?_inclusion") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs?") (("2" (skeep -2) (("2" (typepred "x") (("2" (skeep -1) (("2" (inst 1 "upd_noise(N, length(box), IF SingInterval?(I) THEN 0 ELSE e ENDIF)") (("2" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (skeep) (("1" (case "i< length(box)") (("1" (inst -4 "i") (("1" (flatten) (("1" (case "nth(append(box, (: I :)), i) = nth(box, i)") (("1" (replaces -1) (("1" (assert) (("1" (use "updated_noise_on_varac1") (("1" (assert) (("1" (use "gnbi_upd_2") (("1" (assert) (("1" (replaces -1) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (use "more_list_props[Interval].nth_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i = length(box)") (("1" (hide 1) (("1" (replaces -1) (("1" (case "nth(append(box, (: I :)), length(box)) = nth((: I :), length(box) - length(box))") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth" 1) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (use "gnbi_upd") (("1" (replaces -1) (("1" (assert) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but 1) (("2" (use "more_list_props[Interval].nth_append") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (use "length_append[Interval]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skeep) (("2" (inst -4 "i") (("2" (skeep) (("2" (inst -4 "n") (("1" (flatten) (("1" (split 1) (("1" (expand "idxs_ac_cache_not_in_idx_gap") (("1" (inst -8 "i") (("1" (use "eval_upd_no_idxs_ac") (("1" (split -1) (("1" (replaces -1) (("1" (replace -4 1 :hide? t) (("1" (expand "eval_ACExpr_Env") (("1" (use "eval_vs_idempotence") (("1" (assert) (("1" (hide 2) (("1" (expand "varidxs_re_cache_in_box") (("1" (inst -9 "i") nil nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -9 "length(box)") (("2" (assert) (("2" (typepred "added_idx") (("2" (expand "last_idx_in_box") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (assert) (("1" (case "nth_ac(box, varidx_powvar(nth(cache, i)`1)) = nth_ac(append[Interval](box, (: I :)),
                                                                                                                      varidx_powvar(nth(cache, i)`1))") (("1" (replaces -1) (("1" (expand "pow_var_compatible?") (("1" (flatten) (("1" (assert) (("1" (skeep) (("1" (inst -9 "i_1") (("1" (use "gnbi_upd_2") (("1" (split -1) (("1" (replaces -1) (("1" (use "gnbi_upd_2") (("1" (split -1) (("1" (replaces -1) nil nil) ("2" (hide 2) (("2" (expand "nth" 1 1 :assert? nil) (("2" (expand "nth_ac" (1 -4)) (("2" (expand "var_ac" -4) (("2" (expand_ol) (("2" (lift-if -4) (("2" (assert) (("2" (split -4) (("1" (assert) (("1" (expand "var_ac" 1) (("1" (assert) (("1" (expand "cons_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i_1") (("2" (hide 2) (("2" (expand "new_idxs_cache_not_in_idx_gap") (("2" (inst -14 "i") (("2" (inst -14 "i_1") (("2" (assert) (("2" (hide 1) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (flatten) (("2" (expand "nth_ac") (("2" (case "nth(append(box, (: I :)), varidx_powvar(nth(cache, i)`1)) =
       nth(box, varidx_powvar(nth(cache, i)`1))") (("1" (replaces -1) (("1" (assert) (("1" (typepred "added_idx") (("1" (expand "last_idx_in_box") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (name-replace "k" "varidx_powvar(nth(cache, i)`1)") (("2" (hide-all-but (1 -4)) (("2" (use "more_list_props[Interval].nth_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth_ac" 1) (("2" (use "nth_append2[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "cache") (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (Env type-eq-decl nil affine_box nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith) (Epsilon type-eq-decl nil affine nil) (SingInterval? const-decl "bool" affine nil) (upd_noise def-decl "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" affine nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (Env type-eq-decl nil box interval_arith) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (eval_upd_no_idxs_ac formula-decl nil affine nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (nzBaseType type-eq-decl nil affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (ac_proj_pd formula-decl nil affine nil) (var_ac const-decl "AffineCombination" affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (updated_noise_on_varac1 formula-decl nil affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (gnbi_upd_2 formula-decl nil affine nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (eval_var_ac formula-decl nil affine nil) (gnbi_upd formula-decl nil affine nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (RE2AC_box_vs_expansion subtype "affine_expr_Eval_fnd.cache" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :)), affine_expr_Eval_fnd.vs WITH [(list_props[Interval].length(affine_expr_Eval_fnd.box)) := affine_expr_Eval_fnd.x])) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.nextfreeidx)(cache)}")) (RE2AC_box_vs_expansion_TCC2-2 nil 3638644378 ("" (skeep*) (("" (expand "last_idx_in_box") (("" (use "length_append[Interval]") (("" (replace -1 1 :hide? t) (("" (typepred "added_idx") (("" (expand "last_idx_in_box") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (length_singleton formula-decl nil more_list_props structures) (Box type-eq-decl nil box interval_arith) (Interval type-eq-decl nil interval interval_arith)) nil (RE2AC_box_vs_expansion subtype "affine_expr_Eval_fnd.cache" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :)), affine_expr_Eval_fnd.vs WITH [(list_props[Interval].length(affine_expr_Eval_fnd.box)) := affine_expr_Eval_fnd.x])) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.nextfreeidx)(cache)}")) (RE2AC_box_vs_expansion_TCC2-1 nil 3638607084 ("" (skeep*) (("" (typepred "cache") (("" (split 1) (("1" (use "correct_cache?_alt_def") (("1" (replace -1 :hide? t) (("1" (use "correct_cache?_alt_def") (("1" (replace -1 :hide? t) (("1" (lemma "every_implies[CacheData]") (("1" (inst? -1 :where 1) (("1" (inst? -1 :where -2) (("1" (assert) (("1" (use "CacheData_correct?_inclusion") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs?") (("2" (skeep -2) (("2" (typepred "x") (("2" (skeep -1) (("2" (inst 1 "upd_noise(N, length(box), IF SingInterval?(I) THEN 0 ELSE e ENDIF)") (("2" (split 1) (("1" (expand "vars_in_box_compatible?") (("1" (skeep) (("1" (case "i< length(box)") (("1" (inst -4 "i") (("1" (flatten) (("1" (use "nth_append2[Interval]") (("1" (replaces -1) (("1" (assert) (("1" (use "updated_noise_on_varac1") (("1" (assert) (("1" (use "gnbi_upd_2") (("1" (assert) (("1" (replaces -1) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i = length(box)") (("1" (hide 1) (("1" (replaces -1) (("1" (use "nth_append[Interval]") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth" 1) (("1" (use "eval_var_ac") (("1" (replaces -1) (("1" (use "gnbi_upd") (("1" (replaces -1) (("1" (assert) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?") (("2" (skeep) (("2" (inst -4 "i") (("2" (skeep) (("2" (inst -4 "n") (("1" (flatten) (("1" (split 1) (("1" (expand "idxs_ac_cache_not_in_idx_gap") (("1" (inst -8 "i") (("1" (use "eval_upd_no_idxs_ac") (("1" (split -1) (("1" (replaces -1) (("1" (replace -4 1 :hide? t) (("1" (expand "eval_ACExpr_Env") (("1" (use "eval_vs_idempotence") (("1" (assert) (("1" (hide 2) (("1" (expand "varidxs_re_cache_in_box") (("1" (inst -9 "i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -9 "length(box)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (assert) (("1" (case "nth_ac(box, varidx_powvar(nth(cache, i)`1)) = nth_ac(append[Interval](box, (: I :)),
                                                                   varidx_powvar(nth(cache, i)`1))") (("1" (replaces -1) (("1" (expand "pow_var_compatible?") (("1" (flatten) (("1" (assert) (("1" (skeep) (("1" (inst -9 "i_1") (("1" (use "gnbi_upd_2") (("1" (split -1) (("1" (replaces -1) (("1" (use "gnbi_upd_2") (("1" (split -1) (("1" (replaces -1) nil nil) ("2" (hide 2) (("2" (expand "nth" 1 1 :assert? nil) (("2" (expand "nth_ac" (1 -4)) (("2" (expand "var_ac" -4) (("2" (expand_ol) (("2" (lift-if -4) (("2" (assert) (("2" (split -4) (("1" (assert) (("1" (expand "var_ac" 1) (("1" (assert) (("1" (expand "cons_ol") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i_1") (("2" (hide 2) (("2" (expand "new_idxs_cache_not_in_idx_gap") (("2" (inst -14 "i") (("2" (inst -14 "i_1") (("2" (assert) (("2" (hide 1) (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (flatten) (("2" (expand "nth_ac") (("2" (use "nth_append2[Interval]") (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth_ac" 1) (("2" (use "nth_append2[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "cache") (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil) ((gt_realorder name-judgement "RealOrder" real_orders reals) (length_singleton formula-decl nil more_list_props structures) (gnbi_upd formula-decl nil affine nil) (eval_var_ac formula-decl nil affine nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (gnbi_upd_2 formula-decl nil affine nil) (le_realorder name-judgement "RealOrder" real_orders reals) (updated_noise_on_varac1 formula-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (var_ac const-decl "AffineCombination" affine nil) (length_null formula-decl nil more_list_props structures) (ac_proj_pd formula-decl nil affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (nzBaseType type-eq-decl nil affine nil) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_upd_no_idxs_ac formula-decl nil affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (Env type-eq-decl nil box interval_arith) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (null_ol? const-decl "bool" ordered_list structures) (car_ol const-decl "T" ordered_list structures) (upd_noise def-decl "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" affine nil) (SingInterval? const-decl "bool" affine nil) (Epsilon type-eq-decl nil affine nil) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)) nil (RE2AC_box_vs_expansion subtype "affine_expr_Eval_fnd.cache" "{cache: (affine_expr_Eval_fnd.compatible_pairs?(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :)), affine_expr_Eval_fnd.vs WITH [(list_props[Interval].length(affine_expr_Eval_fnd.box)) := affine_expr_Eval_fnd.x])) | affine_expr_Eval_fnd.idxs_bounded(affine_expr_Eval_fnd.nextfreeidx)(cache)}"))) (RE2AC_box_vs_expansion 0 (RE2AC_box_vs_expansion-2 "" 3638644743 ("" (induct "re") (("1" (assert) nil nil) ("2" (typepred "re!1") (("2" (assert) nil nil)) nil) ("3" (skeep*) (("3" (hide -1) (("3" (grind) nil nil)) nil)) nil) ("4" (skeep*) (("4" (hide -1) (("4" (expand "RE2AC" -5) (("4" (lift-if -5) (("4" (assert) (("4" (split -5) (("1" (expand RE2AC 1 1) (("1" (assert) (("1" (expand RE2AC 1 1) (("1" (expand RE2AC 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "RE2AC" 1) (("2" (flatten) (("2" (assert) (("2" (split -1) (("1" (propax) nil nil) ("2" (assert) (("2" (lift-if 3) (("2" (split 3) (("1" (flatten) (("1" (use "length_append[Interval]") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "nth_ac") (("2" (use "nth_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep*) (("5" (expand "RE2AC" -8) (("5" (lift-if -8) (("5" (assert) (("5" (split -8) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand "RE2AC" 3) (("2" (lift-if 3) (("2" (assert) (("2" (split -1) (("1" (split -2) (("1" (inst -2 "box" "vs" "nextfreeidx" "cache" "I" "x" "added_idx") (("1" (assert) (("1" (inst -1 "box" "vs" "val(RE2AC(ADD1_var, box, vs, nextfreeidx, cache))`1" "val(RE2AC(ADD1_var, box, vs, nextfreeidx, cache))`2" "I" "x" "added_idx") (("1" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (hide 4) (("3" (flatten) (("3" (typepred "RE2AC(ADD1_var, box, vs, nextfreeidx, cache)") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 4) (("4" (lemma "iacniig_RE2AC_preservation") (("4" (assert) (("4" (inst -1 "box" "vs" "ADD1_var" "added_idx" "nextfreeidx" "cache") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 4) (("5" (lemma "nicniig_RE2AC_preservation") (("5" (inst -1 "box" "vs" "ADD1_var" "added_idx" "nextfreeidx" "cache") (("5" (assert) nil nil)) nil)) nil)) nil) ("6" (hide 4) (("6" (use "vrcib_RE2AC_preservation") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "ADD2_var") (("2" (propax) nil nil)) nil)) nil) ("2" (typepred "ADD1_var") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "RE2AC") (("6" (propax) nil nil)) nil) ("7" (skolem 1 "op") (("7" (flatten) (("7" (hide -2) (("7" (split -1) (("1" (skeep*) (("1" (expand RE2AC -6) (("1" (lift-if -6) (("1" (assert) (("1" (split -6) (("1" (propax) nil nil) ("2" (inst -1 "box" "vs" "nextfreeidx" "cache" "I" "x" "added_idx") (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil) ("3" (propax) nil nil) ("4" (propax) nil nil) ("5" (propax) nil nil) ("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "op") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("8" (skolem 1 ("re1" "re2")) (("8" (flatten) (("8" (skeep*) (("8" (expand "RE2AC" -8) (("8" (lift-if -8) (("8" (assert) (("8" (split -8) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand "RE2AC" 3) (("2" (lift-if 3) (("2" (assert) (("2" (split -1) (("1" (split -2) (("1" (inst -2 "box" "vs" "nextfreeidx" "cache" "I" "x" "added_idx") (("1" (assert) (("1" (inst -1 "box" "vs" "val(RE2AC(re1, box, vs, nextfreeidx, cache))`1" "val(RE2AC(re1, box, vs, nextfreeidx, cache))`2" "I" "x" "added_idx") (("1" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (hide 4) (("3" (flatten) (("3" (typepred "RE2AC(re1, box, vs, nextfreeidx, cache)") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 4) (("4" (lemma "iacniig_RE2AC_preservation") (("4" (assert) (("4" (inst -1 "box" "vs" "re1" "added_idx" "nextfreeidx" "cache") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 4) (("5" (lemma "nicniig_RE2AC_preservation") (("5" (inst -1 "box" "vs" "re1" "added_idx" "nextfreeidx" "cache") (("5" (assert) nil nil)) nil)) nil)) nil) ("6" (hide 4) (("6" (use "vrcib_RE2AC_preservation") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "re2") (("2" (propax) nil nil)) nil)) nil) ("2" (typepred "re1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (skolem 1 ("re1" "re2")) (("9" (flatten) (("9" (hide -3) (("9" (split -1) (("1" (split -2) (("1" (skeep*) (("1" (label "ind hyp 1" -1) (("1" (hide "ind hyp 1") (("1" (label "ind hyp 2" -1) (("1" (hide "ind hyp 2") (("1" (expand RE2AC -5) (("1" (lift-if -5) (("1" (assert) (("1" (split -5) (("1" (expand RE2AC 1 1) (("1" (assert) (("1" (expand RE2AC 1 1) (("1" (expand RE2AC 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand RE2AC 4 1) (("2" (assert) (("2" (reveal "ind hyp 1") (("2" (inst -1 "box" "vs") (("2" (inst -1 "val(RE2AC(re1, box, vs, nextfreeidx, cache))`1" "val(RE2AC(re1, box, vs, nextfreeidx, cache))`2" "I" "x" "added_idx") (("2" (split "ind hyp 1") (("1" (flatten) (("1" (assert) (("1" (reveal "ind hyp 2") (("1" (inst -1 "box" "vs") (("1" (inst -1 "nextfreeidx" "cache" "I" "x" "added_idx") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand RE2AC 4) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (typepred "RE2AC(re1, box, vs, nextfreeidx, cache)") (("3" (assert) nil nil)) nil) ("4" (hide-all-but (-2 1)) (("4" (use "iacniig_RE2AC_preservation") (("4" (assert) nil nil)) nil)) nil) ("5" (hide-all-but (-3 1)) (("5" (use "nicniig_RE2AC_preservation") (("5" (assert) nil nil)) nil)) nil) ("6" (hide-all-but (-4 1)) (("6" (use "vrcib_RE2AC_preservation") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "re2") (("2" (propax) nil nil)) nil)) nil) ("2" (typepred "re1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("10" (expand "RE2AC") (("10" (propax) nil nil)) nil) ("11" (skolem 1 ("re" "n")) (("11" (flatten) (("11" (split -1) (("1" (skeep*) (("1" (label "ind hyp" -1) (("1" (hide "ind hyp") (("1" (hide -1) (("1" (expand RE2AC -5) (("1" (lift-if -5) (("1" (assert) (("1" (split -5) (("1" (flatten) (("1" (split -2) (("1" (propax) nil nil) ("2" (expand RE2AC 2 1) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (split 1) (("1" (assert) (("1" (use "length_append[Interval]") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (expand "nth_ac" -1) (("1" (split -1) (("1" (expand RE2AC 1) (("1" (assert) (("1" (expand "null_ol") (("1" (expand "nth_ac") (("1" (use "nth_append[Interval]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand RE2AC 1) (("2" (expand "nth_ac") (("2" (use "nth_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 3) (("1" (flatten) (("1" (assert) (("1" (expand RE2AC 1 1) (("1" (expand "nth_ac") (("1" (use "nth_append[Interval]") (("1" (assert) (("1" (expand RE2AC 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (assert) (("1" (expand RE2AC 2 1) (("1" (expand "nth_ac") (("1" (use "nth_append[Interval]") (("1" (assert) (("1" (expand RE2AC 2 1) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (split 2) (("1" (flatten) (("1" (assert) (("1" (expand RE2AC 1 1) (("1" (expand "nth_ac") (("1" (use "nth_append[Interval]") (("1" (assert) (("1" (expand RE2AC 1 1) (("1" (expand "nth_ac") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand RE2AC 2 1) (("2" (expand "nth_ac") (("2" (use "nth_append[Interval]") (("2" (assert) (("2" (expand RE2AC 2 1) (("2" (expand "nth_ac") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand RE2AC 2 1) (("2" (expand "nth_ac") (("2" (use "nth_append[Interval]") (("2" (assert) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (expand RE2AC 1 1) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand RE2AC 2 1) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (split 2) (("1" (flatten) (("1" (expand RE2AC 1 1) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "re") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("12" (expand "RE2AC") (("12" (propax) nil nil)) nil) ("13" (expand "RE2AC") (("13" (propax) nil nil)) nil) ("14" (expand "RE2AC") (("14" (propax) nil nil)) nil) ("15" (expand "RE2AC") (("15" (propax) nil nil)) nil) ("16" (assert) nil nil) ("17" (assert) nil nil) ("18" (assert) nil nil) ("19" (assert) nil nil) ("20" (assert) nil nil) ("21" (assert) nil nil) ("22" (assert) nil nil) ("23" (assert) nil nil) ("24" (skeep*) (("24" (use "RE2AC_box_vs_expansion_TCC2") (("24" (assert) nil nil)) nil)) nil) ("25" (expand "RE2AC") (("25" (propax) nil nil)) nil) ("26" (hide 2) (("26" (skeep*) (("26" (use "RE2AC_box_vs_expansion_TCC2") (("26" (assert) (("26" (inst? -1) (("26" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("27" (hide 2) (("27" (skeep*) (("27" (use "RE2AC_box_vs_expansion_TCC1") (("27" (assert) (("27" (inst? -1) nil nil)) nil)) nil)) nil)) nil)) nil) ((BLETIN adt-constructor-decl "[[IntervalExpr, BoolExpr] -> (bletin?)]" IntervalExpr_adt interval_arith) (BoolExpr type-eq-decl nil IntervalExpr_adt interval_arith) (bletin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bite? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (brel? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bimplies? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bor? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (band? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bnot? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (bconst? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (cons_ol const-decl "ordered_list" ordered_list structures) (var_ac const-decl "AffineCombination" affine nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (null_ol const-decl "ordered_list" ordered_list structures) (varidx adt-accessor-decl "[(varidx?) -> nat]" IntervalExpr_adt interval_arith) (le_realorder name-judgement "RealOrder" real_orders reals) (neg_ac const-decl "AffineCombination" affine nil) (length_singleton formula-decl nil more_list_props structures) (nth_append formula-decl nil more_list_props structures) (lt_realorder name-judgement "RealOrder" real_orders reals) (nth_ac const-decl "AffineCombination" affine_box nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (null_is_noise name-judgement "Noise" affine nil) (const_ac const-decl "AffineCombination" affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (subterm adt-def-decl "boolean" IntervalExpr_adt interval_arith) (idxs_ac const-decl "list[nat]" affine nil) (null_ol? const-decl "bool" ordered_list structures) (IntervalExpr_induction formula-decl nil IntervalExpr_adt interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (Interval type-eq-decl nil interval interval_arith) (Box type-eq-decl nil box interval_arith) (BaseType type-eq-decl nil affine nil) (Env type-eq-decl nil affine_box nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (Epsilon type-eq-decl nil affine nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (nzEpsilon type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (Noise type-eq-decl nil affine nil) (vars_in_box_compatible? const-decl "bool" affine_box nil)) shostak) (RE2AC_box_vs_expansion-1 nil 3638632016 ("" (induct "re") (("1" (assert) nil nil) ("2" (typepred "re!1") (("2" (assert) nil nil)) nil) ("3" (skeep*) (("3" (hide -1) (("3" (grind) nil nil)) nil)) nil) ("4" (skeep*) (("4" (hide -1) (("4" (expand "RE2AC" -5) (("4" (lift-if -5) (("4" (assert) (("4" (split -5) (("1" (propax) nil nil) ("2" (expand "RE2AC" 2) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (use "length_append[Interval]") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "nth_ac") (("2" (use "nth_append2[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep*) (("5" (expand "RE2AC" -8) (("5" (lift-if -8) (("5" (assert) (("5" (split -8) (("1" (propax) nil nil) ("2" (flatten) (("2" (split -1) (("1" (propax) nil nil) ("2" (expand "RE2AC" 3) (("2" (lift-if 3) (("2" (assert) (("2" (split -1) (("1" (split -2) (("1" (inst? -2 :where 2) (("1" (inst? -2 :where 3) (("1" (inst -2 "new_idx_gap") (("1" (assert) (("1" (inst -1 "box" "vs" "val(RE2AC(ADD1_var, box, vs, nextfreeidx, cache))`1" "val(RE2AC(ADD1_var, box, vs, nextfreeidx, cache))`2" "I" "x" "new_idx_gap") (("1" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (hide 4) (("3" (flatten) (("3" (typepred "RE2AC(ADD1_var, box, vs, nextfreeidx, cache)") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 4) (("4" (use "iacniig_RE2AC_preservation") (("4" (assert) nil nil)) nil)) nil) ("5" (hide 4) (("5" (use "nicniig_RE2AC_preservation") (("5" (assert) nil nil)) nil)) nil) ("6" (hide 4) (("6" (use "vrcib_RE2AC_preservation") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "ADD2_var") (("2" (propax) nil nil)) nil)) nil) ("2" (typepred "ADD1_var") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "RE2AC") (("6" (propax) nil nil)) nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil) ("9" (postpone) nil nil) ("10" (expand "RE2AC") (("10" (propax) nil nil)) nil) ("11" (postpone) nil nil) ("12" (expand "RE2AC") (("12" (propax) nil nil)) nil) ("13" (expand "RE2AC") (("13" (propax) nil nil)) nil) ("14" (expand "RE2AC") (("14" (propax) nil nil)) nil) ("15" (assert) nil nil) ("16" (assert) nil nil) ("17" (assert) nil nil) ("18" (assert) nil nil) ("19" (assert) nil nil) ("20" (assert) nil nil) ("21" (assert) nil nil) ("22" (assert) nil nil) ("23" (assert) nil nil) ("24" (postpone) nil nil) ("25" (postpone) nil nil)) nil) nil shostak)) (cp_box_vs_expansion_TCC1 0 (cp_box_vs_expansion_TCC1-1 nil 3639411132 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (>= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (above nonempty-type-eq-decl nil integers nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (^ const-decl "real" exponentiation nil) (length_singleton formula-decl nil more_list_props structures) (nth_ac const-decl "AffineCombination" affine_box nil) (varidx_powvar const-decl "nat" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (SingInterval? const-decl "bool" affine nil) (eval_ac_noise const-decl "real" affine nil) (var_ac const-decl "AffineCombination" affine nil) ({\|\|} const-decl "AffineCombination" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (/= const-decl "boolean" notequal nil)) nil (cp_box_vs_expansion subtype "affine_expr_Eval_fnd.nextfreeidx" "nat"))) (cp_box_vs_expansion_TCC2 0 (cp_box_vs_expansion_TCC2-1 nil 3639411132 ("" (skeep*) (("" (typepred "cache") (("" (use "correct_cache?_alt_def") (("" (replace -1 :hide? t) (("" (use "correct_cache?_alt_def") (("" (replace -1 :hide? t) (("" (lemma "every_implies[CacheData]") (("" (inst? -1 :where 1) (("" (inst? -1 :where -2) (("" (assert) (("" (use "CacheData_correct?_inclusion") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((above nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (upfrom nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (ordered_list type-eq-decl nil ordered_list structures) (ordered_list? def-decl "bool" ordered_list structures) (< const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (AffineCombination type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (BaseType type-eq-decl nil affine nil) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (Box type-eq-decl nil box interval_arith) (list type-decl nil list_adt nil) (Interval type-eq-decl nil interval interval_arith) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (CacheData_correct?_inclusion formula-decl nil affine_expr_Eval_fnd nil) (every_implies formula-decl nil more_list_props structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (append def-decl "list[T]" list_props nil) (correct_cache?_alt_def formula-decl nil affine_expr_Eval_fnd nil) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil (cp_box_vs_expansion subtype "affine_expr_Eval_fnd.cache" "(affine_expr_Eval_fnd.correct_cache?(list_props[Interval].append(affine_expr_Eval_fnd.box, (: affine_expr_Eval_fnd.I :))))"))) (cp_box_vs_expansion 0 (cp_box_vs_expansion-6 nil 3639419412 ("" (skeep*) (("" (label "iacniig" -1) (("" (hide "iacniig") (("" (label "vrcib" -1) (("" (hide vrcib) (("" (label nicniig -1) (("" (hide nicniig) (("" (expand "compatible_pairs?" 1) (("" (typepred "cache") (("" (expand "compatible_pairs?" -2) (("" (skolem -2 "N") (("" (flatten) (("" (typepred "x") (("" (skolem -1 "e") (("" (name "e_" "IF SingInterval?(I) THEN 0 ELSE e ENDIF") (("" (inst 1 "upd_noise(N,length(box),e_)") (("1" (split 1) (("1" (expand "vars_in_box_compatible?" 1) (("1" (skolem 1 "i") (("1" (typepred "i") (("1" (case "i<length(box)") (("1" (case "nth(append(box, (: I :)), i) = nth(box, i)") (("1" (replace -1 :hide? t) (("1" (use "eval_upd_no_idxs_ac") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (use "gnbi_upd_2") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (expand "vars_in_box_compatible?" -6) (("1" (inst -6 "i") nil nil)) nil)) nil)) nil) ("2" (replace -3 :dir RL :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (use "idxs_ac_var_ac") (("2" (assert) nil nil)) nil)) nil) ("2" (replace -3 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (use "more_list_props[Interval].nth_append") (("2" (assert) nil nil)) nil)) nil) ("3" (propax) nil nil)) nil) ("2" (case "i=length(box)") (("1" (replace -1 :hide? t) (("1" (hide -1 1) (("1" (case "nth(append(box, (: I :)), length(box)) = nth((: I :), length(box) - length(box))") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 1) (("1" (use "eval_var_ac") (("1" (replace -1 :hide? t) (("1" (use "gnbi_upd") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (replace -1 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (assert) (("2" (use "more_list_props[Interval].nth_append") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (use "length_append[Interval]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?" 1) (("2" (skolem 1 "i") (("2" (skolem 1 "n") (("2" (expand "compatible_pairs_on?" -5) (("2" (inst -5 "i") (("2" (inst -5 "n") (("1" (expand "eval_ACExpr_Env") (("1" (use "eval_vs_idempotence") (("1" (split -1) (("1" (replace -1 :hide? t :dir RL) (("1" (flatten) (("1" (use "eval_upd_no_idxs_ac") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (flatten) (("1" (case "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (assert) (("1" (expand "nth_ac") (("1" (case "nth(append(box, (: I :)), varidx_powvar(nth(cache, i)`1)) =
       nth(box, varidx_powvar(nth(cache, i)`1))") (("1" (replace -1 :hide? t) (("1" (expand "pow_var_compatible?" 1) (("1" (flatten) (("1" (expand "pow_var_compatible?" -10) (("1" (assert) (("1" (skolem 1 "i_") (("1" (inst -10 "i_") (("1" (use "gnbi_upd_2") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (use "gnbi_upd_2") (("1" (assert) (("1" (hide 2) (("1" (expand "var_ac" 1) (("1" (assert) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (expand "cons_ol") (("1" (expand "nth" -1 1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal nicniig) (("2" (expand "new_idxs_cache_not_in_idx_gap") (("2" (inst nicniig i) (("2" (inst nicniig i_) (("2" (split nicniig) (("1" (typepred "added_idx") (("1" (expand "last_idx_in_box") (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "i_") (("2" (use "cache_powvar_correct") (("2" (expand "CacheData_correct?") (("2" (flatten) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name-replace "k" "varidx_powvar(nth(cache, i)`1)") (("2" (hide-all-but (-1 1)) (("2" (use "more_list_props[Interval].nth_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal vrcib) (("2" (expand "varidxs_re_cache_in_box") (("2" (expand "varidx_powvar") (("2" (inst vrcib i) (("2" (inst?) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal iacniig) (("2" (expand "idxs_ac_cache_not_in_idx_gap") (("2" (inst iacniig i) (("2" (inst? iacniig :where -2) (("2" (assert) (("2" (typepred "added_idx") (("2" (expand "last_idx_in_box") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal vrcib) (("2" (expand "varidxs_re_cache_in_box") (("2" (inst vrcib i) nil nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((compatible_pairs? const-decl "bool" affine_expr_Eval_fnd nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (e_ skolem-const-decl "real" affine_expr_Eval_fnd nil) (length def-decl "nat" list_props nil) (upd_noise def-decl "{N_: Noise |
   (null_ol?(N) IMPLIES (null_ol?(N_) OR car_ol(N_)`1 = n)) AND
    (NOT null_ol?(N) IMPLIES
      null_ol?(N_) OR
       ((n < car_ol(N)`1 AND car_ol(N_)`1 = n) OR
         (n > car_ol(N)`1 AND car_ol(N_)`1 = car_ol(N)`1) OR
          car_ol(N_)`1 >= min(car_ol(N)`1, n)))}" affine nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (car_ol const-decl "T" ordered_list structures) (null_ol? const-decl "bool" ordered_list structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Noise type-eq-decl nil affine nil) (lt_idx const-decl "bool" indexed_list structures) (nzEpsilon type-eq-decl nil affine nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (opn adt-accessor-decl "[(pow?) -> nat]" IntervalExpr_adt interval_arith) (nzBaseType type-eq-decl nil affine nil) (ac_proj_pd formula-decl nil affine nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (new_idxs_cache_not_in_idx_gap const-decl "bool" affine_expr_Eval_fnd nil) (CacheData_correct? const-decl "bool" affine_expr_Eval_fnd nil) (pow_var_ac const-decl "AffineCombination" affine_pow nil) (cache_powvar_correct formula-decl nil affine_expr_Eval_fnd nil) (varidxs_re_cache_in_box const-decl "bool" affine_expr_Eval_fnd nil) (subterm adt-def-decl "boolean" IntervalExpr_adt interval_arith) (vs skolem-const-decl "Env" affine_expr_Eval_fnd nil) (added_idx skolem-const-decl "above(1 + last_idx_in_box(box))" affine_expr_Eval_fnd nil) (nextfreeidx skolem-const-decl "upfrom(added_idx)" affine_expr_Eval_fnd nil) (cache skolem-const-decl "{cache: (compatible_pairs?(box, vs)) | idxs_bounded(nextfreeidx)(cache)}" affine_expr_Eval_fnd nil) (i skolem-const-decl "below(length(cache))" affine_expr_Eval_fnd nil) (eval def-decl "real" interval_expr interval_arith) (bincludes? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (op shared-adt-accessor-decl "[{x: IntervalExpr |
         bincludes?(x) OR fun?(x) OR pow?(x) OR sq?(x) OR neg?(x)
     OR abs?(x)} ->
   RealExpr]" IntervalExpr_adt interval_arith) (idxs_ac_cache_not_in_idx_gap const-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil box interval_arith) (eval_vs_idempotence formula-decl nil interval_expr interval_arith) (n skolem-const-decl "upfrom(length(append(box, (: I :))))" affine_expr_Eval_fnd nil) (vars_in_box_compatible? const-decl "bool" affine_box nil) (append def-decl "list[T]" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (below type-eq-decl nil naturalnumbers nil) (length_append formula-decl nil list_props nil) (gnbi_upd formula-decl nil affine nil) (eval_var_ac formula-decl nil affine nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (eval_upd_no_idxs_ac formula-decl nil affine nil) (var_ac const-decl "AffineCombination" affine nil) (i skolem-const-decl "below(length(append(box, (: I :))))" affine_expr_Eval_fnd nil) (I skolem-const-decl "Interval" affine_expr_Eval_fnd nil) (box skolem-const-decl "Box" affine_expr_Eval_fnd nil) (idxs_ac_var_ac formula-decl nil affine nil) (empty_ErrorTerms const-decl "ErrorTerms" affine nil) (cons_ol const-decl "ordered_list" ordered_list structures) ({\|\|} const-decl "AffineCombination" affine nil) (eval_ac_noise const-decl "real" affine nil) (eval_ACExpr_Env const-decl "BaseType" affine_expr nil) (powvar? const-decl "bool" affine_expr nil) (varidx_powvar const-decl "nat" affine_expr nil) (nth_ac const-decl "AffineCombination" affine_box nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (pow_var_compatible? const-decl "bool" affine_pow nil) (compatible_pairs_on? const-decl "bool" affine_expr_Eval_fnd nil) (last_idx const-decl "int" indexed_list structures) (next_idx const-decl "nat" affine nil) (gnbi_upd_2 formula-decl nil affine nil) (nth_append formula-decl nil more_list_props structures) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_singleton formula-decl nil more_list_props structures) (SingInterval? const-decl "bool" affine nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (= const-decl "[T, T -> boolean]" equalities nil) (Epsilon type-eq-decl nil affine nil) (<= const-decl "bool" reals nil) (null_is_noise name-judgement "Noise" affine nil) (null_is_ErrorTerms name-judgement "ErrorTerms" affine nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Interval type-eq-decl nil interval interval_arith) (list type-decl nil list_adt nil) (Box type-eq-decl nil box interval_arith) (IntervalExpr type-decl nil IntervalExpr_adt interval_arith) (OR const-decl "[bool, bool -> bool]" booleans nil) (const? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (add? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (abs? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (neg? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sub? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (mult? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (sq? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (pow? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (div? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun2? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (letin? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (fun4? adt-recognizer-decl "[IntervalExpr -> boolean]" IntervalExpr_adt interval_arith) (RealExpr type-eq-decl nil IntervalExpr_adt interval_arith) (BaseType type-eq-decl nil affine nil) (ErrorTerms type-eq-decl nil affine nil) (AffineCombination type-eq-decl nil affine nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (< const-decl "bool" reals nil) (ordered_list? def-decl "bool" ordered_list structures) (ordered_list type-eq-decl nil ordered_list structures) (CacheData type-eq-decl nil affine_expr_Eval_fnd nil) (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil) (Env type-eq-decl nil affine_box nil) (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (upfrom nonempty-type-eq-decl nil integers nil) (last_idx_in_box const-decl "upfrom(-1)" affine_box nil) (above nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil) (cp_box_vs_expansion-5 nil 3639419365 ("" (skeep*) (("" (label "iacniig" -1) (("" (hide "iacniig") (("" (label "vrcib" -1) (("" (hide vrcib) (("" (label nicniig -1) (("" (hide nicniig) (("" (expand "compatible_pairs?" 1) (("" (typepred "cache") (("" (expand "compatible_pairs?" -2) (("" (skolem -2 "N") (("" (flatten) (("" (typepred "x") (("" (skolem -1 "e") (("" (name "e_" "IF SingInterval?(I) THEN 0 ELSE e ENDIF") (("" (inst 1 "upd_noise(N,length(box),e_)") (("1" (split 1) (("1" (expand "vars_in_box_compatible?" 1) (("1" (skolem 1 "i") (("1" (typepred "i") (("1" (case "i<length(box)") (("1" (use "nth_append2[Interval]") (("1" (replace -1 :hide? t) (("1" (use "eval_upd_no_idxs_ac") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (use "gnbi_upd_2") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (expand "vars_in_box_compatible?" -6) (("1" (inst -6 "i") nil))))))) ("2" (replace -3 :dir RL :hide? t) (("2" (grind) nil))))))) ("2" (use "idxs_ac_var_ac") (("2" (assert) nil))))) ("2" (replace -3 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil))))))))))) ("2" (case "i=length(box)") (("1" (replace -1 :hide? t) (("1" (hide -1 1) (("1" (use "nth_append[Interval]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 1) (("1" (use "eval_var_ac") (("1" (replace -1 :hide? t) (("1" (use "gnbi_upd") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (grind) nil))))) ("2" (replace -1 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil))))))))) ("2" (replace -1 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil))))))))))))) ("2" (use "length_append[Interval]") (("2" (assert) nil))))))))) ("2" (use "length_append[Interval]") (("2" (assert) nil))))))))))))) ("2" (expand "compatible_pairs_on?" 1) (("2" (skolem 1 "i") (("2" (skolem 1 "n") (("2" (expand "compatible_pairs_on?" -5) (("2" (inst -5 "i") (("2" (inst -5 "n") (("1" (expand "eval_ACExpr_Env") (("1" (use "eval_vs_idempotence") (("1" (split -1) (("1" (replace -1 :hide? t :dir RL) (("1" (flatten) (("1" (use "eval_upd_no_idxs_ac") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (flatten) (("1" (case "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (assert) (("1" (expand "nth_ac") (("1" (use "nth_append2[Interval]") (("1" (replace -1 :hide? t) (("1" (postpone) nil))))))))) ("2" (reveal vrcib) (("2" (expand "varidxs_re_cache_in_box") (("2" (expand "varidx_powvar") (("2" (inst vrcib i) (("2" (inst?) (("2" (assert) (("2" (grind) nil))))))))))))))))))))) ("2" (reveal iacniig) (("2" (expand "idxs_ac_cache_not_in_idx_gap") (("2" (inst iacniig i) (("2" (inst? iacniig :where -2) (("2" (assert) (("2" (typepred "first_added_idx") (("2" (expand "last_idx_in_box") (("2" (assert) nil))))))))))))))))) ("2" (hide-all-but (-1 1)) (("2" (grind) nil))))))))) ("2" (reveal vrcib) (("2" (expand "varidxs_re_cache_in_box") (("2" (inst vrcib i) nil))))))))))) ("2" (typepred "n") (("2" (use "length_append[Interval]") (("2" (assert) nil))))))))))))))))))) ("2" (hide-all-but (-1 1)) (("2" (grind) nil)))))))))))))))))))))))))))))))))) nil) nil nil) (cp_box_vs_expansion-4 nil 3639418619 ("" (skeep*) (("" (label "iacniig" -1) (("" (hide "iacniig") (("" (label "vrcib" -1) (("" (hide vrcib) (("" (expand "compatible_pairs?" 1) (("" (typepred "cache") (("" (expand "compatible_pairs?" -2) (("" (skolem -2 "N") (("" (flatten) (("" (typepred "x") (("" (skolem -1 "e") (("" (name "e_" "IF SingInterval?(I) THEN 0 ELSE e ENDIF") (("" (inst 1 "upd_noise(N,length(box),e_)") (("1" (split 1) (("1" (expand "vars_in_box_compatible?" 1) (("1" (skolem 1 "i") (("1" (typepred "i") (("1" (case "i<length(box)") (("1" (use "nth_append2[Interval]") (("1" (replace -1 :hide? t) (("1" (use "eval_upd_no_idxs_ac") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (use "gnbi_upd_2") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (expand "vars_in_box_compatible?" -6) (("1" (inst -6 "i") nil nil)) nil)) nil)) nil) ("2" (replace -3 :dir RL :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (use "idxs_ac_var_ac") (("2" (assert) nil nil)) nil)) nil) ("2" (replace -3 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i=length(box)") (("1" (replace -1 :hide? t) (("1" (hide -1 1) (("1" (use "nth_append[Interval]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 1) (("1" (use "eval_var_ac") (("1" (replace -1 :hide? t) (("1" (use "gnbi_upd") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (replace -1 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?" 1) (("2" (skolem 1 "i") (("2" (skolem 1 "n") (("2" (expand "compatible_pairs_on?" -5) (("2" (inst -5 "i") (("2" (inst -5 "n") (("1" (expand "eval_ACExpr_Env") (("1" (use "eval_vs_idempotence") (("1" (split -1) (("1" (replace -1 :hide? t :dir RL) (("1" (flatten) (("1" (use "eval_upd_no_idxs_ac") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (flatten) (("1" (case "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (assert) (("1" (expand "nth_ac") (("1" (use "nth_append2[Interval]") (("1" (replace -1 :hide? t) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal vrcib) (("2" (expand "varidxs_re_cache_in_box") (("2" (expand "varidx_powvar") (("2" (inst vrcib i) (("2" (inst?) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal iacniig) (("2" (expand "idxs_ac_cache_not_in_idx_gap") (("2" (inst iacniig i) (("2" (inst? iacniig :where -2) (("2" (assert) (("2" (typepred "first_added_idx") (("2" (expand "last_idx_in_box") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal vrcib) (("2" (expand "varidxs_re_cache_in_box") (("2" (inst vrcib i) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (cp_box_vs_expansion-3 nil 3639417319 ("" (skeep*) (("" (label "iacniig" -1) (("" (hide "iacniig") (("" (expand "compatible_pairs?" 1) (("" (typepred "cache") (("" (expand "compatible_pairs?" -2) (("" (skolem -2 "N") (("" (flatten) (("" (typepred "x") (("" (skolem -1 "e") (("" (name "e_" "IF SingInterval?(I) THEN 0 ELSE e ENDIF") (("" (inst 1 "upd_noise(N,length(box),e_)") (("1" (split 1) (("1" (expand "vars_in_box_compatible?" 1) (("1" (skolem 1 "i") (("1" (typepred "i") (("1" (case "i<length(box)") (("1" (use "nth_append2[Interval]") (("1" (replace -1 :hide? t) (("1" (use "eval_upd_no_idxs_ac") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (use "gnbi_upd_2") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (expand "vars_in_box_compatible?" -6) (("1" (inst -6 "i") nil nil)) nil)) nil)) nil) ("2" (replace -3 :dir RL :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (use "idxs_ac_var_ac") (("2" (assert) nil nil)) nil)) nil) ("2" (replace -3 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i=length(box)") (("1" (replace -1 :hide? t) (("1" (hide -1 1) (("1" (use "nth_append[Interval]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 1) (("1" (use "eval_var_ac") (("1" (replace -1 :hide? t) (("1" (use "gnbi_upd") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (replace -1 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?" 1) (("2" (skolem 1 "i") (("2" (skolem 1 "n") (("2" (expand "compatible_pairs_on?" -5) (("2" (inst -5 "i") (("2" (inst -5 "n") (("1" (expand "eval_ACExpr_Env") (("1" (use "eval_vs_idempotence") (("1" (split -1) (("1" (replace -1 :hide? t :dir RL) (("1" (flatten) (("1" (use "eval_upd_no_idxs_ac") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (flatten) (("1" (case "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (assert) (("1" (expand "nth_ac") (("1" (use "nth_append2[Interval]") (("1" (replace -1 :hide? t) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal "iacniig") (("2" (expand "idxs_ac_cache_not_in_idx_gap") (("2" (inst iacniig i) (("2" (inst iacniig "varidx_powvar(nth(cache, i)`1)") (("2" (case "member(varidx_powvar(nth(cache, i)`1), idxs_ac(nth(cache, i)`2))") (("1" (split iacniig) (("1" (propax) nil nil) ("2" (typepred "first_added_idx") (("2" (expand "last_idx_in_box") (("2" (postpone) nil nil)) nil)) nil) ("3" (propax) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (cp_box_vs_expansion-2 nil 3639417284 ("" (skeep*) (("" (label "iacniig" 1) (("" (hide "iacniig") (("" (expand "compatible_pairs?" 1) (("" (typepred "cache") (("" (expand "compatible_pairs?" -2) (("" (skolem -2 "N") (("" (flatten) (("" (typepred "x") (("" (skolem -1 "e") (("" (name "e_" "IF SingInterval?(I) THEN 0 ELSE e ENDIF") (("" (inst 1 "upd_noise(N,length(box),e_)") (("1" (split 1) (("1" (expand "vars_in_box_compatible?" 1) (("1" (skolem 1 "i") (("1" (typepred "i") (("1" (case "i<length(box)") (("1" (use "nth_append2[Interval]") (("1" (replace -1 :hide? t) (("1" (use "eval_upd_no_idxs_ac") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (use "gnbi_upd_2") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (expand "vars_in_box_compatible?" -6) (("1" (inst -6 "i") nil))))))) ("2" (replace -3 :dir RL :hide? t) (("2" (grind) nil))))))) ("2" (use "idxs_ac_var_ac") (("2" (assert) nil))))) ("2" (replace -3 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil))))))))))) ("2" (case "i=length(box)") (("1" (replace -1 :hide? t) (("1" (hide -1 1) (("1" (use "nth_append[Interval]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 1) (("1" (use "eval_var_ac") (("1" (replace -1 :hide? t) (("1" (use "gnbi_upd") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (grind) nil))))) ("2" (replace -1 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil))))))))) ("2" (replace -1 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil))))))))))))) ("2" (use "length_append[Interval]") (("2" (assert) nil))))))))) ("2" (use "length_append[Interval]") (("2" (assert) nil))))))))))))) ("2" (expand "compatible_pairs_on?" 1) (("2" (skolem 1 "i") (("2" (skolem 1 "n") (("2" (expand "compatible_pairs_on?" -5) (("2" (inst -5 "i") (("2" (inst -5 "n") (("1" (expand "eval_ACExpr_Env") (("1" (use "eval_vs_idempotence") (("1" (split -1) (("1" (replace -1 :hide? t :dir RL) (("1" (flatten) (("1" (use "eval_upd_no_idxs_ac") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (flatten) (("1" (case "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (assert) (("1" (expand "nth_ac") (("1" (use "nth_append2[Interval]") (("1" (replace -1 :hide? t) (("1" (postpone) nil))))))))) ("2" (postpone) nil))))))))) ("2" (postpone) nil))) ("2" (hide-all-but (-1 1)) (("2" (grind) nil))))))))) ("2" (postpone) nil))))))) ("2" (typepred "n") (("2" (use "length_append[Interval]") (("2" (assert) nil))))))))))))))))))) ("2" (hide-all-but (-1 1)) (("2" (grind) nil)))))))))))))))))))))))))) nil) nil nil) (cp_box_vs_expansion-1 nil 3639411515 ("" (skeep*) (("" (expand "compatible_pairs?" 1) (("" (typepred "cache") (("" (expand "compatible_pairs?" -2) (("" (skolem -2 "N") (("" (flatten) (("" (typepred "x") (("" (skolem -1 "e") (("" (name "e_" "IF SingInterval?(I) THEN 0 ELSE e ENDIF") (("" (inst 1 "upd_noise(N,length(box),e_)") (("1" (split 1) (("1" (expand "vars_in_box_compatible?" 1) (("1" (skolem 1 "i") (("1" (typepred "i") (("1" (case "i<length(box)") (("1" (use "nth_append2[Interval]") (("1" (replace -1 :hide? t) (("1" (use "eval_upd_no_idxs_ac") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (use "gnbi_upd_2") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (expand "vars_in_box_compatible?" -6) (("1" (inst -6 "i") nil nil)) nil)) nil)) nil) ("2" (replace -3 :dir RL :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (use "idxs_ac_var_ac") (("2" (assert) nil nil)) nil)) nil) ("2" (replace -3 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i=length(box)") (("1" (replace -1 :hide? t) (("1" (hide -1 1) (("1" (use "nth_append[Interval]") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "nth" 1) (("1" (use "eval_var_ac") (("1" (replace -1 :hide? t) (("1" (use "gnbi_upd") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (replace -1 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1 :dir RL :hide? t) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compatible_pairs_on?" 1) (("2" (skolem 1 "i") (("2" (skolem 1 "n") (("2" (expand "compatible_pairs_on?" -5) (("2" (inst -5 "i") (("2" (inst -5 "n") (("1" (expand "eval_ACExpr_Env") (("1" (use "eval_vs_idempotence") (("1" (split -1) (("1" (replace -1 :hide? t :dir RL) (("1" (flatten) (("1" (use "eval_upd_no_idxs_ac") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (flatten) (("1" (case "varidx_powvar(nth(cache, i)`1) < length(box)") (("1" (assert) (("1" (expand "nth_ac") (("1" (use "nth_append2[Interval]") (("1" (replace -1 :hide? t) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (use "length_append[Interval]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)))
