(affine_bandb_simple
 (altvar_TCC1 0
  (altvar_TCC1-1 nil 3627226550 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (/= const-decl "boolean" notequal nil))
   nil))
 (altvar_TCC2 0
  (altvar_TCC2-1 nil 3627226550
   ("" (skeep :preds? t)
    (("" (lemma "mod_pos")
      (("" (inst?)
        (("1" (assert) nil nil)
         ("2" (hide 2) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((mod_pos formula-decl nil mod nil)
    (mod const-decl "{k | abs(k) < abs(j)}" mod nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (stack type-eq-decl nil stack "structures/")
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (AnsType type-eq-decl nil affine_bandb_simple nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (list type-decl nil list_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (Box type-eq-decl nil box "interval_arith/")
    (box skolem-const-decl "Box" affine_bandb_simple nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (simple_affine_soundness 0
  (simple_affine_soundness-1 nil 3627301744
   ("" (skeep)
    (("" (lemma "b_and_b_id_sound")
      (("" (expand "simple_affine")
        (("" (inst?)
          (("" (assert)
            (("" (hide 2)
              (("" (split)
                (("1" (expand "accomodates?")
                  (("1" (skeep)
                    (("1" (expand "sound?")
                      (("1" (flatten)
                        (("1" (skeep)
                          (("1" (lemma "EvalwCache_inclusion")
                            (("1" (inst?)
                              (("1"
                                (beta)
                                (("1"
                                  (expand "evaluate")
                                  (("1"
                                    (lift-if 1)
                                    (("1"
                                      (split 1)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand "Eval")
                                          (("1"
                                            (lift-if -1)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (split -1)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (use
                                                     "containment_interval")
                                                    (("1"
                                                      (expand
                                                       "containment")
                                                      (("1"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (expand "Eval")
                                          (("2"
                                            (lift-if 1)
                                            (("2"
                                              (split 1)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "subdiv_presound?")
                  (("2" (skeep)
                    (("2" (expand "denorm")
                      (("2" (expand "branch")
                        (("2" (expand "subdivide")
                          (("2" (expand "sound?")
                            (("2" (flatten)
                              (("2"
                                (expand "combine")
                                (("2"
                                  (use "Proper_Safe2")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (flatten)
                                      (("2"
                                        (replaces -3)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (skeep :preds? t)
                                            (("2"
                                              (inst - "vs")
                                              (("2"
                                                (rewrite
                                                 "Union_inclusion")
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (expand "subdiv_sound?")
                  (("3" (skeep)
                    (("3" (expand "denorm")
                      (("3" (expand "branch")
                        (("3" (expand "subdivide")
                          (("3" (expand "sound?")
                            (("3" (flatten)
                              (("3"
                                (expand "combine")
                                (("3"
                                  (use "Proper_Safe2")
                                  (("3"
                                    (assert)
                                    (("3"
                                      (flatten)
                                      (("3"
                                        (replaces -3)
                                        (("3"
                                          (assert)
                                          (("3"
                                            (skeep :preds? t)
                                            (("3"
                                              (lemma
                                               "split_vars_in_box")
                                              (("3"
                                                (inst
                                                 -1
                                                 "dom"
                                                 "vs"
                                                 "v")
                                                (("3"
                                                  (beta)
                                                  (("3"
                                                    (split -1)
                                                    (("1"
                                                      (inst? -5)
                                                      (("1"
                                                        (rewrite
                                                         "Union_inclusion")
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      (("2"
                                                        (inst? -6)
                                                        (("2"
                                                          (rewrite
                                                           "Union_inclusion")
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Box type-eq-decl nil box "interval_arith/")
    (list type-decl nil list_adt nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (AnsType type-eq-decl nil affine_bandb_simple nil)
    (real nonempty-type-from-decl nil reals nil)
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (b_and_b_id_sound formula-decl nil branch_and_bound "structures/")
    (Accumulator type-eq-decl nil branch_and_bound "structures/")
    (accumulate const-decl "AnsType" affine_bandb_simple nil)
    (Brancher type-eq-decl nil branch_and_bound "structures/")
    (branch const-decl "[RealExpr, RealExpr]" affine_bandb_simple nil)
    (Combiner type-eq-decl nil branch_and_bound "structures/")
    (combine const-decl "AnsType" affine_bandb_simple nil)
    (DirVar type-eq-decl nil branch_and_bound "structures/")
    (DenormAns type-eq-decl nil branch_and_bound "structures/")
    (denorm const-decl "AnsType" affine_bandb_simple nil)
    (Evaluator type-eq-decl nil branch_and_bound "structures/")
    (evaluate const-decl "AnsType" affine_bandb_simple nil)
    (stack type-eq-decl nil stack "structures/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (DirVarStack type-eq-decl nil branch_and_bound "structures/")
    (ExitPred type-eq-decl nil branch_and_bound "structures/")
    (ge const-decl "bool" affine_bandb_simple nil)
    (LocalExitPred type-eq-decl nil branch_and_bound "structures/")
    (le const-decl "bool" affine_bandb_simple nil)
    (prune const-decl "bool" affine_bandb_simple nil)
    (DirVarSelector type-eq-decl nil branch_and_bound "structures/")
    (altvar const-decl "DirVar" affine_bandb_simple nil)
    (SoundPred type-eq-decl nil branch_and_bound "structures/")
    (sound? const-decl "bool" affine_bandb_simple nil)
    (SubdivDomain type-eq-decl nil branch_and_bound "structures/")
    (subdivide const-decl "[Box, Box]" affine_bandb_simple nil)
    (subdiv_sound? const-decl "bool" branch_and_bound "structures/")
    (split_vars_in_box formula-decl nil interval_expr
     "interval_arith/")
    (below type-eq-decl nil naturalnumbers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (HalfLeft const-decl "Interval" interval "interval_arith/")
    (HalfRight const-decl "Interval" interval "interval_arith/")
    (split def-decl "{lrb: [Box, Box] |
         LET (lb, rb) = lrb IN
           length(lb) = length(box) AND
            length(rb) = length(box) AND
             (FORALL (i: below(length(box))):
                IF i = v
                  THEN nth(lb, i) = HalfLeft(nth(box, i)) AND
                        nth(rb, i) = HalfRight(nth(box, i))
                ELSE nth(lb, i) = nth(box, i) AND nth(rb, i) = nth(box, i)
                ENDIF)}" interval_expr "interval_arith/")
    (v skolem-const-decl "nat" affine_bandb_simple nil)
    (dom skolem-const-decl "Box" affine_bandb_simple nil)
    (vs skolem-const-decl "(vars_in_box?(dom))" affine_bandb_simple
     nil)
    (subdiv_presound? const-decl "bool" branch_and_bound "structures/")
    (Proper_Safe2 formula-decl nil safe_arith "interval_arith/")
    (Union const-decl "Interval" interval "interval_arith/")
    (Union_inclusion formula-decl nil interval "interval_arith/")
    (accomodates? const-decl "bool" branch_and_bound "structures/")
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (Eval const-decl "Maybe[AffineCombination]" affine_expr_Eval nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (containment const-decl "bool" affine nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (eval_ACExpr_Env const-decl "BaseType" affine_expr nil)
    (Env type-eq-decl nil affine_box nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Eval_wCache def-decl
                 "{result: Maybe[[nat, (correct_cache?(box))]] |
         some?(result) IMPLIES
          LET res = val(result)`2, newnidx = val(result)`1 IN
                 NOT null?(res) AND car(res)`1 = re
             AND (EXISTS (l: list[CacheData]): res = append(l, cache))
             AND newnidx >= nextfreeidx AND idxs_bounded(newnidx)(res)}"
                 affine_expr_Eval nil)
    (append def-decl "list[T]" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (idxs_bounded const-decl "bool" affine_expr_Eval_fnd nil)
    (last_idx_in_box const-decl "upfrom(-1)" affine_box nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (> const-decl "bool" reals nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (correct_cache? def-decl "bool" affine_expr_Eval_fnd nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (CacheData type-eq-decl nil affine_expr_Eval_fnd nil)
    (ordered_list type-eq-decl nil ordered_list "structures/")
    (ordered_list? def-decl "bool" ordered_list "structures/")
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AffineCombination type-eq-decl nil affine nil)
    (ErrorTerms type-eq-decl nil affine nil)
    (BaseType type-eq-decl nil affine nil)
    (containment_interval formula-decl nil affine nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (EmptyInterval const-decl "Interval" interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (Proper? const-decl "bool" interval "interval_arith/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (int_minus_int_is_int application-judgement "int" integers nil)
    (EvalwCache_inclusion formula-decl nil affine_expr_Eval nil)
    (simple_affine const-decl "Output" affine_bandb_simple nil))
   nil))
 (zero_to_one_quarter_smp 0
  (zero_to_one_quarter_smp-1 nil 3647953328
   ("" (skeep) (("" (aa-simple-numerical (! 1 1)) nil nil)) nil)
   ((TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (FALSE const-decl "bool" booleans nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (simple_affine const-decl "Output" affine_bandb_simple nil)
    (Output type-eq-decl nil branch_and_bound "structures/")
    (AnsType type-eq-decl nil affine_bandb_simple nil)
    (Box type-eq-decl nil box "interval_arith/")
    (list type-decl nil list_adt nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (vars_in_box formula-decl nil box "interval_arith/")
    (vars_in_box_rec def-decl
     "{b: bool | b = (FORALL (k: subrange(i, n - 1)): vs(k) ## nth(box, k - i))}"
     box "interval_arith/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (eval_ACExpr_Env const-decl "BaseType" affine_expr nil)
    (Env type-eq-decl nil affine_box nil)
    (BaseType type-eq-decl nil affine nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ub_interval formula-decl nil interval "interval_arith/")
    (lb_interval formula-decl nil interval "interval_arith/")
    (|##| const-decl "bool" interval "interval_arith/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (r2i_Proper application-judgement "ProperInterval" interval
     "interval_arith/")
    (r2i_Pos application-judgement "(Pos?)" interval "interval_arith/")
    (r2i_Nneg application-judgement "(NonNeg?)" interval
     "interval_arith/")
    (length_singleton formula-decl nil more_list_props "structures/")
    (eval def-decl "real" interval_expr "interval_arith/")
    (sia_3 skolem-const-decl "(mult?)" affine_bandb_simple nil)
    (x skolem-const-decl "real" affine_bandb_simple nil)
    (list2array def-decl "T" array2list "structures/")
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (vars_in_box? const-decl "bool" box "interval_arith/")
    (Env type-eq-decl nil box "interval_arith/")
    (sound? const-decl "bool" affine_bandb_simple nil)
    (simple_affine_soundness formula-decl nil affine_bandb_simple nil)
    (IntervalExpr type-decl nil IntervalExpr_adt "interval_arith/")
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (const? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (varidx? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (add? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (abs? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (neg? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sub? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (mult? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (sq? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (pow? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (div? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (fun? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (letin? adt-recognizer-decl "[IntervalExpr -> boolean]"
     IntervalExpr_adt "interval_arith/")
    (RealExpr type-eq-decl nil IntervalExpr_adt "interval_arith/")
    (MULT adt-constructor-decl "[[RealExpr, RealExpr] -> (mult?)]"
     IntervalExpr_adt "interval_arith/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (X const-decl "RealExpr" interval_expr "interval_arith/")
    (SUB adt-constructor-decl "[[RealExpr, RealExpr] -> (sub?)]"
     IntervalExpr_adt "interval_arith/")
    (r2E const-decl "RealExpr" interval_expr "interval_arith/"))
   shostak)))

