affine_bandb: THEORY
BEGIN

  IMPORTING affine_expr, interval_arith@safe_arith,
            structures@array2list[real]

  AnsType: TYPE = Interval

  IMPORTING structures@branch_and_bound[RealExpr,AnsType,Box,nat]

  expr      : VAR RealExpr
  box       : VAR Box
  v         : VAR nat
  maxdepth  : VAR nat
  dirvar    : VAR DirVar
  dirvars   : VAR DirVarStack
  ans,
  ans1,ans2 : VAR AnsType
  acc       : VAR AnsType

  evaluate(box,expr) : AnsType = LET eval_res = Eval_ACExpr_Box(expr,box) IN
  		       	       	 IF some?(eval_res) THEN eval_by_intervals(val(eval_res))
				 ELSE EmptyInterval ENDIF

  branch(v,expr) : [RealExpr,RealExpr] = (expr,expr)
  subdivide(v,box) : [Box,Box]   = split(v,box)
  denorm(dirvar,ans) : AnsType   = ans
  combine(v,ans1,ans2) : AnsType = Safe2(interval.Union)(ans1,ans2)
  accumulate(acc,ans) : AnsType  = combine(0,acc,ans)

  prune(dirvars,acc,ans) : bool = false
  le(ans) : bool = false
  ge(dirvars,acc,ans) : bool = EmptyInterval?(ans)


  altvar(dirvars,acc,box,expr) : DirVar =
    IF null?(box) THEN 
      (FALSE,0)
    ELSE
      (FALSE,mod(length(dirvars),length(box)))
    ENDIF


  simple_affine(maxdepth,expr,box) : Output =
    b_and_b_id(evaluate,branch,subdivide,denorm,combine,prune,
               le,ge,altvar,accumulate,maxdepth,expr,box)

  sound?(box,expr,ans) : bool = 
    Proper?(ans) IMPLIES
      FORALL (vs:(vars_in_box?(box))): eval_ACExpr_Env(expr,vs) ## ans

  simple_affine_soundness : THEOREM
    sound?(box,expr,simple_affine(maxdepth,expr,box)`ans)

  x : VAR real

  trivial_test : LEMMA
  x ## [| 0, 1 |] 
  IMPLIES 1 ## [| 1, 1 |]
%|- trivial_test : PROOF
%|- (then (skeep) (simple-affine (! 1 1)))
%|- QED

  simple_test1 : LEMMA
  x ## [| 0, 1 |] 
  IMPLIES x+x ## [| 0, 2 |]
%|- simple_test1 : PROOF
%|- (then (skeep) (simple-affine (! 1 1)))
%|- QED

  simple_test2 : LEMMA
  x ## [| 0, 1 |] 
  IMPLIES x-x ## [| 0, 0 |]
%|- simple_test2 : PROOF
%|- (then (skeep) (simple-affine (! 1 1)))
%|- QED

  simple_test3 : LEMMA
  x ## [| 0, 1 |] 
  IMPLIES x+(1-x)-1 ## [| 0, 0 |]
%|- simple_test3 : PROOF
%|- (then (skeep) (simple-affine (! 1 1)))
%|- QED

  simple_test : LEMMA
  x ## [| 0, 1 |] 
  IMPLIES x*(1-x) ## [| 0, 0.251 |]
%|- simple_test : PROOF
%|- (then (skeep) (simple-affine (! 1 1)))
%|- QED

  simple_test_bad : LEMMA
  x ## [| 0.3, 0.7 |] 
  IMPLIES x*(1-x) ## [| 0, 0.251 |]

%|- simple_test_bad : PROOF
%|- (then (skeep) (name-label "sia" "MULT(X(0),SUB(r2E(1),X(0)))" :hide? t)
%|-  (eval-expr "simple_affine(5,sia,(: [|3/10,7/10|] :))" :safe? nil)
%|-  (lemma "simple_affine_soundness") (inst? -1) (replaces -2) (beta -1)
%|-  (expand "sound?" -1)
%|-  (spread (split -1)
%|-   ((spread (inst -1 "list2array(0)((:x:))")
%|-     ((spread (invoke (case "%1 = %2") (! -1 1) "(x * (1 - x))")
%|-       ((then (replaces -1) (decimalize -1 3) (lemma "Member_trans")
%|-         (inst? -1 :where 1) (inst? -1 :where -2) (assert)
%|-         (eval-formula 1))
%|-        (interval-eq__ "sia" 1)))
%|-      (then (apply (repeat (expand "list2array" 1)))
%|-       (rewrite "vars_in_box")
%|-       (apply (repeat (expand "vars_in_box_rec" 1))))))
%|-    (eval-formula))))
%|- QED


% Pow tests
  pow_simple_test_1 : LEMMA
  x ## [| 0, 1 |] 
  IMPLIES x^2 ## [| -0.001, 1 |]

  pow_simple_test_2 : LEMMA
  x ## [| 1, 2 |] 
  IMPLIES x^2 ## [| 0.999, 4 |]

  pow_simple_test_3 : LEMMA
  x ## [| 0.01, 1 |] 
  IMPLIES x^2 ## [| -0.001, 1 |]

END affine_bandb
