accum_err_div[
  radix : above(1),
  (IMPORTING cr_div[radix])
  b     : Format,
  round : {round: RestrictedRounding(b,EvenClosest?) | rounded_mode?(b)(round)},
  RtoF  : CanonicRoundingFun(b,round)
]: THEORY
BEGIN
  f,f1,f2 : VAR (Fbounded?(b))
  e,e1,e2 : VAR nonneg_real
  r,r1,r2 : VAR real

  IMPORTING reals@abs_lems,
            interval_arith@interval_mps
  
  div_aerr_bound(r1,e1,r2,(e2|0<r2-e2 OR r2+e2<0)): nonneg_real =
    (abs(r2)*e1 + abs(r1)*e2) / (r2*r2 - e2*abs(r2))

  % Error of the (correctly-rounded) function w.r.t. the real operation on
  % the (real version of the) floating point numbers. 
  div_accum_err: LEMMA
    abs(FtoR(f1)-r1) <= e1 AND
    abs(FtoR(f2)-r2) <= e2 AND
    (0<r2-e2 OR r2+e2<0)
    IMPLIES abs(FtoR(f1)/FtoR(f2)-(r1/r2))
            <= div_aerr_bound(r1,e1,r2,e2)

  div_ulp_bound(r1,e1,r2,(e2|0<r2-e2 OR r2+e2<0)): real = (abs(r1) + e1) / (abs(r2) - e2)

  Fdiv_accum_err_bound: LEMMA
    abs(FtoR(f1)-r1) <= e1 AND
    abs(FtoR(f2)-r2) <= e2 AND
    (0<r2-e2 OR r2+e2<0)
    IMPLIES abs(FtoR(f1) / FtoR(f2)) <= div_ulp_bound(r1,e1,r2,e2)  

  div_fp_pre(f1,f2): MACRO bool =
    FtoR(f2)/=0

  div_fp(f1,(f2|div_fp_pre(f1,f2))): MACRO (Fbounded?(b)) =
    Fdiv(b)(f1,f2)

  IMPORTING accum_err_op2sch[
              (Fbounded?(b)), FtoR, RtoF, ulp(b, round, RtoF),
	      
%% This line generates unprovable tccs, is it a bug?
% 	      LAMBDA(f1,f2): FtoR(f2)/=0, Fdiv(b),
              div_fp_pre, div_fp,
	      
	      LAMBDA(r1,r2): r2/=0, /,
	      LAMBDA(r1,e1,r2,e2): 0<r2-e2 OR r2+e2<0,
	      div_aerr_bound,
	      LAMBDA(r1,e1,r2,e2): 0<r2-e2 OR r2+e2<0,
	      div_ulp_bound]

  accum_err_bound: LEMMA
    abs(FtoR(f1)-r1) <= e1 AND
    abs(FtoR(f2)-r2) <= e2 AND
    (0<r2-e2 OR r2+e2<0)
    IMPLIES abs(FtoR(Fdiv(b)(f1,f2)) - (r1/r2))
            <= div_aerr_bound(r1,e1,r2,e2)
	       + ulp(b, round, RtoF)(div_ulp_bound(r1,e1,r2,e2)) / 2    

END accum_err_div
