(defparameter *tarski-invalid-forms* nil) ;; List of invalid forms

(defun tarski-relation (expr &optional neg)
  (is-function-expr
   expr
   (if neg '(> < = >= <= /=) '(<= >= /= < > =))))

;; Return a list (n e1 e2) where e1 and e2 are atomic expressions and n is its
;; (coded) relation representing the relation expression e. Relations are coded as follows:
;; 0 (=), 1 (>), 2 (<), 3 (/=), 4 (>=), 5 (<=)
;; If b is negative, expression is an interval relation, i.e., ##. In any other case, n is nil
(defun tarski-atomic-rel-expr (expr &optional neg)
  (if (extra-negation expr)
      (tarski-atomic-rel-expr (args1 expr) (not neg))
    (let ((r (1- (length (tarski-relation expr neg)))))
      (cond
       ((>= r 0)
	(cond ((is-function-expr (args1 expr) 'abs)
	       (if (member r '(2 5))
		   (cons r (arguments expr))
		 (cons nil expr)))
	      ((is-function-expr (args2 expr) 'abs)
	       (if (member r '(1 4))
		   (cons (1+ r) (reverse (arguments expr)))
		 (cons nil expr)))
	      (t (cons r (arguments expr)))))
       ((and (not neg) (is-function-expr expr "##"))
	(let ((val (extra-add-evalexpr (args2 expr))))
	  (if (record-expr? val)
	      (cons -1 (list (args1 expr) val))
	    (cons nil expr))))
       (t (cons nil expr))))))

;; Return a list of pairs (str n), where str is a string representation of
;; a polynomial and n is the code of its relation wrt to 0
(defun tarski-valid-forms-rec (exprs vars strict accum)
  (if (null exprs) accum
    (let* ((e    (car exprs))
	   (xprs (cdr exprs))
	   (re   (tarski-atomic-rel-expr e))
	   (r    (car re)))
      (cond
       ((null r)
	(push (cdr re) *tarski-invalid-forms*)
	(unless strict
	  (tarski-valid-forms-rec xprs vars strict accum)))
       ((>= r 0)
	(let* ((e0    (nth 1 re))
	       (e1    (if (is-function-expr e0 'abs) (args1 e0) e0))
	       (e2    (nth 2 re))
	       (conj1 (sturm-expr-wrt0 e1 e2))
	       (pe1   (catch '*sturm-error*
			(list (sturm-poly-expr-rec conj1 vars) r))))
	  (cond ((null pe1) 
		 (push conj1 *tarski-invalid-forms*)
		 (unless strict
		   (tarski-valid-forms-rec xprs vars strict accum)))
		((is-function-expr e0 'abs)
		 (let* ((conj2 (sturm-expr-wrt0 e1 e2 t))
			(pe2   (list (sturm-poly-expr-rec conj2 vars) (1- r))))
		   (tarski-valid-forms-rec xprs vars strict
					   (cons pe2 (cons pe1 accum)))))
		(t (tarski-valid-forms-rec xprs vars strict
					   (cons pe1 accum))))))
       (t (let* ((e1    (nth 1 re))
		 (e2    (nth 2 re))
		 (lb    (get-expr-from-obj e2 'lb))
		 (ub    (get-expr-from-obj e2 'ub))
		 (conja (when ub (sturm-expr-wrt0 e1 ub)))
		 (conjb (when lb (sturm-expr-wrt0 e1 lb))))
	    (cond
	     ((and conja conjb)
	      (let* ((ba  (get-expr-from-obj e2 'bounded_above))
		     (bb  (get-expr-from-obj e2 'bounded_below))
		     (ca  (get-expr-from-obj e2 'closed_above))
		     (cb  (get-expr-from-obj e2 'closed_below))
		     (ra  (if (or (null ca) (extra-is-true ca)) 5 2))
		     (rb  (if (or (null cb) (extra-is-true cb)) 4 1))
		     (pea (catch '*sturm-error*
			    (list (sturm-poly-expr-rec conja vars) ra)))
		     (peb (catch '*sturm-error*
			    (list (sturm-poly-expr-rec conjb vars) rb))))
		(cond ((or (null pea) (null peb))
		       (push (cdr re) *tarski-invalid-forms*)
		       (unless strict
			 (tarski-valid-forms-rec xprs vars strict accum)))
		      (t (let ((acc (append
				     (when (or (null ba) (extra-is-true ba)) (list pea))
				     (when (or (null bb) (extra-is-true bb)) (list peb))
				     accum)))
			   (tarski-valid-forms-rec xprs vars strict acc))))))
	     (t (push (cdr re) *tarski-invalid-forms*)
		(unless strict
		  (tarski-valid-forms-rec xprs vars strict accum))))))))))

(defun tarski-valid-forms (exprs vars &optional strict)
  (setq *tarski-invalid-forms* nil)
  (setq *sturm-var* nil)
  (extra-reset-evalexprs)
  (tarski-valid-forms-rec exprs vars strict nil))

(defstep tarski (&optional (fnums *) var preds? dont-fail? (equiv? t) timing?)
  (let ((fns    (extra-get-fnums fnums))
	(fn     (if (equal (length fns) 1) (car fns) 0))
	(expr   (when (/= fn 0)
		  (let ((e (extra-get-formula-from-fnum fn)))
		    (if preds? (lift-predicates-in-quantifier e (list *real*)) e))))
	(quant  (cond ((forall-expr? expr) 1)
		      ((exists-expr? expr) -1)
		      (t 0))) ;; forall: quant > 0, exists: quant < 0, none: 0
	(vars   (if (/= quant 0)
		    (mapcar #'(lambda (x) (format nil "~a" (id x)))
			    (bindings (extra-get-formula-from-fnum fn)))
		  (enlist-it var)))
	(fall   (>= (* fn quant) 0))
	(unqexpr  (when (/= quant 0) (expression expr)))
	(conjs  (if (/= quant 0)
		    (let ((exprs (get-ands-expr unqexpr (< quant 0))))
		      (tarski-valid-forms exprs vars (not fall)))
		  (let ((exprs (get-ands-expr
				(mk-disjunction (mapcar #'formula (extra-get-seqfs fns)))
				nil)))
		    (tarski-valid-forms exprs vars))))
	(invfms *tarski-invalid-forms*)
	(tkvar  *sturm-var*)
	(qvars  (when (/= quant 0) vars))
	(qth    (no-qualified-name "Tarski@strategies.TarskiStrategy__"))
	(dont-fail?  (or dont-fail? (not equiv?)))
	(msg    (cond (qth
		       (format nil "This strategy requires theory ~a to be imported in the current context" qth))
		      ((null tkvar)
		       (format nil "No variable found in formulas ~a." fnums))
		      ((null conjs)
		       (format nil "The following formula doesn't belong to a system of polynomial constraints on ~a
supported by this strategy:~%~{~a~%~}"
			       tkvar invfms))
		      ((and (< (* fn quant) 0) (> (length qvars) 1))
		       (format nil "Formula ~a is not simply quantified." fn)))))
    (if msg
	(printf "~a" msg)
      (with-fresh-labels@
       ((labfalse!))
       (tarski__$ fnums fall conjs tkvar qvars preds? equiv? labfalse! timing?)
       (when invfms
	 (printf "The following formulas don't belong to a system of polynomials constraints on ~a
and were not considered by this strategy:~%~{~a~%~}"
		 tkvar invfms))
       (when-label
	labfalse!
	(printf "Sequent formed by formulas in ~a~:[, without considering typing information, may not~; doesn't~] hold.~%" 
		fnums preds?))
       (unless dont-fail? (fail)))))
  "[Tarski] Applies decision procedure for univariate polynomial based on Tarski's Theorem
to formulas in FNUM. Each formula denoted by FNUM is expected to have the form pi Ri qi,
where pi and qi are polynomials on variable VAR and Ri is a relation in {<,<=,>,>=,=,/=}.
If FNUM denotes a simply quantified formula, that formula is expected to have one of the forms
- EXISTS (VAR:real) : p0 R0 q0 AND ... AND pn Rn qn
- FORALL (VAR:real) : p0 R0 q0 AND ... AND pi Ri qi IMPLIES pj Rj qj OR ... OR pn Rn qn.
If variable VAR is not provided, it is inferred by the strategy from the formulas in FNUM. 

The subtype predicate of VAR is introduced as hypothesis when PREDS? is t. 

When DONT-FAIL? is set to t, strategy skips instead of failing when sequent cannot be 
discharged. 

When EQUIV? is set to nil, the strategy doesn't try to prove that the deep embedding of 
the original polynomial system is correct. The proof of this fact is trivial from a logical 
point of view, but requires unfolding of several definitions which is time consuming in 
PVS. In this case, DONT-FAIL? is assumed to be t. 

When TIMING? is set to t, strategy prints timing information of the ground evaluation of
the formally verified PVS algorithm.
"
  "Applying Tarski's Theorem to sequent formed by formulas in ~a")

(defhelper tarski_polylist__ (name expr labp labd)
  (let ((nn   (freshname "plst"))
	(estr (format nil "length[rat](~a)-1" nn)))
    (then
     (name-label name expr :hide? t)
     (eval-expr name)
     (name-label nn (! -1 r) :hide? t)
     (label labp -1)
     (eval-expr estr)
     (label labd -1)
     (replace -2 -1 :dir rl)))
  "[Tarski] Internal strategy." "")

(defstrat pre-assert (fnums)
  (let ((exprs (remove-if
		#'(lambda (x) (or (not (application? x))
				  (extra-get-number-from-expr x)))
		(extra-get-exprs `(! ,fnums (->* (">" "<" "=" ">=" "<=" "/=")) *))))
	(n (length exprs)))
    (if exprs
	(with-fresh-names
	 (names_ :list n)
	 (let ((nandes (merge-lists names_ exprs)))
	   (name-label* nandes :hide? t :tcc-step nil))
	 (assert))
      (assert)))
  "[Tarski] Internal strategy.")

(defhelper tarski_polynomial__ (skname skfn ex rews n name names &optional labj labn)
  (let ((exstp (cons 'expand* names)))
    (unless-label@
     labj
     (with-focus-on@
      ex
      (if skname
	  (let ((castr (format nil "~a = ~a" skname n)))
	    (then (spread
		   (case-replace castr)
		   ((label labj -1)
		    (label labn 1)))
		  (assert)))
	(then@
	 (copy skfn)
	 (hide skfn)
	 (inst * n)))
      (unless-label
       labn
       exstp
       (rewrite "polylist_eval" :dir rl)
       (expand name)
       (when rews
	 (rewrite* rews))
       (unless skname (reveal skfn))))))
  "[Tarski] Internal strategy." "")
   
(defhelper tarski__ (fnums fall exprs var qvars preds? equiv? labfalse timing?)
  (with-fresh-labels
   ((fnums! fnums) (labp!) (labd!) (labpred!)
    (labsk! :delete) (labj! :delete) (labn! :delete))
   (hide *)
   (let ((predvar (unless qvars preds?)))
     (then
      (when predvar
	(discriminate (typepred var) labpred!))
      (let ((predexprs (when predvar
			 (get-ands-expr
			  (mk-disjunction (mapcar #'formula (extra-get-seqfs labpred!)))
			  nil)))
	    (conjs (tarski-valid-forms-rec predexprs (list var) nil exprs))
	    (labp  (list 'quote labp!))
	    (labd  (list 'quote labd!))
	    (labj  (list 'quote labj!))
	    (labn  (list 'quote labn!))
	    (n     (1- (length conjs)))
	    (names (freshnames "pl" (1+ n)))
	    (nes   (pair-lists names conjs))
	    (polyl (extra-lambda-list
		    (mapcar #'(lambda (x) (format nil "list2array[rat](0)(~a)" x)) names)
		    "zero_pol"))
	    (degl  (extra-lambda-list
		    (mapcar #'(lambda (x) (format nil "length[rat](~a)-1" x)) names) 0))
	    (rell  (extra-lambda-list (mapcar #'cadr conjs) 0)))
	(then
	 (mapstep #'(lambda (x)`(tarski_polylist__$ ,(car x) ,(cadr x) ,labp ,labd)) nes)
	 (with-fresh-names
	  ((polyl_ polyl) (degl_ degl) (rell_ rell) (j_))
	  (lemma "tarski_def")
	  (spread
	   (inst -1 rell_ n degl_ polyl_)
	   ((spread
	     (split -1)
	     ((then (expand degl_ -1 2)
		    (replaces labd! :in -1)
		    (expand polyl_ -1 2)
		    (replaces labp! :in -1)
		    (with-fresh-labels
		     ((ex! -1) (eqs!))
		     (with-fresh-names
		      ((ps_ (! ex! 2 2) :tccs) (ds_ (! ex! 2 3)))
		      (delete *ps_-tccs*)
		      (eval-expr (! -1 2) :timing? timing?)
		      (replaces -1 -2)
		      (prop)
		      (let ((instp (> (extra-get-fnum ex!) 0))
			    (skolv (when qvars (freshnames "x" (length qvars))))
			    (instv (if qvars
				       (let ((pns (pair-lists qvars skolv)))
					 (cdr (assoc var pns :test #'string=)))
				     var))
			    (skolfn (when qvars (if fall fnums! ex!)))
			    (instfn (if fall ex! fnums!))
			    (valid  (iff instp fall))
			    (z2n    (pair-lists (fromto 0 n) names))
			    (qsknm  (when fall (list 'quote j_)))
			    (qskfn  (when qvars (list 'quote skolfn)))
			    (qex    (list 'quote ex!))
			    (qnms   (list 'quote (list "poly_system_strategy.rel5" polyl_ degl_ rell_)))
			    (eqs    (extra-evalexprs))
			    (rews   (when equiv? (list 'quote *sturm-rews*))))
			(if valid
			  (if fall ;; For all quantification
			      (then
			       (when qvars
				 (reveal fnums!) ;; Fnums are needed for the skolemization 
				 (skolem skolfn skolv)
				 (when preds?
				   (with-labels (typepred skolv) labsk!))
				 (hide fnums!)   ;; Fnums are not needed for now
				 )
			       (inst instfn instv)
			       (skolem instfn j_)
			       (extra-evalexprs$ eqs)
			       (expand* "[||]" "##" "contains?")
			       (rewrite* ("abs_lt" "abs_le" "abs_gt" "abs_ge" "lt_abs" "le_abs" "gt_abs" "ge_abs"))
			       (flatten)
			       (mapstep #'(lambda (x)`(tarski_polynomial__$
						       ,qsknm ,qskfn ,qex ,rews ,(car x) ,(cdr x) ,qnms ,labj ,labn))
					z2n)
			       (reveal fnums!)   ;; Finally, fnums are needed for this step
			       (when rews (pre-assert fnums!)))
			    (then ;; Exists quantification
			     (skolem skolfn skolv)
			     (mapstep@ #'(lambda (x)`(tarski_polynomial__$
						      ,qsknm ,qskfn ,qex ,rews ,(car x) ,(cdr x) ,qnms))
				       z2n)
			     (hide ex!)
			     (extra-evalexprs$ eqs eqs!)
			     (reveal fnums!) ;; Finally, fnums are needed for this step
			     (inst instfn instv)
			     (reveal eqs!)
			     (replaces eqs!)
			     (expand* "[||]" "##" "contains?")
			     (rewrite* ("abs_lt" "abs_le" "abs_gt" "abs_ge" "lt_abs" "le_abs" "gt_abs" "ge_abs"))
			     (flatten)
			     (when rews (pre-assert fnums!))))
			  (relabel labfalse ex!))))))
	      (then (hide-all-but (labd! labp! 1))
		    (expand* polyl_ degl_)
		    (replaces (labd! labp!))
		    (eval-formula))))
	    (then (hide-all-but (labd! 1))
		  (expand degl_)
		  (replaces -)
		  (skosimp)
		  (lift-if)
		  (assert))
	    (then (hide-all-but 1)
		  (expand rell_)
		  (skosimp)
		  (lift-if)
		  (assert))))))))))
  "[Tarski] Internal strategy." "")

(defstep hutch (&optional (fnums *) var preds? (sos? t) dont-fail? (equiv? t) timing?)
  (let ((fns    (extra-get-fnums fnums))
	(fn     (if (equal (length fns) 1) (car fns) 0))
	(expr   (when (/= fn 0)
		  (let ((e (extra-get-formula-from-fnum fn)))
		    (if preds? (lift-predicates-in-quantifier e (list *real*)) e))))
	(quant  (cond ((forall-expr? expr) 1)
		      ((exists-expr? expr) -1)
		      (t 0))) ;; forall: quant > 0, exists: quant < 0, none: 0
	(vars   (if (/= quant 0)
		    (mapcar #'(lambda (x) (format nil "~a" (id x)))
			    (bindings (extra-get-formula-from-fnum fn)))
		  (enlist-it var)))
	(fall   (>= (* fn quant) 0))
	(unqexpr  (when (/= quant 0) (expression expr)))
	(conjs  (if (/= quant 0)
		    (let ((exprs (get-ands-expr unqexpr (< quant 0))))
		      (tarski-valid-forms exprs vars (not fall)))
		  (let ((exprs (get-ands-expr
				(mk-disjunction (mapcar #'formula (extra-get-seqfs fns)))
				nil)))
		    (tarski-valid-forms exprs vars))))
	(invfms *tarski-invalid-forms*)
	(tkvar  *sturm-var*)
	(qvars  (when (/= quant 0) vars))
	(qth    (no-qualified-name "Tarski@strategies.TarskiStrategy__"))
	(dont-fail?  (or dont-fail? (not equiv?)))
	(msg    (cond (qth
		       (format nil "This strategy requires theory ~a to be imported in the current context" qth))
		      ((null tkvar)
		       (format nil "No variable found in formulas ~a." fnums))
		      ((null conjs)
		       (format nil "The following formula doesn't belong to a system of polynomial constraints on ~a
supported by this strategy:~%~{~a~%~}"
			       tkvar invfms))
		      ((and (< (* fn quant) 0) (> (length qvars) 1))
		       (format nil "Formula ~a is not simply quantified." fn)))))
    (if msg
	(printf "~a" msg)
      (with-fresh-labels@
       ((labfalse!))
       (hutch__$ fnums fall conjs tkvar qvars preds? sos? equiv? labfalse! timing?)
       (when invfms
	 (printf "The following formulas don't belong to a system of polynomials constraints on ~a
and were not considered by this strategy:~%~{~a~%~}"
		 tkvar invfms))
       (when-label
	labfalse!
	(printf "Sequent formed by formulas in ~a~:[, without considering typing information, may not~; doesn't~] hold.~%" 
		fnums preds?))
       (unless dont-fail? (fail)))))
  "[Tarski] Applies decision procedure for univariate polynomial based on a variant of
Tarski's Theorem to formulas in FNUM. Each formula denoted by FNUM is expected to
have the form B(p0 Ri q0,...,pn Rn qn), where B is an arbitrary boolean expresion on 
polynomial relations of the form pi Ri qi, with pi and qi are polynomials on variable 
VAR and Ri is a relation in {<,<=,>,>=,=,/=}. If FNUM denotes a simply quantified formula, 
that formula is expected to have one of the forms
- EXISTS (VAR:real) : B(p0 Ri q0,...,pn Rn qn)
- FORALL (VAR:real) : B(p0 Ri q0,...,pn Rn qn)
If variable VAR is not provided, it is inferred by the strategy from the formulas in FNUM. 

The subtype predicate of VAR is introduced as hypothesis when PREDS? is t. 

The option SOS?, which is set by default to t, indicates the use of a
sum-of-squares-based heuristic for dealing with small intervals. If is
set to nil, a heuristic based on the product of the polynomials is
used.

When DONT-FAIL? is set to t, strategy skips instead of failing when sequent cannot be 
discharged. 

When EQUIV? is set to nil, the strategy doesn't try to prove that the deep embedding of 
the original polynomial system is correct. The proof of this fact is trivial from a logical 
point of view, but requires unfolding of several definitions which is time consuming in 
PVS. In this case, DONT-FAIL? is assumed to be t.

When TIMING? is set to t, strategy prints timing information of the ground evaluation of
the formally verified PVS algorithm.
"
  "Applying a variant of Tarski's Theorem to sequent formed by formulas in ~a")

(defhelper hutch__ (fnums fall exprs var qvars preds? sos? equiv? labfalse timing?)
  (with-fresh-labels
   ((fnums! fnums) (labp!) (labd!) (labpred!)
    (labsk! :delete) (labj! :delete) (labn! :delete))
   (hide *) ;; All that is needed is already labeled. It's expensive to have these formulas around
   (let ((predvar (unless qvars preds?)))
     (then
      (when predvar
	(discriminate (typepred var) labpred!))
      (let ((predexprs (when predvar
			 (get-ands-expr
			  (mk-disjunction (mapcar #'formula (extra-get-seqfs labpred!)))
			  nil)))
	    (conjs (tarski-valid-forms-rec predexprs (list var) nil exprs))
	    (labp  (list 'quote labp!))
	    (labd  (list 'quote labd!))
	    (labj  (list 'quote labj!))
	    (labn  (list 'quote labn!))
	    (n     (1- (length conjs)))
	    (names (freshnames "pl" (1+ n)))
	    (nes   (pair-lists names conjs))
	    (be    (format nil "LAMBDA (bt:BoolTuple(~a)): FORALL (k:upto(~a)): bt(k)" n n))
	    (mapp  (format nil "LAMBDA (k:upto(~a)): k" n))
	    (polyl (extra-lambda-list
		    (mapcar #'(lambda (x) (format nil "list2array[rat](0)(~a)" x)) names)
		    "zero_pol"))
	    (degl  (extra-lambda-list
		    (mapcar #'(lambda (x) (format nil "length[rat](~a)-1" x)) names) 0))
	    (sos   (if sos? "TRUE" "FALSE"))
	    (rell  (extra-lambda-list (mapcar #'cadr conjs) 0)))
	(then
	 (mapstep #'(lambda (x)`(tarski_polylist__$ ,(car x) ,(cadr x) ,labp ,labd)) nes)
	 (with-fresh-names
	  ((polyl_ polyl) (degl_ degl) (rell_ rell) (j_))
	  (lemma "hutch_def")
	  (spread
	   (inst -1 sos n n be rell_ mapp polyl_ degl_)
	   ((then (expand degl_ -1 1)
		  (replaces labd! :in -1)
		  (expand polyl_ -1 1)
		  (replaces labp! :in -1)
		  (with-fresh-labels
		   ((ex! -1) (eqs!))
		   (with-fresh-names
		    ((ps_ (! ex! 1 7) :tccs) (ds_ (! ex! 1 8)))
		    (delete *ps_-tccs*)
		    (eval-expr (! -1 1) :timing? timing?)
		    (replaces -1 -2)
		    (prop)
		    (let ((instp (> (extra-get-fnum ex!) 0))
			  (skolv (when qvars (freshnames "x" (length qvars))))
			  (instv (if qvars
				     (let ((pns (pair-lists qvars skolv)))
				       (cdr (assoc var pns :test #'string=)))
				   var))
			  (skolfn (when qvars (if fall fnums! ex!)))
			  (instfn (if fall ex! fnums!))
			  (valid  (iff instp fall))
			  (z2n    (pair-lists (fromto 0 n) names))
			  (qsknm  (when fall (list 'quote j_)))
			  (qskfn  (when qvars (list 'quote skolfn)))
			  (qex    (list 'quote ex!))
			  (qnms   (list 'quote (list "poly_system_strategy.rel5" polyl_ degl_ rell_)))
			  (eqs    (extra-evalexprs))
			  (rews   (when equiv? (list 'quote *sturm-rews*))))
		      (if valid
			  (then
			   (expand "SystemSatRat?")
			   (if fall ;; For all quantification
			       (then
				(when qvars
				  (reveal fnums!) ;; Fnums are needed for the skolemization 
				  (skolem skolfn skolv)
				  (when preds?
				    (with-labels (typepred skolv) labsk!))
				  (hide fnums!)   ;; Fnums are not needed for now
				  )
				(inst instfn instv)
				(skolem instfn j_)
				(extra-evalexprs$ eqs)
				(expand* "[||]" "##" "contains?")
				(rewrite* ("abs_lt" "abs_le" "abs_gt" "abs_ge" "lt_abs" "le_abs" "gt_abs" "ge_abs"))
				(flatten)
				(mapstep #'(lambda (x)`(tarski_polynomial__$
							,qsknm ,qskfn ,qex ,rews ,(car x) ,(cdr x) ,qnms ,labj ,labn))
					 z2n)
				(reveal fnums!)   ;; Finally, fnums are needed for this step
				(when rews (pre-assert fnums!)))
			     (then ;; Exists quantification
			      (skolem skolfn skolv)
			      (mapstep@ #'(lambda (x)`(tarski_polynomial__$
						       ,qsknm ,qskfn ,qex ,rews ,(car x) ,(cdr x) ,qnms))
					z2n)
			      (hide ex!)
			      (extra-evalexprs$ eqs eqs!)
			      (reveal fnums!) ;; Finally, fnums are needed for this step
			      (inst instfn instv) 
			      (reveal eqs!)
			      (replaces eqs!)
			      (expand* "[||]" "##" "contains?")
			      (rewrite* ("abs_lt" "abs_le" "abs_gt" "abs_ge" "lt_abs" "le_abs" "gt_abs" "ge_abs"))
			      (flatten)
			      (when rews (pre-assert fnums!)))))
			(relabel labfalse ex!))))))
	    (spread (split 1)
		    ((then (hide-all-but (labd! 1))
			   (expand degl_)
			   (replaces -)
			   (skosimp)
			   (lift-if)
			   (assert))
		     (then (hide-all-but (labd! labp! 1))
			   (expand* polyl_ degl_)
			   (replaces (labd! labp!))
			   (eval-formula))))
	    (then (hide-all-but 1)
		  (expand rell_)
		  (skosimp)
		  (lift-if)
		  (assert))))))))))
  "[Tarski] Internal strategy." "")
