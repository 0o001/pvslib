(hutch_examples
 (example_fall_TCC1 0
  (example_fall_TCC1-1 nil 3703874797 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_fall_TCC2 0
  (example_fall_TCC2-1 nil 3703874797 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   nil))
 (example_fall 0
  (example_fall-1 nil 3703874526 ("" (hutch) nil nil)
   ((id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (zero_pol const-decl "rat" polylist "Sturm/")
    (list2array def-decl "T" array2list "structures/")
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (rell__243 skolem-const-decl "[nat -> naturalnumber]"
     hutch_examples nil)
    (degl__242 skolem-const-decl "[nat -> int]" hutch_examples nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (polyl__241 skolem-const-decl "[nat -> [nat -> rat]]"
     hutch_examples nil)
    (> const-decl "bool" reals nil)
    (subrange type-eq-decl nil integers nil)
    (BoolExpr type-eq-decl nil hutch "Tarski/")
    (BoolTuple type-eq-decl nil hutch "Tarski/")
    (rel5 const-decl "bool" poly_system_strategy "Tarski/")
    (pl_235 skolem-const-decl "{pl: Polylist |
         length(pl) = 3 AND (FORALL (x: real): polylist(pl)(x) = 1 * x ^ 2)}"
     hutch_examples nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_eval formula-decl nil polylist "Sturm/")
    (pl_236 skolem-const-decl "Polylist" hutch_examples nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (expt_x1 formula-decl nil exponentiation nil)
    (polylist_prod formula-decl nil polylist "Sturm/")
    (pl_237 skolem-const-decl "{pl: Polylist |
         length(pl) = 4 AND (FORALL (x: real): polylist(pl)(x) = 1 * x ^ 3)}"
     hutch_examples nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (SystemSatRat? const-decl "bool" hutch "Tarski/")
    (FALSE const-decl "bool" booleans nil)
    (hutch const-decl "bool" hutch "Tarski/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (hutch_def formula-decl nil hutch "Tarski/")
    (pprod const-decl "Polylist" polylist "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (example_ex_TCC1 0
  (example_ex_TCC1-1 nil 3703874797 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil))
   nil))
 (example_ex 0
  (example_ex-1 nil 3703874526 ("" (hutch) nil nil)
   ((id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (zero_pol const-decl "rat" polylist "Sturm/")
    (list2array def-decl "T" array2list "structures/")
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (even_int nonempty-type-eq-decl nil integers nil)
    (even? const-decl "bool" integers nil)
    (<= const-decl "bool" reals nil)
    (rell__263 skolem-const-decl "[nat -> even_int]" hutch_examples
     nil)
    (degl__262 skolem-const-decl "[nat -> int]" hutch_examples nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (polyl__261 skolem-const-decl "[nat -> [nat -> rat]]"
     hutch_examples nil)
    (> const-decl "bool" reals nil)
    (subrange type-eq-decl nil integers nil)
    (BoolExpr type-eq-decl nil hutch "Tarski/")
    (BoolTuple type-eq-decl nil hutch "Tarski/")
    (polylist_eval formula-decl nil polylist "Sturm/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (pl_258 skolem-const-decl "Polylist" hutch_examples nil)
    (pl_257 skolem-const-decl "Polylist" hutch_examples nil)
    (rel5 const-decl "bool" poly_system_strategy "Tarski/")
    (SystemSatRat? const-decl "bool" hutch "Tarski/")
    (hutch const-decl "bool" hutch "Tarski/")
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (hutch_def formula-decl nil hutch "Tarski/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (example_1_TCC1 0
  (example_1_TCC1-1 nil 3703874525 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_1_TCC2 0
  (example_1_TCC2-1 nil 3703874525 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil))
   nil))
 (example_1_TCC3 0
  (example_1_TCC3-1 nil 3703874525 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil))
   nil))
 (example_1_TCC4 0
  (example_1_TCC4-1 nil 3703874525 ("" (subtype-tcc) nil nil)
   ((minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil))
   nil))
 (example_1_TCC5 0
  (example_1_TCC5-1 nil 3703874797 ("" (subtype-tcc) nil nil)
   ((minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil))
   nil))
 (example_1 0
  (example_1-1 nil 3703874526 ("" (hutch) nil nil)
   ((id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (zero_pol const-decl "rat" polylist "Sturm/")
    (list2array def-decl "T" array2list "structures/")
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (rell__280 skolem-const-decl "[nat -> naturalnumber]"
     hutch_examples nil)
    (degl__279 skolem-const-decl "[nat -> int]" hutch_examples nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (polyl__278 skolem-const-decl "[nat -> [nat -> rat]]"
     hutch_examples nil)
    (> const-decl "bool" reals nil)
    (subrange type-eq-decl nil integers nil)
    (BoolExpr type-eq-decl nil hutch "Tarski/")
    (BoolTuple type-eq-decl nil hutch "Tarski/")
    (pl_272 skolem-const-decl "Polylist" hutch_examples nil)
    (pl_271 skolem-const-decl "Polylist" hutch_examples nil)
    (pl_270 skolem-const-decl "Polylist" hutch_examples nil)
    (polylist_sum formula-decl nil polylist "Sturm/")
    (pl_269 skolem-const-decl "{pql: Polylist |
         FORALL (x):
           polylist(pql)(x) =
            polylist(pconst(1))(x) +
             polylist(pneg(ppow(pminus(pmonom(1, 1), pconst(3)), 2)))(x)}"
     hutch_examples nil)
    (polylist_eval formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_prod formula-decl nil polylist "Sturm/")
    (polylist_pow formula-decl nil polylist "Sturm/")
    (polylist_neg formula-decl nil polylist "Sturm/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pl_268 skolem-const-decl "Polylist" hutch_examples nil)
    (rel5 const-decl "bool" poly_system_strategy "Tarski/")
    (minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (SystemSatRat? const-decl "bool" hutch "Tarski/")
    (FALSE const-decl "bool" booleans nil)
    (hutch const-decl "bool" hutch "Tarski/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (hutch_def formula-decl nil hutch "Tarski/")
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pprod const-decl "Polylist" polylist "Sturm/")
    (pneg const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (ppow def-decl "Polylist" polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (example_2_TCC1 0
  (example_2_TCC1-1 nil 3703874525 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_2_TCC2 0
  (example_2_TCC2-1 nil 3703874525 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil))
   nil))
 (example_2 0
  (example_2-1 nil 3703874526 ("" (hutch) nil nil)
   ((minus_odd_is_odd application-judgement "odd_int" integers nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (zero_pol const-decl "rat" polylist "Sturm/")
    (list2array def-decl "T" array2list "structures/")
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (rell__317 skolem-const-decl "[nat -> naturalnumber]"
     hutch_examples nil)
    (degl__316 skolem-const-decl "[nat -> int]" hutch_examples nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (polyl__315 skolem-const-decl "[nat -> [nat -> rat]]"
     hutch_examples nil)
    (> const-decl "bool" reals nil)
    (subrange type-eq-decl nil integers nil)
    (BoolExpr type-eq-decl nil hutch "Tarski/")
    (BoolTuple type-eq-decl nil hutch "Tarski/")
    (rel5 const-decl "bool" poly_system_strategy "Tarski/")
    (pl_307 skolem-const-decl "{pl: Polylist |
         length(pl) = 13 AND
          (FORALL (x: real): polylist(pl)(x) = 1 * x ^ 12)}"
     hutch_examples nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_eval formula-decl nil polylist "Sturm/")
    (pl_308 skolem-const-decl "{pl: Polylist |
         length(pl) = 5 AND (FORALL (x: real): polylist(pl)(x) = 1 * x ^ 4)}"
     hutch_examples nil)
    (pl_309 skolem-const-decl "Polylist" hutch_examples nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (pl_310 skolem-const-decl "Polylist" hutch_examples nil)
    (SystemSatRat? const-decl "bool" hutch "Tarski/")
    (FALSE const-decl "bool" booleans nil)
    (hutch const-decl "bool" hutch "Tarski/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (hutch_def formula-decl nil hutch "Tarski/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (example_3 0
  (example_3-1 nil 3703874526 ("" (hutch) nil nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (zero_pol const-decl "rat" polylist "Sturm/")
    (list2array def-decl "T" array2list "structures/")
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (rell__342 skolem-const-decl "[nat -> naturalnumber]"
     hutch_examples nil)
    (degl__341 skolem-const-decl "[nat -> int]" hutch_examples nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (polyl__340 skolem-const-decl "[nat -> [nat -> rat]]"
     hutch_examples nil)
    (> const-decl "bool" reals nil)
    (subrange type-eq-decl nil integers nil)
    (BoolExpr type-eq-decl nil hutch "Tarski/")
    (BoolTuple type-eq-decl nil hutch "Tarski/")
    (polylist_eval formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_prod formula-decl nil polylist "Sturm/")
    (polylist_pow formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (minus_real_is_real application-judgement "real" reals nil)
    (polylist_neg formula-decl nil polylist "Sturm/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (polylist_sum formula-decl nil polylist "Sturm/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (pl_334 skolem-const-decl "Polylist" hutch_examples nil)
    (pl_333 skolem-const-decl "Polylist" hutch_examples nil)
    (pl_332 skolem-const-decl "Polylist" hutch_examples nil)
    (pl_331 skolem-const-decl "{pql: Polylist |
         FORALL (x):
           polylist(pql)(x) =
            polylist(pconst(1))(x) +
             polylist(pneg(ppow(pminus(pmonom(1, 1), pconst(3)), 2)))(x)}"
     hutch_examples nil)
    (pl_330 skolem-const-decl "Polylist" hutch_examples nil)
    (rel5 const-decl "bool" poly_system_strategy "Tarski/")
    (SystemSatRat? const-decl "bool" hutch "Tarski/")
    (hutch const-decl "bool" hutch "Tarski/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (hutch_def formula-decl nil hutch "Tarski/")
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (pprod const-decl "Polylist" polylist "Sturm/")
    (pneg const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (ppow def-decl "Polylist" polylist "Sturm/")
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (example_4_TCC1 0
  (example_4_TCC1-1 nil 3703874525 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_4_TCC2 0
  (example_4_TCC2-1 nil 3703874525 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (example_4_TCC3 0
  (example_4_TCC3-1 nil 3703874525 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (example_4_TCC4 0
  (example_4_TCC4-1 nil 3703874525 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (example_4_TCC5 0
  (example_4_TCC5-1 nil 3703874525 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (example_4_TCC6 0
  (example_4_TCC6-1 nil 3703874525 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (example_4_TCC7 0
  (example_4_TCC7-1 nil 3703874525 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (example_4_TCC8 0
  (example_4_TCC8-1 nil 3703874525 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (example_4_TCC9 0
  (example_4_TCC9-1 nil 3703874525 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (example_4_TCC10 0
  (example_4_TCC10-1 nil 3703874525 ("" (subtype-tcc) nil nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil))
   nil))
 (example_4_TCC11 0
  (example_4_TCC11-1 nil 3703874797 ("" (subtype-tcc) nil nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil))
   nil))
 (example_4 0
  (example_4-1 nil 3703874526 ("" (hutch) nil nil)
   ((id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (zero_pol const-decl "rat" polylist "Sturm/")
    (list2array def-decl "T" array2list "structures/")
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (rell__357 skolem-const-decl "[nat -> naturalnumber]"
     hutch_examples nil)
    (degl__356 skolem-const-decl "[nat -> int]" hutch_examples nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (polyl__355 skolem-const-decl "[nat -> [nat -> rat]]"
     hutch_examples nil)
    (> const-decl "bool" reals nil)
    (subrange type-eq-decl nil integers nil)
    (BoolExpr type-eq-decl nil hutch "Tarski/")
    (BoolTuple type-eq-decl nil hutch "Tarski/")
    (polylist_eval formula-decl nil polylist "Sturm/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (polylist_sum formula-decl nil polylist "Sturm/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (pl_350 skolem-const-decl "Polylist" hutch_examples nil)
    (pl_349 skolem-const-decl "Polylist" hutch_examples nil)
    (pl_348 skolem-const-decl "Polylist" hutch_examples nil)
    (pl_347 skolem-const-decl "{pql: Polylist |
         FORALL (x):
           polylist(pql)(x) =
            polylist(pconst(1948))(x) +
             polylist(pminus(pminus(pmonom(1, 22), pmonom(26/63, 20)),
                             pmonom(419, 10)))
                     (x)}" hutch_examples nil)
    (rel5 const-decl "bool" poly_system_strategy "Tarski/")
    (SystemSatRat? const-decl "bool" hutch "Tarski/")
    (hutch const-decl "bool" hutch "Tarski/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (hutch_def formula-decl nil hutch "Tarski/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (polylist const-decl "real" polylist "Sturm/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (pconst const-decl "Polylist" polylist "Sturm/")
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (example_5_TCC1 0
  (example_5_TCC1-1 nil 3703874797 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (example_5 0
  (example_5-1 nil 3703874526 ("" (hutch) nil nil)
   ((id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (zero_pol const-decl "rat" polylist "Sturm/")
    (list2array def-decl "T" array2list "structures/")
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (rell__370 skolem-const-decl "[nat -> naturalnumber]"
     hutch_examples nil)
    (degl__369 skolem-const-decl "[nat -> int]" hutch_examples nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (polyl__368 skolem-const-decl "[nat -> [nat -> rat]]"
     hutch_examples nil)
    (> const-decl "bool" reals nil)
    (subrange type-eq-decl nil integers nil)
    (BoolExpr type-eq-decl nil hutch "Tarski/")
    (BoolTuple type-eq-decl nil hutch "Tarski/")
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (abs_ge formula-decl nil abs_lems "reals/")
    (pl_364 skolem-const-decl "Polylist" hutch_examples nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pl_363 skolem-const-decl "Polylist" hutch_examples nil)
    (polylist_eval formula-decl nil polylist "Sturm/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (polylist_sum formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pl_362 skolem-const-decl "{pql: Polylist |
         FORALL (x):
           polylist(pql)(x) =
            polylist(pconst(1))(x) + polylist(pmonom(1, 1))(x)}"
     hutch_examples nil)
    (rel5 const-decl "bool" poly_system_strategy "Tarski/")
    (SystemSatRat? const-decl "bool" hutch "Tarski/")
    (FALSE const-decl "bool" booleans nil)
    (hutch const-decl "bool" hutch "Tarski/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (hutch_def formula-decl nil hutch "Tarski/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (listn_0 name-judgement "listn[rat](0)" polylist "Sturm/")
    (listn_0 name-judgement "listn[real](0)" polynomial_division
     "Sturm/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (polylist const-decl "real" polylist "Sturm/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (psum def-decl "{pql: Polylist |
         FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
     polylist "Sturm/")
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (pmonom def-decl "{pl: Polylist |
         length(pl) = deg + 1 AND
          (FORALL (x: real): polylist(pl)(x) = c * x ^ deg)}" polylist
     "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (TRUE const-decl "bool" booleans nil))
   shostak)))

