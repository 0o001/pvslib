(monotone_sequences
 (reflexive_closure_ascending 0
  (reflexive_closure_ascending-1 nil 3314543892
   ("" (skolem-typepred)
    (("" (expand* "ascending?" "reflexive_closure" "union" "member")
      (("" (skosimp) (("" (inst?) nil nil)) nil)) nil))
    nil)
   ((reflexive_closure const-decl "(reflexive?)" closure_ops nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (ascending? const-decl "bool" monotone_sequences nil)
    (sequence type-eq-decl nil sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-type-decl nil monotone_sequences nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (reflexive_closure_descending 0
  (reflexive_closure_descending-1 nil 3314543932
   ("" (skolem-typepred)
    (("" (expand* "descending?" "reflexive_closure" "union" "member")
      (("" (skosimp) (("" (inst?) nil nil)) nil)) nil))
    nil)
   ((reflexive_closure const-decl "(reflexive?)" closure_ops nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (descending? const-decl "bool" monotone_sequences nil)
    (sequence type-eq-decl nil sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-type-decl nil monotone_sequences nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (ascending_lem 0
  (ascending_lem-1 nil 3314543958
   ("" (skolem-typepred)
    (("" (expand* "preserves" "restrict")
      (("" (induct "x2")
        (("1" (skosimp) (("1" (assert) nil nil)) nil)
         ("2" (skosimp*)
          (("2" (case-replace "x1!1 = j!1")
            (("1" (hide -2)
              (("1" (expand "ascending?")
                (("1" (inst?) (("1" (assert) nil nil)) nil)) nil))
              nil)
             ("2" (inst?)
              (("2" (assert)
                (("2" (expand "transitive?")
                  (("2"
                    (inst - "seq!1(x1!1)" "seq!1(j!1)"
                     "seq!1(1 + j!1)")
                    (("2" (assert)
                      (("2" (hide 2 -1)
                        (("2" (expand "ascending?")
                          (("2" (inst?) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (ascending? const-decl "bool" monotone_sequences nil)
    (sequence type-eq-decl nil sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pred type-eq-decl nil defined_types nil)
    (transitive? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (T formal-type-decl nil monotone_sequences nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (descending_lem 0
  (descending_lem-1 nil 3314544287
   ("" (skolem-typepred)
    (("" (rewrite "ascending_lem")
      (("" (expand* "ascending?" "converse" "descending?") nil nil))
      nil))
    nil)
   ((transitive_converse application-judgement "(transitive?[T])"
     relation_converse_props nil)
    (ascending_lem formula-decl nil monotone_sequences nil)
    (converse const-decl "pred[[T2, T1]]" relation_defs nil)
    (ascending? const-decl "bool" monotone_sequences nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (descending? const-decl "bool" monotone_sequences nil)
    (sequence type-eq-decl nil sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pred type-eq-decl nil defined_types nil)
    (transitive? const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (T formal-type-decl nil monotone_sequences nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (ascending_suffix 0
  (ascending_suffix-1 nil 3820697627
   ("" (skeep*)
    (("" (typepred "seq")
      (("" (expand "ascending?")
        (("" (skolem 1 "m")
          (("" (expand "suffix")
            (("" (inst -1 "m+n") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((ascending? const-decl "bool" monotone_sequences nil)
    (sequence type-eq-decl nil sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-type-decl nil monotone_sequences nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (suffix const-decl "sequence" sequences nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (ascending_subsequence 0
  (ascending_subsequence-1 nil 3314544355
   ("" (skolem-typepred)
    (("" (lemma "preserves_composition[nat, nat, T]")
      (("" (inst?)
        (("" (invoke (inst - "%1" "%1" "lt!1") (! -2 0 1))
          (("" (expand "preserves" -2)
            (("" (assert)
              (("" (hide -2)
                (("" (split)
                  (("1" (hide -3)
                    (("1" (expand* "ascending?" "preserves" "restrict")
                      (("1" (skolem!)
                        (("1" (inst?) (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (rewrite "ascending_lem") nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((preserves_composition formula-decl nil function_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (preserves const-decl "bool" functions nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ascending_lem formula-decl nil monotone_sequences nil)
    (ascending? const-decl "bool" monotone_sequences nil)
    (sequence type-eq-decl nil sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (transitive? const-decl "bool" relations nil)
    (T formal-type-decl nil monotone_sequences nil)
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (descending_subsequence 0
  (descending_subsequence-1 nil 3314544571
   ("" (skolem-typepred)
    (("" (use "ascending_subsequence" ("lt" "converse(lt!1)"))
      (("1" (expand* "ascending?" "converse" "descending?") nil nil)
       ("2" (expand* "ascending?" "converse" "descending?") nil nil))
      nil))
    nil)
   ((converse const-decl "pred[[T2, T1]]" relation_defs nil)
    (ascending_subsequence formula-decl nil monotone_sequences nil)
    (transitive_converse application-judgement "(transitive?[T])"
     relation_converse_props nil)
    (seq!1 skolem-const-decl "(descending?(lt!1))" monotone_sequences
     nil)
    (lt!1 skolem-const-decl "(transitive?[T])" monotone_sequences nil)
    (ascending? const-decl "bool" monotone_sequences nil)
    (descending? const-decl "bool" monotone_sequences nil)
    (sequence type-eq-decl nil sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (transitive? const-decl "bool" relations nil)
    (T formal-type-decl nil monotone_sequences nil)
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (ascending_n?_TCC1 0
  (ascending_n?_TCC1-1 nil 3820753926 ("" (subtype-tcc) nil nil) nil
   nil
   (ascending_n? subtype "monotone_sequences.i"
    "naturalnumbers.upto(monotone_sequences.n)")))
 (ascending_n?_TCC2 0
  (ascending_n?_TCC2-1 nil 3820753926 ("" (subtype-tcc) nil nil) nil
   nil
   (ascending_n? subtype "(number_fields.+)(monotone_sequences.i, 1)"
    "naturalnumbers.upto(monotone_sequences.n)")))
 (ascending_iterate_n_TCC1 0
  (ascending_iterate_n_TCC1-1 nil 3820753926 ("" (subtype-tcc) nil nil)
   nil nil
   (ascending_iterate_n subtype "monotone_sequences.j"
    "naturalnumbers.upto(monotone_sequences.n)")))
 (ascending_iterate_n_TCC2 0
  (ascending_iterate_n_TCC2-1 nil 3820753926 ("" (subtype-tcc) nil nil)
   nil nil
   (ascending_iterate_n subtype
    "(number_fields.-)(monotone_sequences.j, monotone_sequences.i)"
    "nat")))
 (ascending_iterate_n 0
  (ascending_iterate_n-1 nil 3820753942
   (""
    (case "FORALL (m,n: nat, rel: pred[[T, T]], fseq: (ascending_n?(n)(rel))) (i: below(n), j: subrange(i, n)): j-i=m IMPLIES iterate_n(j - i)(rel)(fseq(i), fseq(j))")
    (("1" (skeep)
      (("1" (skeep)
        (("1" (inst -1 "j-i" "n" "rel" "fseq" "i" "j") nil nil)) nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "m")
        (("1" (skeep* :preds? t)
          (("1" (case-replace "j=i")
            (("1" (grind) nil nil) ("2" (assert) nil nil)) nil))
          nil)
         ("2" (skeep*)
          (("2" (expand "iterate_n" 1)
            (("2" (expand "iterate" 1)
              (("2" (assert)
                (("2" (expand "o" 1)
                  (("2" (case "i=0")
                    (("1" (case "j=0")
                      (("1" (assert) nil nil)
                       ("2" (inst -2 "n" "rel" "fseq" "i" "j-1")
                        (("2" (assert)
                          (("2" (expand "iterate_n" -2)
                            (("2" (inst 2 "fseq(j-1)")
                              (("2"
                                (assert)
                                (("2"
                                  (typepred "fseq")
                                  (("2"
                                    (expand "ascending_n?" -1)
                                    (("2"
                                      (inst -1 "j-1")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (case "j=i")
                      (("1" (assert) nil nil)
                       ("2" (inst -1 "n" "rel" "fseq" "i" "j-1")
                        (("2" (assert)
                          (("2" (expand "iterate_n" -1)
                            (("2" (inst 3 "fseq(j-1)")
                              (("2"
                                (assert)
                                (("2"
                                  (typepred "fseq")
                                  (("2"
                                    (expand "ascending_n?" -1)
                                    (("2"
                                      (inst -1 "j-1")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((O const-decl "bool" relation_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (TRUE const-decl "bool" booleans nil)
    (iterate def-decl "pred[[T, T]]" relation_iterate nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil monotone_sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ascending_n? const-decl "bool" monotone_sequences nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subrange type-eq-decl nil integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (PRED type-eq-decl nil defined_types nil)
    (iterate_n const-decl "PRED[[T, T]]" relation_iterate nil))
   shostak))
 (iterate_n_fseq_TCC1 0
  (iterate_n_fseq_TCC1-1 nil 3820958931 ("" (subtype-tcc) nil nil) nil
   nil
   (iterate_n_fseq subtype "0"
    "naturalnumbers.upto(monotone_sequences.n)")))
 (iterate_n_fseq_TCC2 0
  (iterate_n_fseq_TCC2-1 nil 3820958931 ("" (subtype-tcc) nil nil) nil
   nil
   (iterate_n_fseq subtype "monotone_sequences.n"
    "naturalnumbers.upto(monotone_sequences.n)")))
 (iterate_n_fseq 0
  (iterate_n_fseq-1 nil 3820959601
   (""
    (case "FORALL (x, y: T, rel, n):         iterate_n(n)(rel)(x, y) IMPLIES EXISTS (fseq: (ascending_n?(n)(rel))): fseq(0) = x AND fseq(n) = y")
    (("1" (skeep)
      (("1" (insteep)
        (("1" (split 1)
          (("1" (propax) nil nil)
           ("2" (hide -1)
            (("2" (flatten)
              (("2" (skeep)
                (("2" (lemma "ascending_iterate_n")
                  (("2" (inst?)
                    (("1" (inst -1 "n") (("1" (assert) nil nil)) nil)
                     ("2" (case-replace "n=0")
                      (("1" (hide (-1 1)) (("1" (grind) nil nil)) nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "n")
        (("1" (skeep*)
          (("1" (expand "iterate_n")
            (("1" (expand "iterate" -1)
              (("1" (inst 1 "LAMBDA(i:upto(0)): x")
                (("1" (expand "ascending_n?" 1) (("1" (skeep) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep*)
          (("2" (expand "iterate_n" -2)
            (("2" (expand "iterate" -2)
              (("2" (expand "iterate_n" -1)
                (("2" (expand "o" -2)
                  (("2" (skeep -2)
                    (("2" (inst -1 "x" "y_1" "rel")
                      (("2" (assert)
                        (("2" (skeep)
                          (("2"
                            (inst 1
                             "LAMBDA(i:upto(j+1)): IF i=1+j THEN y ELSE fseq(i) ENDIF")
                            (("1" (assert) nil nil)
                             ("2" (expand "ascending_n?" 1)
                              (("2"
                                (skeep)
                                (("2"
                                  (assert)
                                  (("2"
                                    (case "i_1=j")
                                    (("1" (assert) nil nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (typepred "fseq")
                                        (("2"
                                          (expand "ascending_n?" -1)
                                          (("2"
                                            (inst -1 "i_1")
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (skeep) (("3" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((O const-decl "bool" relation_props nil)
    (fseq skolem-const-decl "(ascending_n?(j)(rel))" monotone_sequences
     nil)
    (y skolem-const-decl "T" monotone_sequences nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (rel skolem-const-decl "pred[[T, T]]" monotone_sequences nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (j skolem-const-decl "nat" monotone_sequences nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (TRUE const-decl "bool" booleans nil)
    (x skolem-const-decl "T" monotone_sequences nil)
    (rel skolem-const-decl "pred[[T, T]]" monotone_sequences nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (ascending_iterate_n formula-decl nil monotone_sequences nil)
    (iterate def-decl "pred[[T, T]]" relation_iterate nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (subrange type-eq-decl nil integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (n skolem-const-decl "nat" monotone_sequences nil)
    (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (T formal-type-decl nil monotone_sequences nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (iterate_n const-decl "PRED[[T, T]]" relation_iterate nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ascending_n? const-decl "bool" monotone_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   nil)))

