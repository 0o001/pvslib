(monotone_sequences
 (reflexive_closure_ascending 0
  (reflexive_closure_ascending-1 nil 3314543892
   ("" (skolem-typepred)
    (("" (expand* "ascending?" "reflexive_closure" "union" "member")
      (("" (skosimp) (("" (inst?) nil nil)) nil)) nil))
    nil)
   ((reflexive_closure const-decl "(reflexive?)" closure_ops nil))
   shostak))
 (reflexive_closure_descending 0
  (reflexive_closure_descending-1 nil 3314543932
   ("" (skolem-typepred)
    (("" (expand* "descending?" "reflexive_closure" "union" "member")
      (("" (skosimp) (("" (inst?) nil nil)) nil)) nil))
    nil)
   ((reflexive_closure const-decl "(reflexive?)" closure_ops nil))
   shostak))
 (ascending_lem 0
  (ascending_lem-1 nil 3314543958
   ("" (skolem-typepred)
    (("" (expand* "preserves" "restrict")
      (("" (induct "x2")
        (("1" (skosimp) (("1" (assert) nil nil)) nil)
         ("2" (skosimp*)
          (("2" (case-replace "x1!1 = j!1")
            (("1" (hide -2)
              (("1" (expand "ascending?")
                (("1" (inst?) (("1" (assert) nil nil)) nil)) nil))
              nil)
             ("2" (inst?)
              (("2" (assert)
                (("2" (expand "transitive?")
                  (("2"
                    (inst - "seq!1(x1!1)" "seq!1(j!1)"
                     "seq!1(1 + j!1)")
                    (("2" (assert)
                      (("2" (hide 2 -1)
                        (("2" (expand "ascending?")
                          (("2" (inst?) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((transitive? const-decl "bool" relations nil)) shostak))
 (descending_lem 0
  (descending_lem-1 nil 3314544287
   ("" (skolem-typepred)
    (("" (rewrite "ascending_lem")
      (("" (expand* "ascending?" "converse" "descending?") nil nil))
      nil))
    nil)
   ((transitive? const-decl "bool" relations nil)) shostak))
 (ascending_converse_descending 0
  (ascending_converse_descending-1 nil 3822132986
   ("" (skeep)
    (("" (decompose-equality)
      (("" (iff)
        (("" (split)
          (("1" (flatten)
            (("1" (expand "ascending?")
              (("1" (expand "descending?")
                (("1" (skeep)
                  (("1" (insteep)
                    (("1" (expand "converse") (("1" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (expand "descending?")
              (("2" (expand "ascending?")
                (("2" (skeep)
                  (("2" (insteep)
                    (("2" (expand "converse") (("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (descending_converse_ascending 0
  (descending_converse_ascending-1 nil 3822133118
   ("" (skeep)
    (("" (lemma "ascending_converse_descending")
      (("" (inst -1 "converse(rel)")
        (("" (case-replace "converse(converse(rel))=rel")
          (("1" (assert) nil nil)
           ("2" (hide-all-but 1)
            (("2" (decompose-equality) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (ascending_suffix 0
  (ascending_suffix-1 nil 3820697627
   ("" (skeep*)
    (("" (typepred "seq")
      (("" (expand "ascending?")
        (("" (skolem 1 "m")
          (("" (expand "suffix")
            (("" (inst -1 "m+n") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (strict_from_rec_TCC1 0
  (strict_from_rec_TCC1-1 nil 3822134573 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil monotone_sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sequence type-eq-decl nil sequences nil)
    (ascending_non_strict? const-decl "bool" monotone_sequences nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (strict_from_rec subtype
    "(number_fields.-)(monotone_sequences.k, 1)" "nat")))
 (strict_from_rec_TCC2 0
  (strict_from_rec_TCC2-1 nil 3822134573 ("" (subtype-tcc) nil nil) nil
   nil
   (strict_from_rec subtype "(0, monotone_sequences.seq(0))"
    "{(k, x) | booleans.AND(monotone_sequences.x = monotone_sequences.seq(monotone_sequences.k), (booleans.IMPLIES(reals.>(monotone_sequences.k, 0), monotone_sequences.rel(monotone_sequences.seq((number_fields.-)(monotone_sequences.k, 1)), monotone_sequences.seq(monotone_sequences.k)))))}")))
 (strict_from_rec_TCC3 0
  (strict_from_rec_TCC3-1 nil 3822134573 ("" (subtype-tcc) nil nil) nil
   nil
   (strict_from_rec subtype
    "(number_fields.-)(monotone_sequences.j, 1)" "nat")))
 (strict_from_rec_TCC4 0
  (strict_from_rec_TCC4-1 nil 3822134573
   ("" (skeep*)
    (("" (expand "nonempty?")
      (("" (expand "empty?")
        (("" (expand "member")
          (("" (typepred "seq")
            (("" (expand "ascending_non_strict?")
              (("" (flatten)
                (("" (inst -2 "nk")
                  (("" (skeep -2 :preds? t)
                    (("" (inst -6 "k+1") (("" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonempty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil monotone_sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sequence type-eq-decl nil sequences nil)
    (ascending_non_strict? const-decl "bool" monotone_sequences nil)
    (empty? const-decl "bool" sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (strict_from_rec subtype
    "{j: integers.above(monotone_sequences.nk) | monotone_sequences.rel(monotone_sequences.seq((number_fields.-)(j, 1)), monotone_sequences.seq(j))}"
    "(sets[integers.above(monotone_sequences.nk)].nonempty?)")))
 (strict_from_rec_TCC5 0
  (strict_from_rec_TCC5-1 nil 3822134573
   ("" (skeep*) (("" (typepred "minj") (("" (propax) nil nil)) nil))
    nil)
   ((<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ascending_non_strict? const-decl "bool" monotone_sequences nil)
    (sequence type-eq-decl nil sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-type-decl nil monotone_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (above nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (strict_from_rec subtype
    "(monotone_sequences.minj, monotone_sequences.seq(monotone_sequences.minj))"
    "{(k, x) | booleans.AND(monotone_sequences.x = monotone_sequences.seq(monotone_sequences.k), (booleans.IMPLIES(reals.>(monotone_sequences.k, 0), monotone_sequences.rel(monotone_sequences.seq((number_fields.-)(monotone_sequences.k, 1)), monotone_sequences.seq(monotone_sequences.k)))))}")))
 (strict_from_rec_TCC6 0
  (strict_from_rec_TCC6-1 nil 3822134573 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil monotone_sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sequence type-eq-decl nil sequences nil)
    (ascending_non_strict? const-decl "bool" monotone_sequences nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (strict_from_rec subtype
    "(number_fields.-)(monotone_sequences.n, 1)" "nat")))
 (strict_from_rec_TCC7 0
  (strict_from_rec_TCC7-1 nil 3822134573 ("" (termination-tcc) nil nil)
   nil nil
   (strict_from_rec termination
    "monotone_sequences.strict_from_rec(monotone_sequences.rel)(monotone_sequences.seq)((number_fields.-)(monotone_sequences.n, 1))"
    "nil")))
 (strict_from_prop_TCC1 0
  (strict_from_prop_TCC1-1 nil 3822138266 ("" (subtype-tcc) nil nil)
   nil nil (strict_from_prop subtype "monotone_sequences.i" "nat")))
 (strict_from_prop 0
  (strict_from_prop-1 nil 3822138329
   ("" (skeep*)
    (("" (skoletin* 1)
      (("" (typepred "strict_from_rec(rel)(seq)(n + 1)")
        (("" (name "sn" "strict_from_rec(rel)(seq)(n + 1)")
          (("" (replace -1)
            (("" (typepred "strict_from_rec(rel)(seq)(n)")
              (("" (expand "strict_from_rec" -3)
                ((""
                  (with-tccs
                   (typepred
                    "min({j: above(strict_from_rec(rel)(seq)(n)`1) |
                               rel(seq(j - 1), seq(j))})"))
                  ((""
                    (with-tccs
                     (name-replace "mm"
                      "min({j: above(strict_from_rec(rel)(seq)(n)`1) |
                               rel(seq(j - 1), seq(j))})"))
                    (("" (expand "sn")
                      (("" (replaces -6 :dir rl)
                        (("" (assert)
                          (("" (hide (-6 -7))
                            (("" (replaces -7 :dir rl)
                              ((""
                                (replace -8 :dir rl :actuals? t)
                                ((""
                                  (replaces -7 :dir rl)
                                  ((""
                                    (hide -7)
                                    ((""
                                      (case
                                       "FORALL(i:below(k2-k1)):seq(i+k1)=seq(k1)")
                                      (("1"
                                        (split 1)
                                        (("1"
                                          (inst -1 "k2-k1-1")
                                          (("1" (assert) nil nil))
                                          nil)
                                         ("2"
                                          (skeep)
                                          (("2"
                                            (inst -1 "i-k1")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide 2)
                                        (("2"
                                          (induct "i")
                                          (("1" (assert) nil nil)
                                           ("2"
                                            (skeep)
                                            (("2"
                                              (typepred "seq")
                                              (("2"
                                                (expand
                                                 "ascending_non_strict?")
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (inst -1 "jb+k1")
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (inst
                                                         -7
                                                         "1+jb+k1")
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (below_induction formula-decl nil bounded_nat_inductions nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sn skolem-const-decl
     "{(k, x) | x = seq(k) AND (k > 0 IMPLIES rel(seq(k - 1), seq(k)))}"
     monotone_sequences nil)
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
         min_nat nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (above nonempty-type-eq-decl nil integers nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (subrange type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (strict_from_rec def-decl
     "{(k, x) | x = seq(k) AND (k > 0 IMPLIES rel(seq(k - 1), seq(k)))}"
     monotone_sequences nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (> const-decl "bool" reals nil)
    (ascending_non_strict? const-decl "bool" monotone_sequences nil)
    (sequence type-eq-decl nil sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil monotone_sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (strict_from_TCC1 0
  (strict_from_TCC1-1 nil 3822136005
   ("" (skeep)
    (("" (expand "ascending?")
      (("" (skeep)
        (("" (lemma "strict_from_prop")
          (("" (inst?)
            (("" (skoletin*)
              (("" (flatten) (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ascending? const-decl "bool" monotone_sequences nil)
    (strict_from_prop formula-decl nil monotone_sequences nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (strict_from_rec def-decl
     "{(k, x) | x = seq(k) AND (k > 0 IMPLIES rel(seq(k - 1), seq(k)))}"
     monotone_sequences nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (subrange type-eq-decl nil integers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ascending_non_strict? const-decl "bool" monotone_sequences nil)
    (sequence type-eq-decl nil sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil monotone_sequences nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (strict_from subtype
    "LAMBDA (i: naturalnumbers.nat): monotone_sequences.strict_from_rec(monotone_sequences.rel)(monotone_sequences.seq)(i)`2"
    "(monotone_sequences.ascending?(monotone_sequences.rel))")))
 (ascending_subsequence 0
  (ascending_subsequence-1 nil 3314544355
   ("" (skolem-typepred)
    (("" (lemma "preserves_composition[nat, nat, T]")
      (("" (inst?)
        (("" (invoke (inst - "%1" "%1" "lt!1") (! -2 0 1))
          (("" (expand "preserves" -2)
            (("" (assert)
              (("" (hide -2)
                (("" (split)
                  (("1" (hide -3)
                    (("1" (expand* "ascending?" "preserves" "restrict")
                      (("1" (skolem!)
                        (("1" (inst?) (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (rewrite "ascending_lem") nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((preserves_composition formula-decl nil function_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ascending_lem formula-decl nil monotone_sequences nil)
    (ascending? const-decl "bool" monotone_sequences nil)
    (sequence type-eq-decl nil sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (transitive? const-decl "bool" relations nil)
    (T formal-type-decl nil monotone_sequences nil)
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (descending_subsequence 0
  (descending_subsequence-1 nil 3314544571
   ("" (skolem-typepred)
    (("" (use "ascending_subsequence" ("lt" "converse(lt!1)"))
      (("1" (expand* "ascending?" "converse" "descending?") nil nil)
       ("2" (expand* "ascending?" "converse" "descending?") nil nil))
      nil))
    nil)
   ((transitive? const-decl "bool" relations nil)) shostak))
 (ascending_n?_TCC1 0
  (ascending_n?_TCC1-1 nil 3820753926 ("" (subtype-tcc) nil nil) nil
   nil
   (ascending_n? subtype "monotone_sequences.i"
    "naturalnumbers.upto(monotone_sequences.n)")))
 (ascending_n?_TCC2 0
  (ascending_n?_TCC2-1 nil 3820753926 ("" (subtype-tcc) nil nil) nil
   nil
   (ascending_n? subtype "(number_fields.+)(monotone_sequences.i, 1)"
    "naturalnumbers.upto(monotone_sequences.n)")))
 (ascending_iterate_n_TCC1 0
  (ascending_iterate_n_TCC1-1 nil 3820753926 ("" (subtype-tcc) nil nil)
   nil nil
   (ascending_iterate_n subtype "monotone_sequences.j"
    "naturalnumbers.upto(monotone_sequences.n)")))
 (ascending_iterate_n_TCC2 0
  (ascending_iterate_n_TCC2-1 nil 3820753926 ("" (subtype-tcc) nil nil)
   nil nil
   (ascending_iterate_n subtype
    "(number_fields.-)(monotone_sequences.j, monotone_sequences.i)"
    "nat")))
 (ascending_iterate_n 0
  (ascending_iterate_n-1 nil 3820753942
   (""
    (case "FORALL (m,n: nat, rel: pred[[T, T]], fseq: (ascending_n?(n)(rel))) (i: below(n), j: subrange(i, n)): j-i=m IMPLIES iterate_n(j - i)(rel)(fseq(i), fseq(j))")
    (("1" (skeep)
      (("1" (skeep)
        (("1" (inst -1 "j-i" "n" "rel" "fseq" "i" "j") nil nil)) nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "m")
        (("1" (skeep* :preds? t)
          (("1" (case-replace "j=i")
            (("1" (grind) nil nil) ("2" (assert) nil nil)) nil))
          nil)
         ("2" (skeep*)
          (("2" (expand "iterate_n" 1)
            (("2" (expand "iterate" 1)
              (("2" (assert)
                (("2" (expand "o" 1)
                  (("2" (case "i=0")
                    (("1" (case "j=0")
                      (("1" (assert) nil nil)
                       ("2" (inst -2 "n" "rel" "fseq" "i" "j-1")
                        (("2" (assert)
                          (("2" (expand "iterate_n" -2)
                            (("2" (inst 2 "fseq(j-1)")
                              (("2"
                                (assert)
                                (("2"
                                  (typepred "fseq")
                                  (("2"
                                    (expand "ascending_n?" -1)
                                    (("2"
                                      (inst -1 "j-1")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (case "j=i")
                      (("1" (assert) nil nil)
                       ("2" (inst -1 "n" "rel" "fseq" "i" "j-1")
                        (("2" (assert)
                          (("2" (expand "iterate_n" -1)
                            (("2" (inst 3 "fseq(j-1)")
                              (("2"
                                (assert)
                                (("2"
                                  (typepred "fseq")
                                  (("2"
                                    (expand "ascending_n?" -1)
                                    (("2"
                                      (inst -1 "j-1")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((iterate def-decl "pred[[T, T]]" relation_iterate nil)
    (iterate_n const-decl "PRED[[T, T]]" relation_iterate nil))
   shostak))
 (iterate_n_fseq_TCC1 0
  (iterate_n_fseq_TCC1-1 nil 3820958931 ("" (subtype-tcc) nil nil) nil
   nil
   (iterate_n_fseq subtype "0"
    "naturalnumbers.upto(monotone_sequences.n)")))
 (iterate_n_fseq_TCC2 0
  (iterate_n_fseq_TCC2-1 nil 3820958931 ("" (subtype-tcc) nil nil) nil
   nil
   (iterate_n_fseq subtype "monotone_sequences.n"
    "naturalnumbers.upto(monotone_sequences.n)")))
 (iterate_n_fseq 0
  (iterate_n_fseq-1 nil 3820959601
   (""
    (case "FORALL (x, y: T, rel, n):         iterate_n(n)(rel)(x, y) IMPLIES EXISTS (fseq: (ascending_n?(n)(rel))): fseq(0) = x AND fseq(n) = y")
    (("1" (skeep)
      (("1" (insteep)
        (("1" (split 1)
          (("1" (propax) nil nil)
           ("2" (hide -1)
            (("2" (flatten)
              (("2" (skeep)
                (("2" (lemma "ascending_iterate_n")
                  (("2" (inst?)
                    (("1" (inst -1 "n") (("1" (assert) nil nil)) nil)
                     ("2" (case-replace "n=0")
                      (("1" (hide (-1 1)) (("1" (grind) nil nil)) nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "n")
        (("1" (skeep*)
          (("1" (expand "iterate_n")
            (("1" (expand "iterate" -1)
              (("1" (inst 1 "LAMBDA(i:upto(0)): x")
                (("1" (expand "ascending_n?" 1) (("1" (skeep) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep*)
          (("2" (expand "iterate_n" -2)
            (("2" (expand "iterate" -2)
              (("2" (expand "iterate_n" -1)
                (("2" (expand "o" -2)
                  (("2" (skeep -2)
                    (("2" (inst -1 "x" "y_1" "rel")
                      (("2" (assert)
                        (("2" (skeep)
                          (("2"
                            (inst 1
                             "LAMBDA(i:upto(j+1)): IF i=1+j THEN y ELSE fseq(i) ENDIF")
                            (("1" (assert) nil nil)
                             ("2" (expand "ascending_n?" 1)
                              (("2"
                                (skeep)
                                (("2"
                                  (assert)
                                  (("2"
                                    (case "i_1=j")
                                    (("1" (assert) nil nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (typepred "fseq")
                                        (("2"
                                          (expand "ascending_n?" -1)
                                          (("2"
                                            (inst -1 "i_1")
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (skeep) (("3" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((iterate def-decl "pred[[T, T]]" relation_iterate nil)
    (iterate_n const-decl "PRED[[T, T]]" relation_iterate nil))
   nil)))

