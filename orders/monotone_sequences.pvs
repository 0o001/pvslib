% infinite ascending and descending sequences and their subsequences
%
% Author: Alfons Geser (geser@nianet.org), National Institute of Aerospace
% Date: Dec 2004

monotone_sequences[T: TYPE]: THEORY

BEGIN

  IMPORTING closure_ops[T]

  n: VAR nat
  x, y: VAR T
  rel: VAR pred[[T, T]]
  seq: VAR sequence[T]
  lt: VAR (transitive?[T])
  asc: VAR (preserves[nat, nat](<, <))

  % these definitions do not require rel to be a partial order

  ascending?(rel)(seq): bool =
    FORALL n: rel(seq(n), seq(n + 1))

  descending?(rel)(seq): bool =
    FORALL n: rel(seq(n + 1), seq(n))

  reflexive_closure_ascending: LEMMA
    FORALL (seq: (ascending?(rel))): ascending?(reflexive_closure(rel))(seq)

  reflexive_closure_descending: LEMMA
    FORALL (seq: (descending?(rel))): descending?(reflexive_closure(rel))(seq)

  ascending_lem: LEMMA
    FORALL (seq: (ascending?(lt))): preserves(seq, <, lt)

  descending_lem: LEMMA
    FORALL (seq: (descending?(lt))): preserves(seq, <, converse(lt))

  ascending_suffix : LEMMA
    FORALL (seq: (ascending?(rel)))(n:nat) :
      ascending?(rel)(suffix(seq,n))

  % subsequences
  ascending_subsequence: THEOREM
    FORALL (seq: (ascending?(lt))): ascending?(lt)(seq o asc)

  descending_subsequence: THEOREM
    FORALL (seq: (descending?(lt))): descending?(lt)(seq o asc)

  %1/27/21 JTS, 1/29/21 CM: fseq goes up to n
  ascending_n?(n)(rel)(fseq:ARRAY[upto(n)->T]): bool =
    FORALL (i:below(n)): rel(fseq(i),fseq(i+1))

  ascending_iterate_n : LEMMA
    FORALL(fseq:(ascending_n?(n)(rel)))(i:below(n),j:subrange(i,n)):
      iterate_n(j-i)(rel)(fseq(i),fseq(j))

  iterate_n_fseq: LEMMA
    FORALL(x,y:T,rel,n):
      iterate_n(n)(rel)(x,y) IFF
      EXISTS (fseq:(ascending_n?(n)(rel))) : fseq(0) = x AND fseq(n) =y

END monotone_sequences
