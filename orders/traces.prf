(traces
 (reachable_empty 0
  (reachable_empty-1 nil 3821351824
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "empty?" 1)
          (("1" (skeep)
            (("1" (expand "member")
              (("1" (lemma "reachable_weak_induction")
                (("1" (inst?)
                  (("1" (inst -1 "LAMBDA(t:T): NOT empty?(init)")
                    (("1" (split)
                      (("1" (inst -1 "x") (("1" (assert) nil nil)) nil)
                       ("2" (skeep)
                        (("2" (split)
                          (("1" (expand "empty?")
                            (("1" (expand "member")
                              (("1" (inst -2 "t_1") nil nil)) nil))
                            nil)
                           ("2" (skeep) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "empty?")
          (("2" (skeep)
            (("2" (insteep)
              (("2" (expand "member")
                (("2" (expand "reachable") (("2" (flatten) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (reachable_weak_induction formula-decl nil traces nil)
    (reachable inductive-decl "bool" traces nil))
   shostak))
 (invariant_rule 0
  (invariant_rule-1 nil 3821297502
   ("" (skeep)
    (("" (lemma "reachable_induction")
      (("" (expand "invariant")
        (("" (inst -1 "rel" "init" "inv")
          (("" (split -1)
            (("1" (skeep)
              (("1" (insteep) (("1" (assert) nil nil)) nil)) nil)
             ("2" (hide 2)
              (("2" (skeep)
                (("2" (inst -2 "t")
                  (("2" (assert)
                    (("2" (skeep)
                      (("2" (inst -4 "tp" "t") (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((reachable_induction formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil) nil nil nil nil
    (reachable inductive-decl "bool" traces nil)
    (invariant const-decl "bool" traces nil))
   shostak))
 (reachable_tc 0
  (reachable_tc-1 nil 3821476787
   ("" (skeep*)
    (("" (lemma "TC_weak_induction")
      (("" (inst -1 "rel" _)
        ((""
          (inst -1
           "LAMBDA(x,y:T):reachable(rel)(init)(x) IMPLIES reachable(rel)(init)(y)")
          (("" (split)
            (("1" (inst?) (("1" (assert) nil nil)) nil)
             ("2" (hide-all-but 1)
              (("2" (skeep)
                (("2" (split -1)
                  (("1" (expand "reachable" 1)
                    (("1" (flatten)
                      (("1" (inst? 2) (("1" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (skeep) (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TC_weak_induction formula-decl nil relations nil)
    (T formal-type-decl nil traces nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (reachable inductive-decl "bool" traces nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (reachable_iff_tc 0
  (reachable_iff_tc-1 nil 3821466405
   ("" (skeep)
    ((""
      (case "FORALL (t: T): reachable(rel)(init)(t) IMPLIES init(t) OR EXISTS (tt: (init)): TC(rel)(tt, t)")
      (("1"
        (case "FORALL (t: T): (init(t) OR EXISTS (tt: (init)): TC(rel)(tt, t)) IMPLIES reachable(rel)(init)(t)")
        (("1" (skeep)
          (("1" (insteep)
            (("1" (insteep) (("1" (ground) nil nil)) nil)) nil))
          nil)
         ("2" (hide-all-but 1)
          (("2" (skeep)
            (("2" (expand "reachable")
              (("2" (flatten)
                (("2" (assert)
                  (("2" (skeep -1)
                    (("2" (lemma "TC_induction")
                      (("2" (inst -1 "rel" _)
                        (("2"
                          (inst -1
                           "LAMBDA(t1,t2:T): init(t1) IMPLIES reachable(rel)(init)(t2)")
                          (("2" (split -1)
                            (("1" (inst? -1)
                              (("1"
                                (assert)
                                (("1"
                                  (expand "reachable" -1)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but 1)
                              (("2"
                                (skeep)
                                (("2"
                                  (split -1)
                                  (("1"
                                    (expand "reachable")
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (inst 2 "x")
                                        (("1"
                                          (expand "reachable")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (skeep)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (lemma "reachable_tc")
                                        (("2"
                                          (inst
                                           -1
                                           "rel"
                                           "init"
                                           "z"
                                           "y")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (rule-induct "reachable")
          (("2" (skeep)
            (("2" (assert)
              (("2" (skeep -1)
                (("2" (split -1)
                  (("1" (inst 2 "tp")
                    (("1" (expand "TC") (("1" (flatten) nil nil)) nil))
                    nil)
                   ("2" (skeep)
                    (("2" (insteep)
                      (("2" (expand "TC" 2)
                        (("2" (flatten)
                          (("2" (inst 3 "tp")
                            (("2" (assert)
                              (("2"
                                (expand "TC" 3)
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TC inductive-decl "bool" relations nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (reachable inductive-decl "bool" traces nil)
    (PRED type-eq-decl nil defined_types nil)
    (Relation type-eq-decl nil termination nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil traces nil)
    (TC_induction formula-decl nil relations nil)
    (reachable_tc formula-decl nil traces nil)
    (reachable_weak_induction formula-decl nil traces nil) nil nil)
   shostak))
 (normalizing_reachable 0
  (normalizing_reachable-1 nil 3821620584
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "normalizing")
          (("1" (expand "empty?")
            (("1" (expand "member")
              (("1" (skeep)
                (("1" (inst -2 "0")
                  (("1" (lemma "reachable_iff_tc")
                    (("1" (inst?)
                      (("1" (assert)
                        (("1" (split -1)
                          (("1" (insteep) nil nil)
                           ("2" (skeep :preds? t)
                            (("2" (rewrite "iterate_n_tc")
                              (("2"
                                (skeep)
                                (("2"
                                  (rewrite "iterate_n_fseq")
                                  (("2"
                                    (skeep)
                                    (("2"
                                      (inst
                                       -4
                                       "LAMBDA(i:nat): IF i <= n THEN fseq(i) ELSE x(i-n) ENDIF")
                                      (("1" (assert) nil nil)
                                       ("2"
                                        (expand "ascending?")
                                        (("2"
                                          (skeep)
                                          (("2"
                                            (case "n_1 < n")
                                            (("1"
                                              (assert)
                                              (("1"
                                                (typepred "fseq")
                                                (("1"
                                                  (expand
                                                   "ascending_n?")
                                                  (("1"
                                                    (inst?)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (case-replace "n_1=n")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (replaces -4)
                                                  (("1"
                                                    (typepred "x")
                                                    (("1"
                                                      (expand
                                                       "ascending?")
                                                      (("1"
                                                        (inst?)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (typepred "x")
                                                  (("2"
                                                    (expand
                                                     "ascending?")
                                                    (("2"
                                                      (inst? -1)
                                                      (("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3"
                                        (hide-all-but 1)
                                        (("3" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "normalizing")
          (("2" (expand "empty?")
            (("2" (skeep)
              (("2" (insteep)
                (("2" (expand "member")
                  (("2" (induct "i")
                    (("1" (expand "reachable")
                      (("1" (flatten) nil nil)) nil)
                     ("2" (skeep)
                      (("2" (expand "reachable" 1)
                        (("2" (flatten)
                          (("2" (inst 2 "x(j)")
                            (("2" (assert)
                              (("2"
                                (typepred "x")
                                (("2"
                                  (expand "ascending?")
                                  (("2" (inst?) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((normalizing const-decl "bool" traces nil)
    (member const-decl "bool" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil traces nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil)
    (sequence type-eq-decl nil sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (ascending? const-decl "bool" monotone_sequences nil)
    (iterate_n_tc formula-decl nil relation_iterate nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (iterate_n_fseq formula-decl nil monotone_sequences nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) nil
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil (ascending_n? const-decl "bool" monotone_sequences nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil) nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (TRUE const-decl "bool" booleans nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (reachable_iff_tc formula-decl nil traces nil)
    (empty? const-decl "bool" sets nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (reachable inductive-decl "bool" traces nil))
   shostak))
 (terminating_eq_normalizing 0
  (terminating_eq_normalizing-1 nil 3822240824
   ("" (decompose-equality)
    (("" (rewrite "terminating_no_ascending_seq")
      (("" (expand "normalizing")
        (("" (expand "empty?")
          (("" (expand "member")
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (skeep)
                    (("1" (insteep)
                      (("1" (typepred "x") (("1" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (skeep) (("2" (insteep) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((terminating_no_ascending_seq formula-decl nil termination nil)
    (empty? const-decl "bool" sets nil) nil nil
    (ascending? const-decl "bool" monotone_sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (sequence type-eq-decl nil sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (normalizing const-decl "bool" traces nil)
    (PRED type-eq-decl nil defined_types nil)
    (terminating const-decl "bool" termination nil)
    (Relation type-eq-decl nil termination nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   nil))
 (normalizing_is_terminating 0
  (normalizing_is_terminating-1 nil 3821653539
   ("" (skeep)
    (("" (rewrite "normalizing_reachable")
      (("" (rewrite "terminating_no_ascending_seq")
        (("" (expand "empty?")
          (("" (expand "member")
            (("" (split)
              (("1" (flatten)
                (("1" (skeep)
                  (("1" (insteep)
                    (("1" (expand "ascending?")
                      (("1" (skeep)
                        (("1" (inst -1 "i") (("1" (flatten) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "ascending?")
                      (("2" (skeep)
                        (("2" (insteep) (("2" (flatten) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (skeep)
                  (("2" (insteep)
                    (("2" (expand "ascending?")
                      (("2" (skeep)
                        (("2" (inst -1 "n")
                          (("2" (assert)
                            (("2" (typepred "x")
                              (("2"
                                (expand "ascending?")
                                (("2" (insteep) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((normalizing_reachable formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (Relation type-eq-decl nil termination nil)
    (empty? const-decl "bool" sets nil) nil nil
    (ascending? const-decl "bool" monotone_sequences nil)
    (sequence type-eq-decl nil sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pred type-eq-decl nil defined_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (reachable inductive-decl "bool" traces nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (terminating_no_ascending_seq formula-decl nil termination nil))
   shostak))
 (normalizing_reachable_normalizable 0
  (normalizing_reachable_normalizable-1 nil 3821706091
   ("" (skeep*)
    (("" (typepred "rel")
      (("" (rewrite "normalizing_is_terminating")
        (("" (lemma "terminating_is_weakly_terminating")
          ((""
            (inst -1
             "LAMBDA (t1, t2: T):reachable(rel)(init)(t1) AND rel(t1, t2)")
            (("" (expand "weakly_terminating")
              (("" (insteep)
                (("" (expand "normalizable")
                  (("" (split -1)
                    (("1" (expand "normal") (("1" (flatten) nil nil))
                      nil)
                     ("2" (skeep :preds? t)
                      (("2" (typepred "t")
                        (("2" (case "TC(rel)(t,nft)")
                          (("1" (insteep)
                            (("1" (hide -4 -5 2)
                              (("1"
                                (expand "normal")
                                (("1"
                                  (skeep)
                                  (("1"
                                    (insteep)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (lemma "reachable_tc")
                                        (("1"
                                          (inst
                                           -1
                                           "rel"
                                           "init"
                                           "t"
                                           "nft")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but (-1 -3 1))
                            (("2" (rewrite "iterate_n_tc")
                              (("2"
                                (rewrite "iterate_n_tc")
                                (("2"
                                  (skeep)
                                  (("2"
                                    (insteep)
                                    (("2"
                                      (rewrite "iterate_n_fseq")
                                      (("2"
                                        (rewrite "iterate_n_fseq")
                                        (("2"
                                          (skeep)
                                          (("2"
                                            (insteep)
                                            (("1" (assert) nil nil)
                                             ("2"
                                              (typepred "fseq")
                                              (("2"
                                                (expand "ascending_n?")
                                                (("2"
                                                  (skeep)
                                                  (("2"
                                                    (insteep)
                                                    (("2"
                                                      (flatten)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((normalizing const-decl "bool" traces nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil)
    (T formal-type-decl nil traces nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (terminating_is_weakly_terminating formula-decl nil termination
     nil)
    (weakly_terminating const-decl "bool" termination nil)
    (normalizable const-decl "bool" termination nil)
    (TC inductive-decl "bool" relations nil)
    (reachable_tc formula-decl nil traces nil) nil
    (pred type-eq-decl nil defined_types nil)
    (iterate_n_tc formula-decl nil relation_iterate nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (iterate_n_fseq formula-decl nil monotone_sequences nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ascending_n? const-decl "bool" monotone_sequences nil) nil nil
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (normal const-decl "bool" termination nil)
    (terminating const-decl "bool" termination nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (reachable inductive-decl "bool" traces nil) nil nil
    (normalizing_is_terminating formula-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (terminating_is_normalizing 0
  (terminating_is_normalizing-1 nil 3822240958
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (rewrite "terminating_no_ascending_seq")
          (("1" (expand "normalizing")
            (("1" (expand "empty?")
              (("1" (expand "member")
                (("1" (skeep*)
                  (("1" (insteep) (("1" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (inst -1 "LAMBDA(t:T):TRUE")
          (("2" (rewrite "terminating_eq_normalizing" :dir rl) nil
            nil))
          nil))
        nil))
      nil))
    nil)
   ((terminating_no_ascending_seq formula-decl nil termination nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Relation type-eq-decl nil termination nil)
    (T formal-type-decl nil traces nil)
    (empty? const-decl "bool" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sequence type-eq-decl nil sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (ascending? const-decl "bool" monotone_sequences nil)
    (member const-decl "bool" sets nil)
    (normalizing const-decl "bool" traces nil)
    (PRED type-eq-decl nil defined_types nil)
    (terminating_eq_normalizing formula-decl nil traces nil))
   shostak))
 (none_above 0
  (none_above-1 nil 3821301708
   ("" (skeep :but "j")
    (("" (case "FORALL (n:nat): none?(tr(i)) IMPLIES none?(tr(i+n))")
      (("1" (skeep)
        (("1" (inst -1 "j-i") (("1" (assert) nil nil)) nil)) nil)
       ("2" (hide 2)
        (("2" (induct "n")
          (("1" (flatten) (("1" (assert) nil nil)) nil)
           ("2" (skeep)
            (("2" (assert)
              (("2" (typepred "tr")
                (("2" (inst -1 "i+j") (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Trace type-eq-decl nil traces nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (sequence type-eq-decl nil sequences nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (Maybe type-decl nil Maybe structures)
    (T formal-type-decl nil traces nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (pred type-eq-decl nil defined_types nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak))
 (some_below 0
  (some_below-1 nil 3821713973
   ("" (skeep)
    (("" (typepred "j")
      (("" (case "none?(tr(j))")
        (("1" (lemma "none_above")
          (("1" (inst -1 "tr" "j" "i") (("1" (assert) nil nil)) nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (none_above formula-decl nil traces nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil))
   shostak))
 (some_before_none 0
  (some_before_none-1 nil 3822252802
   ("" (skeep)
    (("" (lemma "none_above")
      (("" (inst -1 "tr" "j" "i")
        (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
      nil))
    nil)
   ((none_above formula-decl nil traces nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (Trace type-eq-decl nil traces nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sequence type-eq-decl nil sequences nil)
    (Maybe type-decl nil Maybe structures)
    (T formal-type-decl nil traces nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil) nil nil
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (length_TCC1 0
  (length_TCC1-1 nil 3821301700 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (finite_trace? const-decl "bool" traces nil)
    (FiniteTrace type-eq-decl nil traces nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   nil
   (length subtype
           "{n: naturalnumbers.nat | Maybe[traces.T].none?(traces.ftr(n))}"
           "(sets[nat].nonempty?)")))
 (none_after_length 0
  (none_after_length-1 nil 3821302445
   ("" (skeep :preds? t)
    (("" (expand "length")
      (("" (name-label "mm" "min({n: nat | none?(ftr(n))})")
        (("" (typepred "mm")
          (("" (lemma "none_above")
            (("" (inst -1 "ftr" "mm" "i") (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((length const-decl "nat" traces nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil (upfrom nonempty-type-eq-decl nil integers nil) nil nil
    (none_above formula-decl nil traces nil)
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
         min_nat nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (finite_trace? const-decl "bool" traces nil)
    (FiniteTrace type-eq-decl nil traces nil))
   shostak))
 (some_before_length 0
  (some_before_length-1 nil 3822252239
   ("" (skeep* :preds? t)
    (("" (expand "length")
      (("" (with-tccs (typepred "min({n: nat | none?(ftr(n))})"))
        (("" (inst -2 "i") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((length const-decl "nat" traces nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
         min_nat nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (finite_trace? const-decl "bool" traces nil)
    (FiniteTrace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (length_is_none 0
  (length_is_none-1 nil 3821303019
   ("" (skeep)
    (("" (lemma "none_after_length") (("" (inst?) nil nil)) nil)) nil)
   ((none_after_length formula-decl nil traces nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (finite_trace? const-decl "bool" traces nil)
    (FiniteTrace type-eq-decl nil traces nil)
    (length const-decl "nat" traces nil)
    (upfrom nonempty-type-eq-decl nil integers nil))
   shostak))
 (empty_trace_TCC1 0
  (empty_trace_TCC1-1 nil 3821352934 ("" (subtype-tcc) nil nil)
   ((finite_trace? const-decl "bool" traces nil)) nil
   (empty_trace subtype
    "LAMBDA (i: naturalnumbers.nat): Maybe[traces.T].None"
    "FiniteTrace")))
 (empty_trace_length 0
  (empty_trace_length-1 nil 3821352966
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (decompose-equality)
          (("1" (expand "empty_trace")
            (("1" (lemma "none_after_length")
              (("1" (inst?) (("1" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (replaces -1)
          (("2" (grind)
            (("2" (with-tccs (typepred "min({n: nat | TRUE})"))
              (("2" (inst -1 "0") (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (finite_trace? const-decl "bool" traces nil)
    (FiniteTrace type-eq-decl nil traces nil)
    (empty_trace const-decl "FiniteTrace" traces nil)
    (sequence type-eq-decl nil sequences nil)
    (Maybe type-decl nil Maybe structures)
    (T formal-type-decl nil traces nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (none_after_length formula-decl nil traces nil)
    (length const-decl "nat" traces nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
         min_nat nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (empty_trace_lenght_eq_0 0
  (empty_trace_lenght_eq_0-1 nil 3821352941
   ("" (lemma "empty_trace_length")
    (("" (inst?) (("" (assert) nil nil)) nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (finite_trace? const-decl "bool" traces nil)
    (FiniteTrace type-eq-decl nil traces nil)
    (empty_trace const-decl "FiniteTrace" traces nil)
    (empty_trace_length formula-decl nil traces nil))
   shostak))
 (head_none_empty_trace 0
  (head_none_empty_trace-1 nil 3821726644
   ("" (skeep)
    (("" (grind)
      (("" (decompose-equality)
        (("" (case-replace "x!1=0")
          (("1" (assert) nil nil)
           ("2" (lemma "none_above")
            (("2" (inst -1 "tr" "0" "x!1") (("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((empty_trace const-decl "FiniteTrace" traces nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (none_above formula-decl nil traces nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (FiniteTrace type-eq-decl nil traces nil)
    (finite_trace? const-decl "bool" traces nil)
    (Trace type-eq-decl nil traces nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   shostak))
 (single_trace_TCC1 0
  (single_trace_TCC1-1 nil 3821722059
   ("" (skeep)
    (("" (split)
      (("1" (skeep)
        (("1" (case-replace "i_1=0")
          (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
        nil)
       ("2" (expand "finite_trace?")
        (("2" (inst 1 "1") (("2" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (finite_trace? const-decl "bool" traces nil))
   nil
   (single_trace subtype
    "LAMBDA (i: naturalnumbers.nat): IF i = 0 THEN Maybe[traces.T].Some(traces.t) ELSE Maybe[traces.T].None ENDIF"
    "FiniteTrace")))
 (single_trace_length 0
  (single_trace_length-1 nil 3821722225
   ("" (skeep)
    (("" (expand "length")
      ((""
        (with-tccs
         (typepred "min({n: nat | none?(single_trace(t)(n))})"))
        (("" (inst -2 "1") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((length const-decl "nat" traces nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
         min_nat nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (finite_trace? const-decl "bool" traces nil)
    (FiniteTrace type-eq-decl nil traces nil)
    (single_trace const-decl "FiniteTrace" traces nil))
   shostak))
 (traces_TCC1 0
  (traces_TCC1-1 nil 3821301700 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (traces subtype "traces.tr(traces.n)" "(Maybe[traces.T].some?)")))
 (traces_TCC2 0
  (traces_TCC2-1 nil 3821301700 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (traces subtype "traces.tr(traces.n)" "(Maybe[traces.T].some?)")))
 (single_iff_normal 0
  (single_iff_normal-1 nil 3821722477
   ("" (skeep*)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "traces")
          (("1" (skeep)
            (("1" (case-replace "n=0")
              (("1" (assert)
                (("1" (expand "single_trace") (("1" (propax) nil nil))
                  nil))
                nil)
               ("2" (hide 3)
                (("2" (expand "single_trace") (("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "traces")
          (("2" (inst -1 "0")
            (("2" (expand "single_trace") (("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((traces const-decl "bool" traces nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (single_trace const-decl "FiniteTrace" traces nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (single_normal_unique 0
  (single_normal_unique-2 nil 3821723373
   ("" (skeep* :preds? t)
    (("" (split)
      (("1" (flatten)
        (("1" (decompose-equality)
          (("1" (case-replace "x!1=0")
            (("1" (expand "single_trace")
              (("1" (hide-all-but (-5 1))
                (("1" (decompose-equality) nil nil)) nil))
              nil)
             ("2" (expand "single_trace")
              (("2" (assert)
                (("2" (expand "traces")
                  (("2" (inst -3 "0")
                    (("2" (assert)
                      (("2" (split -3)
                        (("1" (flatten)
                          (("1" (hide-all-but (-2 -3))
                            (("1" (expand "normal")
                              (("1" (inst? 1) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (lemma "none_above")
                          (("2" (inst -1 "tr" "1" "x!1")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (lemma "single_iff_normal")
          (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (Relation type-eq-decl nil termination nil)
    (traces const-decl "bool" traces nil)
    (finite_trace? const-decl "bool" traces nil)
    (FiniteTrace type-eq-decl nil traces nil)
    (single_trace const-decl "FiniteTrace" traces nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (val adt-accessor-decl "[(some?) -> T]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (Maybe type-decl nil Maybe structures)
    (T formal-type-decl nil traces nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (none_above formula-decl nil traces nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (normal const-decl "bool" termination nil)
    (Maybe_Some_extensionality formula-decl nil Maybe structures)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe structures)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (single_iff_normal formula-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (tc_iff_prefix_of_trace_TCC1 0
  (tc_iff_prefix_of_trace_TCC1-1 nil 3821525849
   ("" (skeep) (("" (inst? -1) nil nil)) nil)
   ((upto nonempty-type-eq-decl nil naturalnumbers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (tc_iff_prefix_of_trace subtype "traces.tr(0)"
    "(Maybe[traces.T].some?)")))
 (tc_iff_prefix_of_trace_TCC2 0
  (tc_iff_prefix_of_trace_TCC2-1 nil 3821525849
   ("" (skeep) (("" (inst? -1) nil nil)) nil)
   ((upto nonempty-type-eq-decl nil naturalnumbers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (tc_iff_prefix_of_trace subtype "traces.tr(traces.n)"
    "(Maybe[traces.T].some?)")))
 (tc_iff_prefix_of_trace 0
  (tc_iff_prefix_of_trace-1 nil 3821525900
   ("" (skeep*)
    (("" (split)
      (("1" (flatten)
        (("1" (rewrite "iterate_n_tc")
          (("1" (skeep)
            (("1" (rewrite "iterate_n_fseq")
              (("1" (skeep)
                (("1" (typepred "fseq")
                  (("1" (expand "ascending_n?")
                    (("1" (case "normalizing(LAMBDA(t:T):t=t2)(rel)")
                      (("1"
                        (lemma "normalizing_reachable_normalizable")
                        (("1" (inst -1 "LAMBDA(t:T):t=t2" "rel" "t2")
                          (("1" (expand "normalizable")
                            (("1" (split -1)
                              (("1"
                                (inst
                                 1
                                 "LAMBDA(i:nat): IF i <= n THEN Some(fseq(i)) ELSE None ENDIF"
                                 "n")
                                (("1" (assert) nil nil)
                                 ("2"
                                  (split)
                                  (("1"
                                    (skeep)
                                    (("1"
                                      (case-replace "i_1 <= n")
                                      (("1" (assert) nil nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand "traces")
                                    (("2"
                                      (skeep)
                                      (("2"
                                        (case "n_1 < n")
                                        (("1"
                                          (assert)
                                          (("1" (inst? -4) nil nil))
                                          nil)
                                         ("2"
                                          (assert)
                                          (("2"
                                            (case-replace "n_1 = n")
                                            (("1" (assert) nil nil)
                                             ("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (skeep)
                                (("2"
                                  (rewrite "iterate_n_tc")
                                  (("2"
                                    (skolem -1 "nn")
                                    (("2"
                                      (rewrite "iterate_n_fseq")
                                      (("2"
                                        (skolem -1 "ffseq")
                                        (("2"
                                          (flatten)
                                          (("2"
                                            (typepred "nft")
                                            (("2"
                                              (typepred "ffseq")
                                              (("2"
                                                (expand "ascending_n?")
                                                (("2"
                                                  (inst
                                                   1
                                                   "LAMBDA(i:nat): IF i <= n THEN Some(fseq(i)) ELSIF i <= n+nn THEN Some(ffseq(i-n)) ELSE None ENDIF"
                                                   "n")
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (split)
                                                    (("1"
                                                      (skeep)
                                                      (("1"
                                                        (case-replace
                                                         "i_1 <= n")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (assert)
                                                          (("2"
                                                            (case-replace
                                                             "i_1 <= n + nn")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (expand "traces")
                                                      (("2"
                                                        (skeep)
                                                        (("2"
                                                          (case
                                                           "n_1 < n")
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (inst?
                                                               -7)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (case-replace
                                                             "n_1=n")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (inst
                                                                 -2
                                                                 "0")
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              (("2"
                                                                (case-replace
                                                                 "n_1 <= n+nn")
                                                                (("1"
                                                                  (split
                                                                   4)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (case-replace
                                                                       "1 + n_1 <= n + nn")
                                                                      (("1"
                                                                        (inst
                                                                         -4
                                                                         "n_1-n")
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil)
                                                                         ("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (hide-all-but 1)
                                                    (("3"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but 1)
                            (("2" (expand "reachable")
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "normalizing")
                        (("2" (expand "empty?")
                          (("2" (expand "member")
                            (("2" (skeep :preds? t)
                              (("2"
                                (expand "ascending?")
                                (("2"
                                  (inst
                                   1
                                   "LAMBDA(i:nat): IF i <= n THEN Some(fseq(i)) ELSE Some(x(i-n)) ENDIF"
                                   "n")
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (split)
                                    (("1"
                                      (skeep)
                                      (("1"
                                        (lift-if)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand "traces")
                                      (("2"
                                        (skeep)
                                        (("2"
                                          (hide 1)
                                          (("2"
                                            (case "n_1 < n")
                                            (("1"
                                              (assert)
                                              (("1"
                                                (inst? -4)
                                                nil
                                                nil))
                                              nil)
                                             ("2"
                                              (case-replace "n_1 = n")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (inst -2 "0")
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (inst -1 "n_1-n")
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (hide-all-but 1)
                                    (("3" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (skeep)
          (("2" (typepred "tr")
            (("2" (expand "traces")
              (("2" (rewrite "iterate_n_tc")
                (("2" (insteep)
                  (("2" (rewrite "iterate_n_fseq")
                    (("2" (inst 1 "LAMBDA(i:upto(n)):val(tr(i))")
                      (("1" (assert) nil nil)
                       ("2" (expand "ascending_n?")
                        (("2" (skeep :preds? t)
                          (("2" (inst -3 "i_1")
                            (("2" (split -3)
                              (("1"
                                (inst -4 "i_1")
                                (("1" (assert) nil nil))
                                nil)
                               ("2" (flatten) nil nil)
                               ("3"
                                (flatten)
                                (("3"
                                  (inst -4 "i_1+1")
                                  (("3" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((iterate_n_tc formula-decl nil relation_iterate nil)
    (pred type-eq-decl nil defined_types nil)
    (Relation type-eq-decl nil termination nil)
    (T formal-type-decl nil traces nil)
    (iterate_n_fseq formula-decl nil monotone_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (ascending_n? const-decl "bool" monotone_sequences nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (normalizing const-decl "bool" traces nil)
    (= const-decl "[T, T -> boolean]" equalities nil) nil nil
    (reachable inductive-decl "bool" traces nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Maybe type-decl nil Maybe structures)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (IF const-decl "[boolean, T, T -> T]" if_def nil) nil
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe structures) nil
    (None adt-constructor-decl "(none?)" Maybe structures)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sequence type-eq-decl nil sequences nil)
    (Trace type-eq-decl nil traces nil)
    (traces const-decl "bool" traces nil)
    (normal const-decl "bool" termination nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil (int_plus_int_is_int application-judgement "int" integers nil)
    nil
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (normalizable const-decl "bool" termination nil)
    (normalizing_reachable_normalizable formula-decl nil traces nil)
    (empty? const-decl "bool" sets nil) nil
    (ascending? const-decl "bool" monotone_sequences nil)
    (member const-decl "bool" sets nil) nil nil
    (val adt-accessor-decl "[(some?) -> T]" Maybe structures)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (terminating_iff_finite_traces 0
  (terminating_iff_finite_traces-1 nil 3822165873
   ("" (skeep)
    (("" (rewrite "terminating_no_ascending_seq")
      (("" (expand "empty?")
        (("" (expand "member")
          (("" (split)
            (("1" (flatten)
              (("1" (skeep)
                (("1" (expand "finite_trace?")
                  (("1" (inst -1 "LAMBDA(i:nat):val(tr(i))")
                    (("1" (expand "ascending?")
                      (("1" (skeep)
                        (("1" (typepred "tr")
                          (("1" (expand "traces")
                            (("1" (insteep -2)
                              (("1"
                                (split -2)
                                (("1" (insteep 2) nil nil)
                                 ("2" (flatten) nil nil)
                                 ("3"
                                  (flatten)
                                  (("3"
                                    (inst 3 "n+1")
                                    (("3" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skeep)
                      (("2" (inst 2 "i") (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (skeep)
                (("2" (expand "ascending?")
                  (("2" (inst -1 "LAMBDA(i:nat):Some(x(i))")
                    (("1" (expand "finite_trace?")
                      (("1" (propax) nil nil)) nil)
                     ("2" (expand "traces") (("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((terminating_no_ascending_seq formula-decl nil termination nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Relation type-eq-decl nil termination nil)
    (T formal-type-decl nil traces nil)
    (member const-decl "bool" sets nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe structures) nil
    (finite_trace? const-decl "bool" traces nil)
    (ascending? const-decl "bool" monotone_sequences nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe structures)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Maybe type-decl nil Maybe structures)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (traces const-decl "bool" traces nil) nil nil
    (empty? const-decl "bool" sets nil))
   shostak))
 (last_of_finite_is_normal_TCC1 0
  (last_of_finite_is_normal_TCC1-1 nil 3822259718
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (Relation type-eq-decl nil termination nil)
    (traces const-decl "bool" traces nil)
    (normal const-decl "bool" termination nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finite_trace? const-decl "bool" traces nil)
    (length const-decl "nat" traces nil))
   nil (last_of_finite_is_normal subtype "traces.last" "nat")))
 (last_of_finite_is_normal 0
  (last_of_finite_is_normal-1 nil 3822260303
   ("" (skeep* :preds? t)
    (("" (skoletin)
      (("" (expand "traces")
        (("" (inst -3 "last")
          (("1" (lemma "some_before_length")
            (("1" (inst -1 "tr" "last")
              (("1" (assert)
                (("1" (split -4)
                  (("1" (flatten)
                    (("1" (lemma "length_is_none")
                      (("1" (inst? -1) (("1" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (propax) nil nil))
                  nil))
                nil)
               ("2" (assert) nil nil))
              nil))
            nil)
           ("2" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((traces const-decl "bool" traces nil)
    (Relation type-eq-decl nil termination nil)
    (finite_trace? const-decl "bool" traces nil)
    (Trace type-eq-decl nil traces nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sequence type-eq-decl nil sequences nil)
    (Maybe type-decl nil Maybe structures)
    (T formal-type-decl nil traces nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (FiniteTrace type-eq-decl nil traces nil)
    (length const-decl "nat" traces nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (normal const-decl "bool" termination nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe structures)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (last skolem-const-decl "int" traces nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (rel skolem-const-decl "Relation[T]" traces nil)
    (tr skolem-const-decl "(traces(rel))" traces nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length_is_none formula-decl nil traces nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (some_before_length formula-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (run_traces_j 0
  (run_traces_j-1 nil 3822260212 ("" (judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Maybe type-decl nil Maybe structures)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil)
    (run const-decl "PRED[Trace]" traces nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (T formal-type-decl nil traces nil)
    (normal const-decl "bool" termination nil)
    (traces const-decl "bool" traces nil))
   nil
   (run_traces_j subtype "traces.x" "(traces.traces(traces.rel))")))
 (normalizing_iff_finite_traces 0
  (normalizing_iff_finite_traces-1 nil 3822241615
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "normalizing")
          (("1" (expand "empty?")
            (("1" (expand "member")
              (("1" (skeep)
                (("1" (expand "finite_trace?")
                  (("1" (typepred "rn")
                    (("1" (expand "run")
                      (("1" (flatten)
                        (("1" (expand "traces")
                          (("1" (inst -5 "LAMBDA(i:nat):val(rn(i))")
                            (("1" (expand "ascending?")
                              (("1"
                                (skeep)
                                (("1"
                                  (insteep -2)
                                  (("1"
                                    (split -2)
                                    (("1" (insteep 2) nil nil)
                                     ("2" (flatten) nil nil)
                                     ("3"
                                      (flatten)
                                      (("3"
                                        (inst 3 "n+1")
                                        (("3" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (skeep)
                              (("2"
                                (inst 2 "i")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "normalizing")
          (("2" (expand "empty?")
            (("2" (skeep)
              (("2" (expand "member")
                (("2" (inst -1 "LAMBDA(i:nat):Some(x(i))")
                  (("1" (expand "finite_trace?")
                    (("1" (propax) nil nil)) nil)
                   ("2" (expand "run")
                    (("2" (assert)
                      (("2" (expand "traces")
                        (("2" (skeep)
                          (("2" (typepred "x")
                            (("2" (expand "ascending?")
                              (("2" (insteep) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((normalizing const-decl "bool" traces nil)
    (member const-decl "bool" sets nil)
    (finite_trace? const-decl "bool" traces nil)
    (traces const-decl "bool" traces nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    nil nil nil (pred type-eq-decl nil defined_types nil)
    (ascending? const-decl "bool" monotone_sequences nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (val adt-accessor-decl "[(some?) -> T]" Maybe structures)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil)
    (run const-decl "PRED[Trace]" traces nil)
    (empty? const-decl "bool" sets nil) nil
    (Some adt-constructor-decl "[T -> (some?)]" Maybe structures))
   shostak))
 (run_empty 0
  (run_empty-1 nil 3821478499
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "empty?")
          (("1" (skeep :preds? t)
            (("1" (expand "member")
              (("1" (expand "run")
                (("1" (flatten) (("1" (inst? -2) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "empty?")
          (("2" (skeep)
            (("2" (expand "member")
              (("2" (expand "run")
                (("2" (case "normal(rel)(x)")
                  (("1"
                    (inst -2
                     "LAMBDA(i:nat): IF i=0 THEN Some(x) ELSE None ENDIF")
                    (("1" (assert)
                      (("1" (expand "traces")
                        (("1" (skeep)
                          (("1" (case-replace "n=0")
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "normal")
                    (("2" (skeep)
                      (("2" (lemma "tc_iff_prefix_of_trace")
                        (("2" (inst -1 "rel" "x" "tt")
                          (("2" (case-replace "TC(rel)(x,tt)")
                            (("1" (assert)
                              (("1"
                                (skeep)
                                (("1"
                                  (inst -6 "tr")
                                  (("1"
                                    (assert)
                                    (("1" (inst -2 "0") nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but (-2 1))
                              (("2"
                                (expand "TC")
                                (("2" (flatten) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (boolean nonempty-type-decl nil booleans nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (val adt-accessor-decl "[(some?) -> T]" Maybe structures)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sequence type-eq-decl nil sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (run const-decl "PRED[Trace]" traces nil)
    (normal const-decl "bool" termination nil)
    (Relation type-eq-decl nil termination nil)
    (traces const-decl "bool" traces nil)
    (None adt-constructor-decl "(none?)" Maybe structures)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe structures)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (PRED type-eq-decl nil defined_types nil)
    (TC inductive-decl "bool" relations nil)
    (tc_iff_prefix_of_trace formula-decl nil traces nil))
   shostak))
 (empty_trace_not_run 0
  (empty_trace_not_run-1 nil 3821726326
   ("" (skeep)
    (("" (expand "member")
      (("" (expand "run")
        (("" (flatten)
          (("" (expand "empty_trace") (("" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (empty_trace const-decl "FiniteTrace" traces nil)
    (run const-decl "PRED[Trace]" traces nil))
   shostak))
 (head_of_run_some 0
  (head_of_run_some-1 nil 3821726734
   ("" (skeep*)
    (("" (lemma "empty_trace_not_run")
      (("" (insteep)
        (("" (expand "member")
          (("" (lemma "head_none_empty_trace")
            (("" (inst?) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((empty_trace_not_run formula-decl nil traces nil)
    (member const-decl "bool" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Maybe type-decl nil Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (run const-decl "PRED[Trace]" traces nil)
    (head_none_empty_trace formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (run_all_reachable 0
  (run_all_reachable-1 nil 3821714349
   ("" (skeep)
    (("" (skeep)
      (("" (induct "n")
        (("1" (flatten)
          (("1" (expand "reachable")
            (("1" (flatten)
              (("1" (typepred "tr")
                (("1" (expand "run") (("1" (flatten) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (lemma "some_below")
            (("2" (inst -1 "tr" "j+1" "j")
              (("2" (assert)
                (("2" (expand "reachable" 1)
                  (("2" (flatten)
                    (("2" (inst 2 "val(tr(j))")
                      (("2" (assert)
                        (("2" (typepred "tr")
                          (("2" (expand "run")
                            (("2" (flatten)
                              (("2"
                                (expand "traces")
                                (("2"
                                  (inst -2 "j")
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (traces const-decl "bool" traces nil)
    (some_below formula-decl nil traces nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe structures)
    (reachable inductive-decl "bool" traces nil)
    (run const-decl "PRED[Trace]" traces nil)
    (PRED type-eq-decl nil defined_types nil)
    (Relation type-eq-decl nil termination nil)
    (Trace type-eq-decl nil traces nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (Maybe type-decl nil Maybe structures)
    (T formal-type-decl nil traces nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (reachable_prefix_of_trace_TCC1 0
  (reachable_prefix_of_trace_TCC1-1 nil 3821715690
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil traces nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil)
    (reachable inductive-decl "bool" traces nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Maybe type-decl nil Maybe structures)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (run const-decl "PRED[Trace]" traces nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (normal const-decl "bool" termination nil)
    (traces const-decl "bool" traces nil))
   nil
   (reachable_prefix_of_trace subtype "traces.rn(0)"
    "(Maybe[traces.T].some?)")))
 (reachable_prefix_of_trace_TCC2 0
  (reachable_prefix_of_trace_TCC2-1 nil 3821715690
   ("" (skeep*) (("" (inst? -1) nil nil)) nil)
   ((upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (reachable_prefix_of_trace subtype "traces.rn(traces.n)"
    "(Maybe[traces.T].some?)")))
 (reachable_prefix_of_trace 0
  (reachable_prefix_of_trace-1 nil 3821724570
   ("" (skeep* :preds? t)
    (("" (rewrite "reachable_iff_tc")
      (("" (split)
        (("1" (case "normal(rel)(t)")
          (("1" (inst 1 "single_trace(t)" "0")
            (("1" (expand "single_trace") (("1" (propax) nil nil)) nil)
             ("2" (expand "run")
              (("2" (rewrite "single_iff_normal")
                (("2" (assert)
                  (("2" (expand "single_trace" 1)
                    (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "normal")
            (("2" (skeep -1)
              (("2" (lemma "tc_iff_prefix_of_trace")
                (("2" (inst -1 "rel" "t" "tt")
                  (("2" (case-replace "TC(rel)(t,tt)")
                    (("1" (assert)
                      (("1" (hide -1)
                        (("1" (skeep :preds? t)
                          (("1" (inst 1 "tr" "0")
                            (("1" (assert)
                              (("1"
                                (skeep :preds? t)
                                (("1"
                                  (inst -5 "0")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "run")
                              (("2"
                                (assert)
                                (("2" (inst -4 "0") nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide-all-but (-2 1))
                      (("2" (expand "TC") (("2" (flatten) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (rewrite "tc_iff_prefix_of_trace")
            (("2" (skeep)
              (("2" (inst 1 "tr" "n")
                (("1" (assert) nil nil)
                 ("2" (expand "run")
                  (("2" (assert) (("2" (inst -1 "0") nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((reachable_iff_tc formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil)
    (reachable inductive-decl "bool" traces nil) nil
    (normal const-decl "bool" termination nil)
    (single_iff_normal formula-decl nil traces nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Maybe type-decl nil Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (run const-decl "PRED[Trace]" traces nil) nil nil
    (finite_trace? const-decl "bool" traces nil)
    (FiniteTrace type-eq-decl nil traces nil)
    (single_trace const-decl "FiniteTrace" traces nil) nil
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (traces const-decl "bool" traces nil) nil
    (TC inductive-decl "bool" relations nil)
    (tc_iff_prefix_of_trace formula-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (pos_length_finite_run 0
  (pos_length_finite_run-2 nil 3822259749
   ("" (skeep*)
    (("" (lemma "empty_trace_length")
      (("" (inst -1 "rn")
        (("" (lemma "empty_trace_not_run")
          (("" (expand "member")
            (("" (inst? -1)
              (("" (insteep -1) (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((empty_trace_length formula-decl nil traces nil)
    (empty_trace_not_run formula-decl nil traces nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (run const-decl "PRED[Trace]" traces nil)
    (PRED type-eq-decl nil defined_types nil)
    (Relation type-eq-decl nil termination nil)
    (FiniteTrace type-eq-decl nil traces nil)
    (finite_trace? const-decl "bool" traces nil)
    (Trace type-eq-decl nil traces nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sequence type-eq-decl nil sequences nil)
    (Maybe type-decl nil Maybe structures)
    (T formal-type-decl nil traces nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (normal_form_iff_run_TCC1 0
  (normal_form_iff_run_TCC1-1 nil 3822252066 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil)
    (run const-decl "PRED[Trace]" traces nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (normal const-decl "bool" termination nil)
    (traces const-decl "bool" traces nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (finite_trace? const-decl "bool" traces nil)
    (length const-decl "nat" traces nil))
   nil
   (normal_form_iff_run subtype
    "(number_fields.-)(traces.length(traces.rn), 1)" "nat")))
 (normal_form_iff_run_TCC2 0
  (normal_form_iff_run_TCC2-1 nil 3822252066
   ("" (skeep)
    (("" (rewrite "some_before_length")
      (("" (lemma "pos_length_finite_run")
        (("" (inst?) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (some_before_length formula-decl nil traces nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (finite_trace? const-decl "bool" traces nil)
    (FiniteTrace type-eq-decl nil traces nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil)
    (run const-decl "PRED[Trace]" traces nil)
    (< const-decl "bool" reals nil)
    (length const-decl "nat" traces nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (pos_length_finite_run formula-decl nil traces nil))
   nil
   (normal_form_iff_run subtype
    "traces.rn((number_fields.-)(traces.length(traces.rn), 1))"
    "(Maybe[traces.T].some?)")))
 (normal_form_iff_run 0
  (normal_form_iff_run-1 nil 3822253727
   ("" (skeep*)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "normal_form")
          (("1" (flatten)
            (("1" (lemma "reachable_prefix_of_trace")
              (("1" (inst -1 "rel" "init" "t")
                (("1" (skeep)
                  (("1" (insteep)
                    (("1" (typepred "rn")
                      (("1" (expand "run")
                        (("1" (flatten)
                          (("1" (case "none?(rn(n+1))")
                            (("1" (case "finite_trace?(rn)")
                              (("1"
                                (assert)
                                (("1"
                                  (case "length(rn) = n+1")
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (hide 2)
                                    (("2"
                                      (lemma "length_is_none")
                                      (("2"
                                        (inst?)
                                        (("2"
                                          (lemma "some_before_length")
                                          (("2"
                                            (inst -1 "rn" "n+1")
                                            (("1" (assert) nil nil)
                                             ("2"
                                              (lemma
                                               "none_after_length")
                                              (("2"
                                                (inst -1 "rn" "n")
                                                (("1"
                                                  (inst -9 "n")
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (hide 2)
                                (("2"
                                  (expand "finite_trace?")
                                  (("2" (inst? 1) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide 2)
                              (("2"
                                (expand "traces")
                                (("2"
                                  (insteep -2)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (inst -5 "n")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (expand "normal")
                                          (("2"
                                            (inst 2 "val(rn(1+n))")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "normal_form")
          (("2" (skeep)
            (("2" (lemma "pos_length_finite_run")
              (("2" (inst?)
                (("2" (assert)
                  (("2" (lemma "some_before_length")
                    (("2" (inst -1 "rn" "length(rn)-1")
                      (("2" (lemma "run_all_reachable")
                        (("2" (inst?)
                          (("2" (assert)
                            (("2" (lemma "last_of_finite_is_normal")
                              (("2"
                                (inst -1 "rel" "rn")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (run_all_reachable formula-decl nil traces nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (last_of_finite_is_normal formula-decl nil traces nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pos_length_finite_run formula-decl nil traces nil)
    (t skolem-const-decl "T" traces nil)
    (init skolem-const-decl "PRED[T]" traces nil)
    (rel skolem-const-decl "Relation[T]" traces nil)
    (reachable inductive-decl "bool" traces nil)
    (PRED type-eq-decl nil defined_types nil)
    (Relation type-eq-decl nil termination nil)
    (T formal-type-decl nil traces nil)
    (run const-decl "PRED[Trace]" traces nil)
    (Trace type-eq-decl nil traces nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sequence type-eq-decl nil sequences nil)
    (Maybe type-decl nil Maybe structures)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (n skolem-const-decl "nat" traces nil)
    (rn skolem-const-decl "(run(rel)(init))" traces nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (none_after_length formula-decl nil traces nil)
    (some_before_length formula-decl nil traces nil)
    (length_is_none formula-decl nil traces nil)
    (length const-decl "nat" traces nil)
    (FiniteTrace type-eq-decl nil traces nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_trace? const-decl "bool" traces nil)
    (traces const-decl "bool" traces nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe structures)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (normal const-decl "bool" termination nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (reachable_prefix_of_trace formula-decl nil traces nil)
    (normal_form const-decl "bool" traces nil))
   shostak))
 (invariant_run_rule 0
  (invariant_run_rule-1 nil 3821727494
   ("" (skeep*)
    (("" (expand "invariant_run")
      (("" (induct "n")
        (("1" (skeep)
          (("1" (insteep)
            (("1" (flatten) (("1" (assert) nil nil)) nil)) nil))
          nil)
         ("2" (skeep*)
          (("2" (insteep -1)
            (("2" (lemma "some_below")
              (("2" (inst -1 "rn" "j+1" "j")
                (("2" (assert)
                  (("2" (insteep)
                    (("2" (flatten)
                      (("2" (inst -5 "j") (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((invariant_run const-decl "bool" traces nil)
    (some_below formula-decl nil traces nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe structures)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (run const-decl "PRED[Trace]" traces nil)
    (PRED type-eq-decl nil defined_types nil)
    (Relation type-eq-decl nil termination nil)
    (Trace type-eq-decl nil traces nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sequence type-eq-decl nil sequences nil)
    (Maybe type-decl nil Maybe structures)
    (T formal-type-decl nil traces nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (invariant_is_invariant_run 0
  (invariant_is_invariant_run-1 nil 3821730998
   ("" (skeep)
    (("" (expand "invariant_run")
      (("" (expand "invariant")
        (("" (split)
          (("1" (flatten)
            (("1" (skeep :preds? t)
              (("1" (inst? -4)
                (("1" (lemma "run_all_reachable")
                  (("1" (inst -1 "rel" "init" "rn" "n")
                    (("1" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (skeep :preds? t)
              (("2" (lemma "reachable_prefix_of_trace")
                (("2" (insteep)
                  (("2" (skeep)
                    (("2" (inst -5 "rn" "n")
                      (("2" (inst -1 "n") (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((invariant_run const-decl "bool" traces nil)
    (run_all_reachable formula-decl nil traces nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil nil nil nil (run const-decl "PRED[Trace]" traces nil)
    (Trace type-eq-decl nil traces nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sequence type-eq-decl nil sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe structures)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (Maybe type-decl nil Maybe structures)
    (reachable inductive-decl "bool" traces nil)
    (PRED type-eq-decl nil defined_types nil)
    (Relation type-eq-decl nil termination nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil traces nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (reachable_prefix_of_trace formula-decl nil traces nil)
    (invariant const-decl "bool" traces nil))
   nil)))

