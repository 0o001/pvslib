(traces
 (reachable_empty 0
  (reachable_empty-1 nil 3821351824
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "empty?" 1)
          (("1" (skeep)
            (("1" (expand "member")
              (("1" (lemma "reachable_weak_induction")
                (("1" (inst?)
                  (("1" (inst -1 "LAMBDA(t:T): NOT empty?(init)")
                    (("1" (split)
                      (("1" (inst -1 "x") (("1" (assert) nil nil)) nil)
                       ("2" (skeep)
                        (("2" (split)
                          (("1" (expand "empty?")
                            (("1" (expand "member")
                              (("1" (inst -2 "t_1") nil nil)) nil))
                            nil)
                           ("2" (skeep) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "empty?")
          (("2" (skeep)
            (("2" (insteep)
              (("2" (expand "member")
                (("2" (expand "reachable") (("2" (flatten) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (reachable_weak_induction formula-decl nil traces nil)
    (reachable inductive-decl "bool" traces nil))
   shostak))
 (invariant_rule 0
  (invariant_rule-1 nil 3821297502
   ("" (skeep)
    (("" (lemma "reachable_induction")
      (("" (expand "invariant")
        (("" (inst -1 "rel" "init" "inv")
          (("" (split -1)
            (("1" (skeep)
              (("1" (insteep) (("1" (assert) nil nil)) nil)) nil)
             ("2" (hide 2)
              (("2" (skeep)
                (("2" (inst -2 "t")
                  (("2" (assert)
                    (("2" (skeep)
                      (("2" (inst -4 "tp" "t") (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((reachable_induction formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil)
    (reachable inductive-decl "bool" traces nil)
    (invariant const-decl "bool" traces nil))
   shostak))
 (reachable_tc 0
  (reachable_tc-1 nil 3821476787
   ("" (skeep*)
    (("" (lemma "TC_weak_induction")
      (("" (inst -1 "rel" _)
        ((""
          (inst -1
           "LAMBDA(x,y:T):reachable(rel)(init)(x) IMPLIES reachable(rel)(init)(y)")
          (("" (split)
            (("1" (inst?) (("1" (assert) nil nil)) nil)
             ("2" (hide-all-but 1)
              (("2" (skeep)
                (("2" (split -1)
                  (("1" (expand "reachable" 1)
                    (("1" (flatten)
                      (("1" (inst? 2) (("1" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (skeep) (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TC_weak_induction formula-decl nil relations nil)
    (T formal-type-decl nil traces nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (reachable inductive-decl "bool" traces nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (reachable_iff_tc 0
  (reachable_iff_tc-1 nil 3821466405
   ("" (skeep)
    ((""
      (case "FORALL (t: T): reachable(rel)(init)(t) IMPLIES init(t) OR EXISTS (tt: (init)): TC(rel)(tt, t)")
      (("1"
        (case "FORALL (t: T): (init(t) OR EXISTS (tt: (init)): TC(rel)(tt, t)) IMPLIES reachable(rel)(init)(t)")
        (("1" (skeep)
          (("1" (insteep)
            (("1" (insteep) (("1" (ground) nil nil)) nil)) nil))
          nil)
         ("2" (hide-all-but 1)
          (("2" (skeep)
            (("2" (expand "reachable")
              (("2" (flatten)
                (("2" (assert)
                  (("2" (skeep -1)
                    (("2" (lemma "TC_induction")
                      (("2" (inst -1 "rel" _)
                        (("2"
                          (inst -1
                           "LAMBDA(t1,t2:T): init(t1) IMPLIES reachable(rel)(init)(t2)")
                          (("2" (split -1)
                            (("1" (inst? -1)
                              (("1"
                                (assert)
                                (("1"
                                  (expand "reachable" -1)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but 1)
                              (("2"
                                (skeep)
                                (("2"
                                  (split -1)
                                  (("1"
                                    (expand "reachable")
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (inst 2 "x")
                                        (("1"
                                          (expand "reachable")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (skeep)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (lemma "reachable_tc")
                                        (("2"
                                          (inst
                                           -1
                                           "rel"
                                           "init"
                                           "z"
                                           "y")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (rule-induct "reachable")
          (("2" (skeep)
            (("2" (assert)
              (("2" (skeep -1)
                (("2" (split -1)
                  (("1" (inst 2 "tp")
                    (("1" (expand "TC") (("1" (flatten) nil nil)) nil))
                    nil)
                   ("2" (skeep)
                    (("2" (insteep)
                      (("2" (expand "TC" 2)
                        (("2" (flatten)
                          (("2" (inst 3 "tp")
                            (("2" (assert)
                              (("2"
                                (expand "TC" 3)
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TC inductive-decl "bool" relations nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (reachable inductive-decl "bool" traces nil)
    (PRED type-eq-decl nil defined_types nil)
    (Relation type-eq-decl nil termination nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil traces nil)
    (TC_induction formula-decl nil relations nil)
    (reachable_tc formula-decl nil traces nil)
    (reachable_weak_induction formula-decl nil traces nil))
   shostak))
 (normalizing_reachable 0
  (normalizing_reachable-1 nil 3821620584
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "normalizing")
          (("1" (expand "empty?")
            (("1" (expand "member")
              (("1" (skeep)
                (("1" (inst -2 "0")
                  (("1" (lemma "reachable_iff_tc")
                    (("1" (inst?)
                      (("1" (assert)
                        (("1" (split -1)
                          (("1" (insteep) nil nil)
                           ("2" (skeep :preds? t)
                            (("2" (rewrite "iterate_n_tc")
                              (("2"
                                (skeep)
                                (("2"
                                  (rewrite "iterate_n_fseq")
                                  (("2"
                                    (skeep)
                                    (("2"
                                      (inst
                                       -4
                                       "LAMBDA(i:nat): IF i <= n THEN fseq(i) ELSE x(i-n) ENDIF")
                                      (("1" (assert) nil nil)
                                       ("2"
                                        (expand "ascending?")
                                        (("2"
                                          (skeep)
                                          (("2"
                                            (case "n_1 < n")
                                            (("1"
                                              (assert)
                                              (("1"
                                                (typepred "fseq")
                                                (("1"
                                                  (expand
                                                   "ascending_n?")
                                                  (("1"
                                                    (inst?)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (case-replace "n_1=n")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (replaces -4)
                                                  (("1"
                                                    (typepred "x")
                                                    (("1"
                                                      (expand
                                                       "ascending?")
                                                      (("1"
                                                        (inst?)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (typepred "x")
                                                  (("2"
                                                    (expand
                                                     "ascending?")
                                                    (("2"
                                                      (inst? -1)
                                                      (("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3"
                                        (hide-all-but 1)
                                        (("3" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "normalizing")
          (("2" (expand "empty?")
            (("2" (skeep)
              (("2" (insteep)
                (("2" (expand "member")
                  (("2" (induct "i")
                    (("1" (expand "reachable")
                      (("1" (flatten) nil nil)) nil)
                     ("2" (skeep)
                      (("2" (expand "reachable" 1)
                        (("2" (flatten)
                          (("2" (inst 2 "x(j)")
                            (("2" (assert)
                              (("2"
                                (typepred "x")
                                (("2"
                                  (expand "ascending?")
                                  (("2" (inst?) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((normalizing const-decl "bool" traces nil)
    (member const-decl "bool" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil traces nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil)
    (sequence type-eq-decl nil sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (ascending? const-decl "bool" monotone_sequences nil)
    (iterate_n_tc formula-decl nil relation_iterate nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (iterate_n_fseq formula-decl nil monotone_sequences nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ascending_n? const-decl "bool" monotone_sequences nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (TRUE const-decl "bool" booleans nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (reachable_iff_tc formula-decl nil traces nil)
    (empty? const-decl "bool" sets nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (reachable inductive-decl "bool" traces nil))
   shostak))
 (terminating_is_normalizing 0
  (terminating_is_normalizing-1 nil 3821552597
   ("" (decompose-equality)
    (("" (rewrite "terminating_no_ascending_seq")
      (("" (expand "normalizing")
        (("" (expand "empty?")
          (("" (expand "member")
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (skeep)
                    (("1" (insteep)
                      (("1" (typepred "x") (("1" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (skeep) (("2" (insteep) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((terminating_no_ascending_seq formula-decl nil termination nil)
    (empty? const-decl "bool" sets nil)
    (ascending? const-decl "bool" monotone_sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (sequence type-eq-decl nil sequences nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (normalizing const-decl "bool" traces nil)
    (PRED type-eq-decl nil defined_types nil)
    (terminating const-decl "bool" termination nil)
    (Relation type-eq-decl nil termination nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   nil))
 (normalizing_is_terminating 0
  (normalizing_is_terminating-1 nil 3821653539
   ("" (skeep)
    (("" (rewrite "normalizing_reachable")
      (("" (rewrite "terminating_no_ascending_seq")
        (("" (expand "empty?")
          (("" (expand "member")
            (("" (split)
              (("1" (flatten)
                (("1" (skeep)
                  (("1" (insteep)
                    (("1" (expand "ascending?")
                      (("1" (skeep)
                        (("1" (inst -1 "i") (("1" (flatten) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "ascending?")
                      (("2" (skeep)
                        (("2" (insteep) (("2" (flatten) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (skeep)
                  (("2" (insteep)
                    (("2" (expand "ascending?")
                      (("2" (skeep)
                        (("2" (inst -1 "n")
                          (("2" (assert)
                            (("2" (typepred "x")
                              (("2"
                                (expand "ascending?")
                                (("2" (insteep) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((terminating_no_ascending_seq formula-decl nil termination nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (reachable inductive-decl "bool" traces nil)
    (member const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sequence type-eq-decl nil sequences nil)
    (ascending? const-decl "bool" monotone_sequences nil)
    (empty? const-decl "bool" sets nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (normalizing_reachable formula-decl nil traces nil))
   shostak))
 (normalizing_reachable_normalizable 0
  (normalizing_reachable_normalizable-1 nil 3821706091
   ("" (skeep*)
    (("" (typepred "rel")
      (("" (rewrite "normalizing_is_terminating")
        (("" (lemma "terminating_is_weakly_terminating")
          ((""
            (inst -1
             "LAMBDA (t1, t2: T):reachable(rel)(init)(t1) AND rel(t1, t2)")
            (("" (expand "weakly_terminating")
              (("" (insteep)
                (("" (expand "normalizable")
                  (("" (split -1)
                    (("1" (expand "normal") (("1" (flatten) nil nil))
                      nil)
                     ("2" (skeep :preds? t)
                      (("2" (typepred "t")
                        (("2" (case "TC(rel)(t,nft)")
                          (("1" (insteep)
                            (("1" (hide -4 -5 2)
                              (("1"
                                (expand "normal")
                                (("1"
                                  (skeep)
                                  (("1"
                                    (insteep)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (lemma "reachable_tc")
                                        (("1"
                                          (inst
                                           -1
                                           "rel"
                                           "init"
                                           "t"
                                           "nft")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but (-1 -3 1))
                            (("2" (rewrite "iterate_n_tc")
                              (("2"
                                (rewrite "iterate_n_tc")
                                (("2"
                                  (skeep)
                                  (("2"
                                    (insteep)
                                    (("2"
                                      (rewrite "iterate_n_fseq")
                                      (("2"
                                        (rewrite "iterate_n_fseq")
                                        (("2"
                                          (skeep)
                                          (("2"
                                            (insteep)
                                            (("1" (assert) nil nil)
                                             ("2"
                                              (typepred "fseq")
                                              (("2"
                                                (expand "ascending_n?")
                                                (("2"
                                                  (skeep)
                                                  (("2"
                                                    (insteep)
                                                    (("2"
                                                      (flatten)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((normalizing const-decl "bool" traces nil)
    (Relation type-eq-decl nil termination nil)
    (PRED type-eq-decl nil defined_types nil)
    (T formal-type-decl nil traces nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (terminating_is_weakly_terminating formula-decl nil termination
     nil)
    (weakly_terminating const-decl "bool" termination nil)
    (normalizable const-decl "bool" termination nil)
    (TC inductive-decl "bool" relations nil)
    (reachable_tc formula-decl nil traces nil) nil
    (pred type-eq-decl nil defined_types nil)
    (iterate_n_tc formula-decl nil relation_iterate nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (iterate_n_fseq formula-decl nil monotone_sequences nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ascending_n? const-decl "bool" monotone_sequences nil) nil nil
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (normal const-decl "bool" termination nil)
    (terminating const-decl "bool" termination nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (reachable inductive-decl "bool" traces nil) nil nil
    (normalizing_is_terminating formula-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (none_forever 0
  (none_forever-1 nil 3821301708
   ("" (skeep :but "j")
    (("" (case "FORALL (n:nat): none?(tr(i)) IMPLIES none?(tr(i+n))")
      (("1" (skeep)
        (("1" (inst -1 "j-i") (("1" (assert) nil nil)) nil)) nil)
       ("2" (hide 2)
        (("2" (induct "n")
          (("1" (flatten) (("1" (assert) nil nil)) nil)
           ("2" (skeep)
            (("2" (assert)
              (("2" (typepred "tr")
                (("2" (inst -1 "i+j") (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil))
   shostak))
 (length_TCC1 0
  (length_TCC1-1 nil 3821301700 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (finite_trace? const-decl "bool" traces nil)
    (FiniteTrace type-eq-decl nil traces nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   nil
   (length subtype
           "{n: naturalnumbers.nat | Maybe[traces.T].none?(traces.ftr(n))}"
           "(sets[nat].nonempty?)")))
 (none_after_length 0
  (none_after_length-1 nil 3821302445
   ("" (skeep :preds? t)
    (("" (expand "length")
      (("" (name-label "mm" "min({n: nat | none?(ftr(n))})")
        (("" (typepred "mm")
          (("" (lemma "none_forever")
            (("" (inst -1 "ftr" "mm" "i") (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((FiniteTrace type-eq-decl nil traces nil)
    (finite_trace? const-decl "bool" traces nil)
    (Trace type-eq-decl nil traces nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sequence type-eq-decl nil sequences nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (Maybe type-decl nil Maybe structures)
    (T formal-type-decl nil traces nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
         min_nat nil)
    (none_forever formula-decl nil traces nil)
    (mm skolem-const-decl
     "{a | none?(ftr(a)) AND FORALL (x: nat): none?(ftr(x)) IMPLIES a <= x}"
     traces nil)
    (i skolem-const-decl "upfrom(length(ftr))" traces nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (ftr skolem-const-decl "FiniteTrace" traces nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length const-decl "nat" traces nil))
   shostak))
 (length_is_none 0
  (length_is_none-1 nil 3821303019
   ("" (skeep)
    (("" (lemma "none_after_length") (("" (inst?) nil nil)) nil)) nil)
   ((upfrom nonempty-type-eq-decl nil integers nil)
    (length const-decl "nat" traces nil)
    (FiniteTrace type-eq-decl nil traces nil)
    (finite_trace? const-decl "bool" traces nil)
    (Trace type-eq-decl nil traces nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sequence type-eq-decl nil sequences nil)
    (Maybe type-decl nil Maybe structures)
    (T formal-type-decl nil traces nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (none_after_length formula-decl nil traces nil))
   shostak))
 (empty_trace_TCC1 0
  (empty_trace_TCC1-1 nil 3821352934 ("" (subtype-tcc) nil nil)
   ((finite_trace? const-decl "bool" traces nil)) nil
   (empty_trace subtype
    "LAMBDA (i: naturalnumbers.nat): Maybe[traces.T].None"
    "FiniteTrace")))
 (empty_trace_length 0
  (empty_trace_length-1 nil 3821352966
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (decompose-equality)
          (("1" (expand "empty_trace")
            (("1" (lemma "none_after_length")
              (("1" (inst?) (("1" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (replaces -1)
          (("2" (grind)
            (("2" (with-tccs (typepred "min({n: nat | TRUE})"))
              (("2" (inst -1 "0") (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
         min_nat nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (length const-decl "nat" traces nil)
    (none_after_length formula-decl nil traces nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (empty_trace const-decl "FiniteTrace" traces nil)
    (FiniteTrace type-eq-decl nil traces nil)
    (finite_trace? const-decl "bool" traces nil)
    (Trace type-eq-decl nil traces nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   shostak))
 (empty_trace_lenght_eq_0 0
  (empty_trace_lenght_eq_0-1 nil 3821352941
   ("" (lemma "empty_trace_length")
    (("" (inst?) (("" (assert) nil nil)) nil)) nil)
   ((empty_trace_length formula-decl nil traces nil)
    (empty_trace const-decl "FiniteTrace" traces nil)
    (FiniteTrace type-eq-decl nil traces nil)
    (finite_trace? const-decl "bool" traces nil)
    (Trace type-eq-decl nil traces nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sequence type-eq-decl nil sequences nil)
    (Maybe type-decl nil Maybe structures)
    (T formal-type-decl nil traces nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (traces_TCC1 0
  (traces_TCC1-1 nil 3821301700 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (traces subtype "traces.tr(traces.n)" "(Maybe[traces.T].some?)")))
 (traces_TCC2 0
  (traces_TCC2-1 nil 3821301700 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil traces nil)
    (Maybe type-decl nil Maybe structures)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (sequence type-eq-decl nil sequences nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Trace type-eq-decl nil traces nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (traces subtype "traces.tr(traces.n)" "(Maybe[traces.T].some?)")))
 (tc_iff_prefix_of_trace_TCC1 0
  (tc_iff_prefix_of_trace_TCC1-1 nil 3821525849
   ("" (skeep) (("" (inst? -1) nil nil)) nil)
   ((upto nonempty-type-eq-decl nil naturalnumbers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (tc_iff_prefix_of_trace subtype "traces.tr(0)"
    "(Maybe[traces.T].some?)")))
 (tc_iff_prefix_of_trace_TCC2 0
  (tc_iff_prefix_of_trace_TCC2-1 nil 3821525849
   ("" (skeep) (("" (inst? -1) nil nil)) nil)
   ((upto nonempty-type-eq-decl nil naturalnumbers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (tc_iff_prefix_of_trace subtype "traces.tr(traces.n)"
    "(Maybe[traces.T].some?)")))
 (tc_iff_prefix_of_trace 0
  (tc_iff_prefix_of_trace-1 nil 3821525900
   ("" (skeep*)
    (("" (split)
      (("1" (flatten)
        (("1" (rewrite "iterate_n_tc")
          (("1" (skeep)
            (("1" (rewrite "iterate_n_fseq")
              (("1" (skeep)
                (("1" (typepred "fseq")
                  (("1" (expand "ascending_n?")
                    (("1" (case "normalizing(LAMBDA(t:T):t=t2)(rel)")
                      (("1"
                        (lemma "normalizing_reachable_normalizable")
                        (("1" (inst -1 "LAMBDA(t:T):t=t2" "rel" "t2")
                          (("1" (expand "normalizable")
                            (("1" (split -1)
                              (("1"
                                (inst
                                 1
                                 "LAMBDA(i:nat): IF i <= n THEN Some(fseq(i)) ELSE None ENDIF"
                                 "n")
                                (("1" (assert) nil nil)
                                 ("2"
                                  (split)
                                  (("1"
                                    (skeep)
                                    (("1"
                                      (case-replace "i_1 <= n")
                                      (("1" (assert) nil nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand "traces")
                                    (("2"
                                      (skeep)
                                      (("2"
                                        (case "n_1 < n")
                                        (("1"
                                          (assert)
                                          (("1" (inst? -4) nil nil))
                                          nil)
                                         ("2"
                                          (assert)
                                          (("2"
                                            (case-replace "n_1 = n")
                                            (("1" (assert) nil nil)
                                             ("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (skeep)
                                (("2"
                                  (rewrite "iterate_n_tc")
                                  (("2"
                                    (skolem -1 "nn")
                                    (("2"
                                      (rewrite "iterate_n_fseq")
                                      (("2"
                                        (skolem -1 "ffseq")
                                        (("2"
                                          (flatten)
                                          (("2"
                                            (typepred "nft")
                                            (("2"
                                              (typepred "ffseq")
                                              (("2"
                                                (expand "ascending_n?")
                                                (("2"
                                                  (inst
                                                   1
                                                   "LAMBDA(i:nat): IF i <= n THEN Some(fseq(i)) ELSIF i <= n+nn THEN Some(ffseq(i-n)) ELSE None ENDIF"
                                                   "n")
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (split)
                                                    (("1"
                                                      (skeep)
                                                      (("1"
                                                        (case-replace
                                                         "i_1 <= n")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (assert)
                                                          (("2"
                                                            (case-replace
                                                             "i_1 <= n + nn")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (expand "traces")
                                                      (("2"
                                                        (skeep)
                                                        (("2"
                                                          (case
                                                           "n_1 < n")
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (inst?
                                                               -7)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (case-replace
                                                             "n_1=n")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (inst
                                                                 -2
                                                                 "0")
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              (("2"
                                                                (case-replace
                                                                 "n_1 <= n+nn")
                                                                (("1"
                                                                  (split
                                                                   4)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (case-replace
                                                                       "1 + n_1 <= n + nn")
                                                                      (("1"
                                                                        (inst
                                                                         -4
                                                                         "n_1-n")
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil)
                                                                         ("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (hide-all-but 1)
                                                    (("3"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but 1)
                            (("2" (expand "reachable")
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "normalizing")
                        (("2" (expand "empty?")
                          (("2" (expand "member")
                            (("2" (skeep :preds? t)
                              (("2"
                                (expand "ascending?")
                                (("2"
                                  (inst
                                   1
                                   "LAMBDA(i:nat): IF i <= n THEN Some(fseq(i)) ELSE Some(x(i-n)) ENDIF"
                                   "n")
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (split)
                                    (("1"
                                      (skeep)
                                      (("1"
                                        (lift-if)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand "traces")
                                      (("2"
                                        (skeep)
                                        (("2"
                                          (hide 1)
                                          (("2"
                                            (case "n_1 < n")
                                            (("1"
                                              (assert)
                                              (("1"
                                                (inst? -4)
                                                nil
                                                nil))
                                              nil)
                                             ("2"
                                              (case-replace "n_1 = n")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (inst -2 "0")
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (inst -1 "n_1-n")
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (hide-all-but 1)
                                    (("3" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (skeep)
          (("2" (typepred "tr")
            (("2" (expand "traces")
              (("2" (rewrite "iterate_n_tc")
                (("2" (insteep)
                  (("2" (rewrite "iterate_n_fseq")
                    (("2" (inst 1 "LAMBDA(i:upto(n)):val(tr(i))")
                      (("1" (assert) nil nil)
                       ("2" (expand "ascending_n?")
                        (("2" (skeep :preds? t)
                          (("2" (inst -3 "i_1")
                            (("2" (split -3)
                              (("1"
                                (inst -4 "i_1")
                                (("1" (assert) nil nil))
                                nil)
                               ("2" (flatten) nil nil)
                               ("3"
                                (flatten)
                                (("3"
                                  (inst -4 "i_1+1")
                                  (("3" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe structures)
    (n skolem-const-decl "posnat" traces nil)
    (tr skolem-const-decl "(traces(rel))" traces nil)
    (member const-decl "bool" sets nil)
    (ascending? const-decl "bool" monotone_sequences nil)
    (x skolem-const-decl "(ascending?(rel))" traces nil)
    (empty? const-decl "bool" sets nil)
    (normalizing_reachable_normalizable formula-decl nil traces nil)
    (normalizable const-decl "bool" termination nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (n_1 skolem-const-decl "nat" traces nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (ffseq skolem-const-decl "(ascending_n?(nn)(rel))" traces nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nn skolem-const-decl "posnat" traces nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (normal const-decl "bool" termination nil)
    (traces const-decl "bool" traces nil)
    (Trace type-eq-decl nil traces nil)
    (sequence type-eq-decl nil sequences nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (None adt-constructor-decl "(none?)" Maybe structures)
    (fseq skolem-const-decl "(ascending_n?(n)(rel))" traces nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe structures)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (n skolem-const-decl "posnat" traces nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures)
    (Maybe type-decl nil Maybe structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (reachable inductive-decl "bool" traces nil)
    (rel skolem-const-decl "Relation[T]" traces nil)
    (t2 skolem-const-decl "T" traces nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (normalizing const-decl "bool" traces nil)
    (PRED type-eq-decl nil defined_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ascending_n? const-decl "bool" monotone_sequences nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (iterate_n_fseq formula-decl nil monotone_sequences nil)
    (T formal-type-decl nil traces nil)
    (Relation type-eq-decl nil termination nil)
    (pred type-eq-decl nil defined_types nil)
    (iterate_n_tc formula-decl nil relation_iterate nil))
   shostak))
 (run_empty 0
  (run_empty-1 nil 3821478499
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "empty?")
          (("1" (skeep :preds? t)
            (("1" (expand "member")
              (("1" (expand "run")
                (("1" (flatten) (("1" (inst? -3) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "empty?")
          (("2" (skeep)
            (("2" (expand "member")
              (("2" (expand "run") (("2" (postpone) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)))

