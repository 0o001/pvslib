traces[T:TYPE] : THEORY
BEGIN

  IMPORTING termination[T]

  rel  : VAR Relation
  init : VAR PRED[T]
  inv  : VAR PRED[T]

  reachable(rel)(init)(t:T) : INDUCTIVE bool =
    init(t) OR
    EXISTS (tp:T) : reachable(rel)(init)(tp) AND rel(tp,t)

  reachable_empty : LEMMA
    empty?(init) IFF empty?(reachable(rel)(init))

  invariant(rel)(init)(inv) : bool =
    FORALL (t:(reachable(rel)(init))) : inv(t)

  invariant_rule : THEOREM
    FORALL (rel,init,inv) :
      ((FORALL (t0:(init)) : inv(t0)) AND
       (FORALL (t1:(reachable(rel)(init)))(t2:T):
         rel(t1,t2) AND inv(t1) IMPLIES inv(t2)))
      IMPLIES
        invariant(rel)(init)(inv)

  reachable_tc : LEMMA
    FORALL (rel,init)(t1,t2:T):
      reachable(rel)(init)(t1) AND TC(rel)(t1,t2) IMPLIES
      reachable(rel)(init)(t2)

  reachable_iff_tc : LEMMA
    FORALL (rel,init)(t:T):
      reachable(rel)(init)(t) IFF
      (init(t) OR EXISTS (tt:(init)): TC(rel)(tt,t))

  % Relation is normalizing starting from init
  normalizing(init:PRED[T])(rel) : bool =
    empty?({seq:(ascending?(rel)) | init(seq(0))})

  normalizing_reachable : LEMMA
    normalizing(init)(rel) IFF
    empty?({seq:(ascending?(rel)) | FORALL (i:nat): reachable(rel)(init)(seq(i))})

  terminating_is_normalizing : LEMMA
    terminating = normalizing(LAMBDA(t:T):TRUE)

  normalizing_is_terminating : LEMMA
    normalizing(init)(rel) IFF
    terminating(LAMBDA(t1,t2:T):reachable(rel)(init)(t1) AND rel(t1,t2))

  normalizing_reachable_normalizable : LEMMA
    FORALL (init)(rel:(normalizing(init)))(t:(reachable(rel)(init))):
      normalizable(rel)(t) 

  IMPORTING structures@Maybe

  % A trace is an infinite sequence of values or none, such that
  % if one if none, all the rest are nones.
  Trace : TYPE = { seq: sequence[Maybe[T]] |
    FORALL (i:nat) : none?(seq(i)) IMPLIES none?(seq(i+1)) }

  none_above : LEMMA
    FORALL (tr:Trace,i:nat,j:upfrom(i)) :
      none?(tr(i)) IMPLIES none?(tr(j))

  some_below : LEMMA
    FORALL (tr:Trace,i:nat,j:upto(i)) :
      some?(tr(i)) IMPLIES some?(tr(j))

  % Trace is finite if at some point is none
  finite_trace?(tr:Trace) : bool =
    EXISTS (n:nat) : none?(tr(n))

  FiniteTrace : TYPE = (finite_trace?)

  length(ftr:FiniteTrace) : nat =
    min( {n :nat | none?(ftr(n))} )

  none_after_length : LEMMA
    FORALL (ftr:FiniteTrace, i:upfrom(length(ftr))) :
      none?(ftr(i))

  length_is_none : LEMMA
     FORALL (ftr:FiniteTrace) :
       none?(ftr(length(ftr)))

  empty_trace : FiniteTrace = LAMBDA (i:nat) : None

  empty_trace_length : LEMMA
    FORALL (ftr:FiniteTrace) :
      length(ftr) = 0 IFF ftr = empty_trace 

  empty_trace_lenght_eq_0 : LEMMA
    length(empty_trace) = 0

  % Trace of a relation 
  traces(rel)(tr:Trace) : bool =
    FORALL (n:nat) :
      none?(tr(n)) OR 
      IF some?(tr(n+1)) THEN rel(val(tr(n)),val(tr(n+1)))
      ELSE normal(rel)(val(tr(n)))
      ENDIF
  
  tc_iff_prefix_of_trace : LEMMA
    FORALL(rel)(t1,t2:T):
      TC(rel)(t1,t2) IFF
      (EXISTS (tr:(traces(rel)),n:posnat):
        (FORALL (i:upto(n)): some?(tr(i))) AND
        val(tr(0)) = t1 AND
        val(tr(n)) = t2)       

  % Run is a trace from an initial set
  run(rel)(init) : PRED[Trace] =
    { tr:Trace | traces(rel)(tr) AND some?(tr(0)) AND init(val(tr(0))) }

  run_empty : LEMMA
    empty?(init) IFF empty?(run(rel)(init))

  run_all_reachable : LEMMA
    FORALL (rel,init)(tr:(run(rel)(init)))(n:nat) : some?(tr(n)) IMPLIES
      reachable(rel)(init)(val(tr(n)))

  reachable_prefix_of_trace : LEMMA
    FORALL (rel,init)(t:(reachable(rel)(init))):
      (EXISTS (rn:(run(rel)(init)), n:nat):
        (FORALL (i:upto(n)): some?(rn(i))) AND
         init(val(rn(0))) AND
         val(rn(n)) = t)   
       
  invariant_run(rel)(init)(inv) : bool =
    FORALL (tr : (run(rel)(init)), n:nat ): some?(tr(n)) IMPLIES inv(val(tr(n)))

  %invariant_run : THEOREM
  %  FORALL (rel,initial,p):
  %    (FORALL (seq : (run(rel)(initial))) :
  %     p(seq(0)) AND 
  %     FORALL (n : nat) : p(seq(n)) IMPLIES p(seq(n+1)))
  %    IMPLIES invariant(rel)(initial)(p)

END traces
