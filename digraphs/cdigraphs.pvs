%------------------------------------------------------------------------
%
% This theory defines a computational representation of digraphs
%
%            Mariano Moscato (NIA) 2015
%------------------------------------------------------------------------
cdigraphs[T: TYPE]: THEORY 
BEGIN
  IMPORTING structures@more_list_props,
  	    structures@permutations_list,
            digraphs[T],
            structures@set_as_list[T],
            finite_sets@finite_cross,
            structures@set_as_list_props[T]

  ComputableDigraph: TYPE = [# data: list[T],
  	    	               adjs: list[list[nat]] #]  

  size(cd:ComputableDigraph): nat = length(data(cd))

  list_of_idxs(C:ComputableDigraph)(l:list[nat]): bool = 
    FORALL(i:below(length(l))):nth(l,i)<size(C)


  loi_append: LEMMA FORALL(C:ComputableDigraph, l1,l2: list[nat]):
   list_of_idxs(C)(l1) AND 
   list_of_idxs(C)(l2) 
   IMPLIES list_of_idxs(C)(append(l1,l2)) 

  loi_permutation: LEMMA
   FORALL(C:ComputableDigraph, l1: list[nat], l2: (permutation_list(l1))):
    list_of_idxs(C)(l1) IMPLIES list_of_idxs(C)(l2)

  cdigraph(g: ComputableDigraph): bool = 
    (length(data(g)) = length(adjs(g))) AND
    (FORALL(i:below(length(adjs(g)))): list_of_idxs(g)(nth(adjs(g),i))) AND
    no_repetitions?[T](data(g))
     % (this following restriction assures that no multiple edges
     %  are present in the computable representation.)
    AND FORALL(i:below(length(adjs(g)))): no_repetitions?[nat](nth(adjs(g),i))

  cd,cd1,cd2: VAR (cdigraph)

  empty?(cd): bool = length(data(cd)) = 0

  G: VAR digraph

  % --------------------------------------------------------------------------- %
  % Semantic equivalence between computable digraphs.                           %
  % --------------------------------------------------------------------------- %
  % Two computable (representations of) digraphs are semantically equivalent if
  % they consist of the same collection of vertices, linked in the same way.
  % Note that this concept is weaker than the equality.
  sem_eq(cd1,cd2): bool =
    permutation?(data(cd1), data(cd2)) AND
    FORALL(i:below(length(data(cd1)))):
      LET adjs_i_cd1 = nth(adjs(cd1),i), 
      	  adjs_i_cd2 = nth(adjs(cd2),idx(data(cd2), nth(data(cd1),i))) 
      IN permutation?(filter_idxs(data(cd1),adjs_i_cd1), filter_idxs(data(cd2), adjs_i_cd2))

  % --------------------------------------------------------------------------- %
  % Equivalence between computable and non-computable digraphs.                 %
  % --------------------------------------------------------------------------- %

  % Equivalence predicate

  % Two digraph representations are equivalent if
  eq(G,cd): bool = 
    % 1) they have the same collection of vertices
    set_as_list.list2set(data(cd)) = vert(G) AND
    % 2) linked in the same way
    FORALL(i:below(length(data(cd)))):
     (FORALL(j:below(length(data(cd)))): 
       member(j, nth(adjs(cd),i)) 
       IFF LET vi = nth(data(cd),i), vj = nth(data(cd),j) 
       	   IN member((vi,vj), edges(G)))

  cdigraph_eq(G): TYPE = {C: (cdigraph)|eq(G,C)}
  digraph_eq(cd): TYPE = {G: digraph | eq(G,cd)}

  % Conversion functions
  to_digraph(cd): digraph_eq(cd) =
    (# vert := {v:T|EXISTS(i:below(size(cd))):nth(data(cd),i)=v},
       edges := {u,v:T|EXISTS(i,j:below(size(cd))):
	                nth(data(cd),i)=u AND 
			nth(data(cd),j)=v AND 
			member(j,nth(adjs(cd),i))}  #)

  vertsl?(G)(l: list[T]): bool = 
    (FORALL(v:T):member(v,l) IFF member(v,vert(G)))
    AND length(l) = size(G)

  no_rep_vertsl: LEMMA
    FORALL(l:(vertsl?(G))): no_repetitions?(l)
  
  filter_edges_for(G,(vertsl:(vertsl?(G))),v:T|member(v,vertsl),
    E:finite_set[edgetype]|subset?(E,edges(G))) : RECURSIVE { adj_v: list[nat] | 
                                               (FORALL(w:T): member(w,vertsl) 
					       IMPLIES (member(idx(vertsl,w),adj_v)
					       	        IFF member((v,w),E))) AND
					       (FORALL(i:below(length(adj_v))):
					         nth(adj_v, i) < size(G)) AND
					       no_repetitions?(adj_v)} =
    IF empty?(E) THEN null
    ELSE LET (v1,v2) = choose(E) 
    	 IN IF v1 = v THEN cons( idx(vertsl,v2) , filter_edges_for(G,vertsl,v,rest(E)))
	       	      ELSE filter_edges_for(G,vertsl,v,rest(E)) ENDIF ENDIF
  MEASURE card(E)

  filter_edges_rec(G,(vertsl:(vertsl?(G)))) 
    (vs:list[T]|suffix?(vs,vertsl)) : RECURSIVE { adjs: list[list[nat]] | 
                               length(vs) = length(adjs) AND
    	                       (FORALL(i:below(length(vs)),j:below(length(vertsl))):
			         member(j,nth(adjs,i)) 
				 IFF LET vi = nth(vertsl,i + length(vertsl)-length(vs)),
				     	 vj = nth(vertsl,j) IN
				     member((vi,vj),edges(G))) AND
			       (FORALL(i:below(length(adjs)),j:below(length(nth(adjs,i)))):
			          nth(nth(adjs, i),j) < size(G)) AND
			       (FORALL(i:below(length(adjs))):
			          no_repetitions?(nth(adjs,i)))} =
    CASES vs OF 
      null: null,
      cons(v,vs_): cons( filter_edges_for(G,vertsl,v,edges(G)) ,
      		   	 filter_edges_rec(G,vertsl)(vs_) )
    ENDCASES
  MEASURE length(vs)  

  filter_edges(G, (vertsl:(vertsl?(G)))): { adjs:list[list[nat]] |
                        length(adjs) = length(vertsl) AND
 		        (FORALL(i,j:below(length(vertsl))):
			   member(j,nth(adjs,i))
			     IFF LET vi = nth(vertsl,i), vj = nth(vertsl,j) 
				 IN member((vi,vj),edges(G))) AND
			(FORALL(i:below(length(adjs)),j:below(length(nth(adjs,i)))):
			   nth(nth(adjs, i),j) < size(G)) AND
                        (FORALL(i:below(length(adjs))): 
			   no_repetitions?(nth(adjs,i)))} =
    filter_edges_rec(G,vertsl)(vertsl)

  vertsl(G): (vertsl?(G)) = set2list(vert(G))

  to_cdigraph(G): cdigraph_eq(G) =
    (# data := vertsl(G),
       adjs := filter_edges(G,vertsl(G))  #)

  % Completeness of conversion functions
  eq_digraph: LEMMA
    eq(G,cd) IMPLIES to_digraph(cd) = G

  eq_cdigraph: LEMMA
    eq(G,cd) IMPLIES sem_eq(to_cdigraph(G),cd)

END cdigraphs
