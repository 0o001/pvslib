(cdigraphs
 (loi_append 0
  (loi_append-1 nil 3656092044
   ("" (skeep)
    (("" (expand "list_of_idxs")
      (("" (skeep :preds? t)
        (("" (use "nth_append[nat]")
          (("" (split -1)
            (("1" (replace -1 :hide? t)
              (("1" (lift-if 1)
                (("1" (split 1)
                  (("1" (flatten) (("1" (inst?) nil nil)) nil)
                   ("2" (flatten)
                    (("2" (inst -3 "i-length(l1)")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (use "length_append[nat]") (("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list_of_idxs const-decl "bool" cdigraphs nil)
    (nth_append formula-decl nil more_list_props "structures/")
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (append def-decl "list[T]" list_props nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (length_append formula-decl nil list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (i skolem-const-decl "below(length(append(l1, l2)))" cdigraphs nil)
    (l2 skolem-const-decl "list[nat]" cdigraphs nil)
    (l1 skolem-const-decl "list[nat]" cdigraphs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (loi_permutation 0
  (loi_permutation-1 nil 3656092299
   ("" (skeep)
    (("" (expand "list_of_idxs")
      (("" (skeep)
        (("" (typepred "l2")
          (("" (hide -1)
            (("" (expand "permutation_list")
              (("" (expand "permutation?")
                (("" (flatten)
                  (("" (expand "includes?")
                    (("" (inst -1 "nth(l2, i)")
                      (("" (case "count(nth(l2, i))(l2)>0")
                        (("1" (case "member(nth(l2, i), l1)")
                          (("1" (use "member_nth[nat]")
                            (("1" (assert)
                              (("1"
                                (skeep -1)
                                (("1"
                                  (inst -6 "i_1")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but (1 -1 -2))
                            (("2" (use "count_member[nat]")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (use "count_nth[nat]") nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list_of_idxs const-decl "bool" cdigraphs nil)
    (permutation_list const-decl "bool" permutations_list
     "structures/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (count_nth formula-decl nil permutations_list "structures/")
    (member def-decl "bool" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member_nth formula-decl nil more_list_props "structures/")
    (count_member formula-decl nil permutations_list "structures/")
    (count def-decl "nat" permutations_list "structures/")
    (> const-decl "bool" reals nil)
    (includes? const-decl "bool" permutations_list "structures/")
    (permutation? const-decl "bool" permutations_list "structures/"))
   shostak))
 (eq_TCC1 0
  (eq_TCC1-1 nil 3654690301 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil cdigraphs nil)
    (edgetype type-eq-decl nil digraphs nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (predigraph type-eq-decl nil digraphs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (digraph type-eq-decl nil digraphs nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (ComputableDigraph type-eq-decl nil cdigraphs nil)
    (cdigraph const-decl "bool" cdigraphs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size const-decl "nat" cdigraphs nil)
    (list_of_idxs const-decl "bool" cdigraphs nil)
    (/= const-decl "boolean" notequal nil)
    (no_repetitions? const-decl "bool" more_list_props "structures/")
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil))
 (to_digraph_TCC1 0
  (to_digraph_TCC1-1 nil 3655633029 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil cdigraphs nil)
    (ComputableDigraph type-eq-decl nil cdigraphs nil)
    (cdigraph const-decl "bool" cdigraphs nil)
    (< const-decl "bool" reals nil)
    (size const-decl "nat" cdigraphs nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (no_repetitions? const-decl "bool" more_list_props "structures/")
    (/= const-decl "boolean" notequal nil)
    (list_of_idxs const-decl "bool" cdigraphs nil))
   nil))
 (to_digraph_TCC2 0
  (to_digraph_TCC2-1 nil 3655633029 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil cdigraphs nil)
    (ComputableDigraph type-eq-decl nil cdigraphs nil)
    (cdigraph const-decl "bool" cdigraphs nil)
    (< const-decl "bool" reals nil)
    (size const-decl "nat" cdigraphs nil)
    (below type-eq-decl nil naturalnumbers nil)
    (list_of_idxs const-decl "bool" cdigraphs nil)
    (/= const-decl "boolean" notequal nil)
    (no_repetitions? const-decl "bool" more_list_props "structures/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (to_digraph_TCC3 0
  (to_digraph_TCC3-2 nil 3656089073 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil cdigraphs nil)
    (ComputableDigraph type-eq-decl nil cdigraphs nil)
    (cdigraph const-decl "bool" cdigraphs nil)
    (< const-decl "bool" reals nil)
    (size const-decl "nat" cdigraphs nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_of_idxs const-decl "bool" cdigraphs nil)
    (/= const-decl "boolean" notequal nil)
    (no_repetitions? const-decl "bool" more_list_props "structures/")
    (length def-decl "nat" list_props nil))
   nil)
  (to_digraph_TCC3-1 nil 3655633029 ("" (grind) nil nil) nil nil))
 (to_digraph_TCC4 0
  (to_digraph_TCC4-2 nil 3656096882
   ("" (skeep*)
    (("" (lemma "finite_subset[[T,T]]")
      ((""
        (inst -1 "{u: T, v: T |
                  (EXISTS (i: below(size(cd))): nth[T](data(cd), i) = u) AND
                  (EXISTS (j: below(size(cd))): nth[T](data(cd), j) = v)}"
         "{u: T, v: T |
                  EXISTS (i, j: below(size(cd))):
                    nth[T](data(cd), i) = u AND
                     nth[T](data(cd), j) = v AND
                      member[nat](j, nth[list[nat]](adjs(cd), i))}")
        (("1" (assert)
          (("1" (hide 2)
            (("1" (expand "subset?")
              (("1" (skeep)
                (("1" (expand "member")
                  (("1" (skeep)
                    (("1" (split 1)
                      (("1" (inst?) nil nil) ("2" (inst?) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (grind)
            (("2" (typepred "cd") (("2" (grind) nil nil)) nil)) nil))
          nil)
         ("3" (hide 2)
          (("3" (typepred "cd") (("3" (grind) nil nil)) nil)) nil)
         ("4" (hide 2)
          (("4" (typepred "cd") (("4" (grind) nil nil)) nil)) nil)
         ("5" (hide 2)
          (("5"
            (lemma "finite_full[({u: [T,T] |
                      (EXISTS (i: below(size(cd))): nth[T](data(cd), i) = u`1) AND
                       (EXISTS (j: below(size(cd))): nth[T](data(cd), j) = u`2)})]")
            (("5" (assert)
              (("5" (flatten)
                (("5" (hide -2)
                  (("5" (split -1)
                    (("1" (grind) nil nil)
                     ("2" (hide 2)
                      (("2"
                        (lemma
                         "is_finite_cross[({u1:T|EXISTS (i: below(size(cd))):
                                          nth[T](data(cd), i) = u1}),({u2:T|EXISTS (j: below(size(cd))):
                                          nth[T](data(cd), j) = u2})]")
                        (("2" (split -1)
                          (("1" (expand "is_finite_type")
                            (("1" (skeep -1)
                              (("1"
                                (inst
                                 1
                                 "N"
                                 "LAMBDA(u:[T,T]|
                                           (EXISTS (i: below(size(cd))):
                                              nth[T](data(cd), i) = u`1)
                                            AND
                                            (EXISTS (j: below(size(cd))):
                                               nth[T](data(cd), j) = u`2)): g(u)")
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil)
                                 ("3" (grind) nil nil)
                                 ("4" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide 2)
                            (("2" (expand "is_finite_type")
                              (("2"
                                (case "size(cd)=0")
                                (("1"
                                  (inst
                                   1
                                   "1"
                                   "LAMBDA(u:({u1: T |
                                     EXISTS (i: below(size(cd))):
                                       nth[T](data(cd), i) = u1})): 0")
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2"
                                  (inst
                                   2
                                   "size(cd)"
                                   "LAMBDA(u1:
                                           [{u1: T |
                                                     EXISTS (i: below(size(cd))):
                                                       nth[T](data(cd), i) = u1}]) : epsilon({i: below(size(cd)) |
                                                       nth[T](data(cd), i) = u1})")
                                  (("1"
                                    (expand "injective?")
                                    (("1"
                                      (skeep)
                                      (("1"
                                        (lemma
                                         "epsilon_ax[below(size(cd))]")
                                        (("1"
                                          (inst-cp
                                           -1
                                           "LAMBDA(i: below(size(cd))): nth[T](data(cd), i) = x1")
                                          (("1"
                                            (split -2)
                                            (("1"
                                              (replace
                                               -1
                                               2
                                               :hide?
                                               t
                                               :dir
                                               rl)
                                              (("1"
                                                (inst
                                                 -1
                                                 "LAMBDA(i: below(size(cd))): nth[T](data(cd), i) = x2")
                                                (("1"
                                                  (split -1)
                                                  (("1"
                                                    (replace
                                                     -1
                                                     2
                                                     :hide?
                                                     t
                                                     :dir
                                                     rl)
                                                    (("1"
                                                      (name-replace
                                                       "e1"
                                                       "epsilon({i: below(size(cd)) | nth[T](data(cd), i) = x1})")
                                                      (("1"
                                                        (name-replace
                                                         "e2"
                                                         "epsilon({i: below(size(cd)) | nth[T](data(cd), i) = x2})")
                                                        (("1"
                                                          (typepred
                                                           "cd")
                                                          (("1"
                                                            (expand
                                                             "cdigraph")
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (expand
                                                                 "no_repetitions?")
                                                                (("1"
                                                                  (inst
                                                                   -3
                                                                   "e1"
                                                                   "e2")
                                                                  (("1"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (typepred "x2")
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (typepred "x1")
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil)
                                         ("2"
                                          (inst 1 "0")
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil)
                                   ("3" (grind) nil nil)
                                   ("4" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (hide 2)
                            (("3" (expand "is_finite_type")
                              (("3"
                                (case "size(cd)=0")
                                (("1"
                                  (inst
                                   1
                                   "1"
                                   "LAMBDA(u:({u1: T |
                                               EXISTS (i: below(size(cd))):
                                                 nth[T](data(cd), i) = u1})): 0")
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2"
                                  (inst
                                   2
                                   "size(cd)"
                                   "LAMBDA(u1:
                                                     [{u1: T |
                                                               EXISTS (i: below(size(cd))):
                                                                 nth[T](data(cd), i) = u1}]) : epsilon({i: below(size(cd)) |
                                                                 nth[T](data(cd), i) = u1})")
                                  (("1"
                                    (expand "injective?")
                                    (("1"
                                      (skeep)
                                      (("1"
                                        (lemma
                                         "epsilon_ax[below(size(cd))]")
                                        (("1"
                                          (inst-cp
                                           -1
                                           "LAMBDA(i: below(size(cd))): nth[T](data(cd), i) = x1")
                                          (("1"
                                            (split -2)
                                            (("1"
                                              (replace
                                               -1
                                               2
                                               :hide?
                                               t
                                               :dir
                                               rl)
                                              (("1"
                                                (inst
                                                 -1
                                                 "LAMBDA(i: below(size(cd))): nth[T](data(cd), i) = x2")
                                                (("1"
                                                  (split -1)
                                                  (("1"
                                                    (replace
                                                     -1
                                                     2
                                                     :hide?
                                                     t
                                                     :dir
                                                     rl)
                                                    (("1"
                                                      (name-replace
                                                       "e1"
                                                       "epsilon({i: below(size(cd)) | nth[T](data(cd), i) = x1})")
                                                      (("1"
                                                        (name-replace
                                                         "e2"
                                                         "epsilon({i: below(size(cd)) | nth[T](data(cd), i) = x2})")
                                                        (("1"
                                                          (typepred
                                                           "cd")
                                                          (("1"
                                                            (expand
                                                             "cdigraph")
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (expand
                                                                 "no_repetitions?")
                                                                (("1"
                                                                  (inst
                                                                   -3
                                                                   "e1"
                                                                   "e2")
                                                                  (("1"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (typepred "x2")
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (typepred "x1")
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil)
                                         ("2"
                                          (inst 1 "0")
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil)
                                   ("3" (grind) nil nil)
                                   ("4" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("6" (hide 2) (("6" (grind) nil nil)) nil)
         ("7" (grind) nil nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil cdigraphs nil)
    (finite_subset formula-decl nil finite_sets nil)
    (is_finite_type const-decl "bool" finite_sets nil)
    (TRUE const-decl "bool" booleans nil)
    (epsilon const-decl "T" epsilons nil)
    (pred type-eq-decl nil defined_types nil)
    (epsilon_ax formula-decl nil epsilons nil)
    (is_finite_cross formula-decl nil finite_cross "finite_sets/")
    (fullset const-decl "set" sets nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_full formula-decl nil finite_sets nil)
    (no_repetitions? const-decl "bool" more_list_props "structures/")
    (/= const-decl "boolean" notequal nil)
    (list_of_idxs const-decl "bool" cdigraphs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (member def-decl "bool" list_props nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ComputableDigraph type-eq-decl nil cdigraphs nil)
    (size const-decl "nat" cdigraphs nil)
    (cdigraph const-decl "bool" cdigraphs nil)
    (cd skolem-const-decl "(cdigraph)" cdigraphs nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil))
   nil)
  (to_digraph_TCC4-1 nil 3655633029 ("" (grind) nil nil)
   ((no_repetitions? const-decl "bool" more_list_props "structures/"))
   nil))
 (to_digraph_TCC5 0
  (to_digraph_TCC5-1 nil 3656086108 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil cdigraphs nil)
    (ComputableDigraph type-eq-decl nil cdigraphs nil)
    (cdigraph const-decl "bool" cdigraphs nil)
    (< const-decl "bool" reals nil)
    (size const-decl "nat" cdigraphs nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (no_repetitions? const-decl "bool" more_list_props "structures/")
    (/= const-decl "boolean" notequal nil)
    (list_of_idxs const-decl "bool" cdigraphs nil))
   nil))
 (to_digraph_TCC6 0
  (to_digraph_TCC6-2 nil 3656096938
   ("" (skeep)
    (("" (expand "is_finite")
      (("" (case "size(cd)=0")
        (("1"
          (inst 1 "1" "LAMBDA(u:({u1: T |
                                         EXISTS (i: below(size(cd))):
                                           nth[T](data(cd), i) = u1})): 0")
          (("1" (grind) nil nil)) nil)
         ("2"
          (inst 2 "size(cd)" "LAMBDA(u1:
                                               [{u1: T |
                                                         EXISTS (i: below(size(cd))):
                                                           nth[T](data(cd), i) = u1}]) : epsilon({i: below(size(cd)) |
                                                           nth[T](data(cd), i) = u1})")
          (("1" (expand "injective?")
            (("1" (skeep)
              (("1" (lemma "epsilon_ax[below(size(cd))]")
                (("1"
                  (inst-cp -1
                   "LAMBDA(i: below(size(cd))): nth[T](data(cd), i) = x1")
                  (("1" (split -2)
                    (("1" (replace -1 2 :hide? t :dir rl)
                      (("1"
                        (inst -1
                         "LAMBDA(i: below(size(cd))): nth[T](data(cd), i) = x2")
                        (("1" (split -1)
                          (("1" (replace -1 2 :hide? t :dir rl)
                            (("1"
                              (name-replace "e1"
                               "epsilon({i: below(size(cd)) | nth[T](data(cd), i) = x1})")
                              (("1"
                                (name-replace
                                 "e2"
                                 "epsilon({i: below(size(cd)) | nth[T](data(cd), i) = x2})")
                                (("1"
                                  (typepred "cd")
                                  (("1"
                                    (expand "cdigraph")
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (expand "no_repetitions?")
                                        (("1"
                                          (inst -3 "e1" "e2")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (typepred "x2")
                            (("2" (propax) nil nil)) nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (typepred "x1") (("2" (propax) nil nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (inst 1 "0") (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil) ("3" (grind) nil nil)
           ("4" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((is_finite const-decl "bool" finite_sets nil)
    (cd skolem-const-decl "(cdigraph)" cdigraphs nil)
    (TRUE const-decl "bool" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (epsilon const-decl "T" epsilons nil)
    (no_repetitions? const-decl "bool" more_list_props "structures/")
    (epsilon_ax formula-decl nil epsilons nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil cdigraphs nil)
    (ComputableDigraph type-eq-decl nil cdigraphs nil)
    (size const-decl "nat" cdigraphs nil)
    (cdigraph const-decl "bool" cdigraphs nil))
   nil)
  (to_digraph_TCC6-1 nil 3656086488
   ("" (skeep*)
    (("" (split 1)
      (("1" (grind) nil nil)
       ("2" (expand "eq")
        (("2" (split 1)
          (("1" (typepred "set_as_list.list2set(data(cd))")
            (("1" (replace -2 :hide? t)
              (("1" (apply-extensionality 1)
                (("1" (hide 2)
                  (("1" (iff)
                    (("1" (split 1)
                      (("1" (flatten)
                        (("1" (use "member_nth[T]")
                          (("1" (assert)
                            (("1" (skeep)
                              (("1"
                                (inst 1 "i")
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (skeep)
                          (("2" (use "nth_member[T]")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (split 1)
              (("1" (flatten) (("1" (grind) nil nil)) nil)
               ("2" (flatten)
                (("2" (expand "member" -1 1)
                  (("2" (skeep)
                    (("2" (case "j=j_1")
                      (("1" (case "i=i_1")
                        (("1" (assert) nil nil)
                         ("2" (hide-all-but (-2 1))
                          (("2" (typepred "cd")
                            (("2" (expand "cdigraph")
                              (("2"
                                (flatten)
                                (("2"
                                  (expand "no_repetitions?")
                                  (("2"
                                    (inst -3 "i" "i_1")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide-all-but (1 -2))
                        (("2" (typepred "cd")
                          (("2" (expand "cdigraph")
                            (("2" (flatten)
                              (("2"
                                (expand "no_repetitions?")
                                (("2"
                                  (inst -3 "j" "j_1")
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member_nth formula-decl nil more_list_props "structures/")
    (nth_member formula-decl nil more_list_props "structures/")
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (list2set def-decl "{s: finite_set[T] | s = ({x | member(x, l)})}"
     set_as_list "structures/")
    (no_repetitions? const-decl "bool" more_list_props "structures/"))
   nil))
 (to_digraph_TCC7 0
  (to_digraph_TCC7-3 nil 3656096919
   ("" (skeep*)
    (("" (split 1)
      (("1" (grind) nil nil)
       ("2" (expand "eq")
        (("2" (split 1)
          (("1" (typepred "set_as_list.list2set(data(cd))")
            (("1" (replace -2 :hide? t)
              (("1" (apply-extensionality 1)
                (("1" (hide 2)
                  (("1" (iff)
                    (("1" (split 1)
                      (("1" (flatten)
                        (("1" (use "member_nth[T]")
                          (("1" (assert)
                            (("1" (skeep)
                              (("1"
                                (inst 1 "i")
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (skeep)
                          (("2" (use "nth_member[T]")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (split 1)
              (("1" (flatten) (("1" (grind) nil nil)) nil)
               ("2" (flatten)
                (("2" (expand "member" -1 1)
                  (("2" (skeep)
                    (("2" (case "j=j_1")
                      (("1" (case "i=i_1")
                        (("1" (assert) nil nil)
                         ("2" (hide-all-but (-2 1))
                          (("2" (typepred "cd")
                            (("2" (expand "cdigraph")
                              (("2"
                                (flatten)
                                (("2"
                                  (expand "no_repetitions?")
                                  (("2"
                                    (inst -3 "i" "i_1")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide-all-but (1 -2))
                        (("2" (typepred "cd")
                          (("2" (expand "cdigraph")
                            (("2" (flatten)
                              (("2"
                                (expand "no_repetitions?")
                                (("2"
                                  (inst -3 "j" "j_1")
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (cdigraph const-decl "bool" cdigraphs nil)
    (size const-decl "nat" cdigraphs nil)
    (ComputableDigraph type-eq-decl nil cdigraphs nil)
    (T formal-type-decl nil cdigraphs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member_nth formula-decl nil more_list_props "structures/")
    (i skolem-const-decl "below(length(data(cd)))" cdigraphs nil)
    (nth_member formula-decl nil more_list_props "structures/")
    (cd skolem-const-decl "(cdigraph)" cdigraphs nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (member def-decl "bool" list_props nil)
    (list2set def-decl "{s: finite_set[T] | s = ({x | member(x, l)})}"
     set_as_list "structures/")
    (member const-decl "bool" sets nil)
    (no_repetitions? const-decl "bool" more_list_props "structures/")
    (eq const-decl "bool" cdigraphs nil))
   nil)
  (to_digraph_TCC7-2 nil 3656096769
   ("" (skeep*)
    (("" (lemma "finite_subset[[T,T]]")
      ((""
        (inst -1 "{u: T, v: T |
                  (EXISTS (i: below(size(cd))): nth[T](data(cd), i) = u) AND
                  (EXISTS (j: below(size(cd))): nth[T](data(cd), j) = v)}"
         "{u: T, v: T |
                  EXISTS (i, j: below(size(cd))):
                    nth[T](data(cd), i) = u AND
                     nth[T](data(cd), j) = v AND
                      member[nat](j, nth[list[nat]](adjs(cd), i))}")
        (("1" (assert)
          (("1" (hide 2)
            (("1" (expand "subset?")
              (("1" (skeep)
                (("1" (expand "member")
                  (("1" (skeep)
                    (("1" (split 1)
                      (("1" (inst?) nil)
                       ("2" (inst?) nil)))))))))))))))
         ("2" (hide 2)
          (("2" (grind) (("2" (typepred "cd") (("2" (grind) nil)))))))
         ("3" (hide 2) (("3" (typepred "cd") (("3" (grind) nil)))))
         ("4" (hide 2) (("4" (typepred "cd") (("4" (grind) nil)))))
         ("5" (hide 2)
          (("5"
            (lemma "finite_full[({u: [T,T] |
                      (EXISTS (i: below(size(cd))): nth[T](data(cd), i) = u`1) AND
                       (EXISTS (j: below(size(cd))): nth[T](data(cd), j) = u`2)})]")
            (("5" (assert)
              (("5" (flatten)
                (("5" (hide -2)
                  (("5" (split -1)
                    (("1" (grind) nil)
                     ("2" (hide 2)
                      (("2"
                        (lemma
                         "is_finite_cross[({u1:T|EXISTS (i: below(size(cd))):
                                          nth[T](data(cd), i) = u1}),({u2:T|EXISTS (j: below(size(cd))):
                                          nth[T](data(cd), j) = u2})]")
                        (("2" (split -1)
                          (("1" (expand "is_finite_type")
                            (("1" (skeep -1)
                              (("1"
                                (inst
                                 1
                                 "N"
                                 "LAMBDA(u:[T,T]|
                                           (EXISTS (i: below(size(cd))):
                                              nth[T](data(cd), i) = u`1)
                                            AND
                                            (EXISTS (j: below(size(cd))):
                                               nth[T](data(cd), j) = u`2)): g(u)")
                                (("1" (grind) nil)
                                 ("2" (grind) nil)
                                 ("3" (grind) nil)
                                 ("4" (grind) nil)))))))
                           ("2" (hide 2)
                            (("2" (expand "is_finite_type")
                              (("2"
                                (case "size(cd)=0")
                                (("1"
                                  (inst
                                   1
                                   "1"
                                   "LAMBDA(u:({u1: T |
                                     EXISTS (i: below(size(cd))):
                                       nth[T](data(cd), i) = u1})): 0")
                                  (("1" (grind) nil)))
                                 ("2"
                                  (inst
                                   2
                                   "size(cd)"
                                   "LAMBDA(u1:
                                           [{u1: T |
                                                     EXISTS (i: below(size(cd))):
                                                       nth[T](data(cd), i) = u1}]) : epsilon({i: below(size(cd)) |
                                                       nth[T](data(cd), i) = u1})")
                                  (("1"
                                    (expand "injective?")
                                    (("1"
                                      (skeep)
                                      (("1"
                                        (lemma
                                         "epsilon_ax[below(size(cd))]")
                                        (("1"
                                          (inst-cp
                                           -1
                                           "LAMBDA(i: below(size(cd))): nth[T](data(cd), i) = x1")
                                          (("1"
                                            (split -2)
                                            (("1"
                                              (replace
                                               -1
                                               2
                                               :hide?
                                               t
                                               :dir
                                               rl)
                                              (("1"
                                                (inst
                                                 -1
                                                 "LAMBDA(i: below(size(cd))): nth[T](data(cd), i) = x2")
                                                (("1"
                                                  (split -1)
                                                  (("1"
                                                    (replace
                                                     -1
                                                     2
                                                     :hide?
                                                     t
                                                     :dir
                                                     rl)
                                                    (("1"
                                                      (name-replace
                                                       "e1"
                                                       "epsilon({i: below(size(cd)) | nth[T](data(cd), i) = x1})")
                                                      (("1"
                                                        (name-replace
                                                         "e2"
                                                         "epsilon({i: below(size(cd)) | nth[T](data(cd), i) = x2})")
                                                        (("1"
                                                          (typepred
                                                           "cd")
                                                          (("1"
                                                            (expand
                                                             "cdigraph")
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (expand
                                                                 "no_repetitions?")
                                                                (("1"
                                                                  (inst
                                                                   -3
                                                                   "e1"
                                                                   "e2")
                                                                  (("1"
                                                                    (assert)
                                                                    nil)))))))))))
                                                         ("2"
                                                          (grind)
                                                          nil)))
                                                       ("2"
                                                        (grind)
                                                        nil)))))
                                                   ("2"
                                                    (typepred "x2")
                                                    (("2"
                                                      (propax)
                                                      nil)))))
                                                 ("2" (grind) nil)))))
                                             ("2"
                                              (typepred "x1")
                                              (("2" (propax) nil)))))
                                           ("2" (grind) nil)))
                                         ("2"
                                          (inst 1 "0")
                                          (("2" (grind) nil)))))))))
                                   ("2" (grind) nil)
                                   ("3" (grind) nil)
                                   ("4" (grind) nil)))))))))
                           ("3" (hide 2)
                            (("3" (expand "is_finite_type")
                              (("3"
                                (case "size(cd)=0")
                                (("1"
                                  (inst
                                   1
                                   "1"
                                   "LAMBDA(u:({u1: T |
                                               EXISTS (i: below(size(cd))):
                                                 nth[T](data(cd), i) = u1})): 0")
                                  (("1" (grind) nil)))
                                 ("2"
                                  (inst
                                   2
                                   "size(cd)"
                                   "LAMBDA(u1:
                                                     [{u1: T |
                                                               EXISTS (i: below(size(cd))):
                                                                 nth[T](data(cd), i) = u1}]) : epsilon({i: below(size(cd)) |
                                                                 nth[T](data(cd), i) = u1})")
                                  (("1"
                                    (expand "injective?")
                                    (("1"
                                      (skeep)
                                      (("1"
                                        (lemma
                                         "epsilon_ax[below(size(cd))]")
                                        (("1"
                                          (inst-cp
                                           -1
                                           "LAMBDA(i: below(size(cd))): nth[T](data(cd), i) = x1")
                                          (("1"
                                            (split -2)
                                            (("1"
                                              (replace
                                               -1
                                               2
                                               :hide?
                                               t
                                               :dir
                                               rl)
                                              (("1"
                                                (inst
                                                 -1
                                                 "LAMBDA(i: below(size(cd))): nth[T](data(cd), i) = x2")
                                                (("1"
                                                  (split -1)
                                                  (("1"
                                                    (replace
                                                     -1
                                                     2
                                                     :hide?
                                                     t
                                                     :dir
                                                     rl)
                                                    (("1"
                                                      (name-replace
                                                       "e1"
                                                       "epsilon({i: below(size(cd)) | nth[T](data(cd), i) = x1})")
                                                      (("1"
                                                        (name-replace
                                                         "e2"
                                                         "epsilon({i: below(size(cd)) | nth[T](data(cd), i) = x2})")
                                                        (("1"
                                                          (typepred
                                                           "cd")
                                                          (("1"
                                                            (expand
                                                             "cdigraph")
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (expand
                                                                 "no_repetitions?")
                                                                (("1"
                                                                  (inst
                                                                   -3
                                                                   "e1"
                                                                   "e2")
                                                                  (("1"
                                                                    (assert)
                                                                    nil)))))))))))
                                                         ("2"
                                                          (grind)
                                                          nil)))
                                                       ("2"
                                                        (grind)
                                                        nil)))))
                                                   ("2"
                                                    (typepred "x2")
                                                    (("2"
                                                      (propax)
                                                      nil)))))
                                                 ("2" (grind) nil)))))
                                             ("2"
                                              (typepred "x1")
                                              (("2" (propax) nil)))))
                                           ("2" (grind) nil)))
                                         ("2"
                                          (inst 1 "0")
                                          (("2" (grind) nil)))))))))
                                   ("2" (grind) nil)
                                   ("3" (grind) nil)
                                   ("4"
                                    (grind)
                                    nil)))))))))))))))))))))))))))
         ("6" (hide 2) (("6" (grind) nil))) ("7" (grind) nil))))))
    nil)
   nil nil)
  (to_digraph_TCC7-1 nil 3656096457 ("" (subtype-tcc) nil nil) nil
   nil))
 (eq_digraph 0
  (eq_digraph-1 nil 3656097016
   ("" (skeep)
    (("" (expand "eq")
      (("" (flatten)
        (("" (expand "to_digraph")
          (("" (decompose-equality 1)
            (("1" (typepred "set_as_list.list2set(data(cd))")
              (("1" (replace -2 :hide? t)
                (("1" (apply-extensionality 1)
                  (("1" (hide 2)
                    (("1" (decompose-equality -2)
                      (("1" (iff)
                        (("1" (split 1)
                          (("1" (flatten)
                            (("1" (skeep)
                              (("1"
                                (inst -6 "i" "j")
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand "member")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (typepred "G")
                              (("2"
                                (inst? -1)
                                (("2"
                                  (assert)
                                  (("2"
                                    (flatten)
                                    (("2"
                                      (inst-cp -4 "x!1")
                                      (("2"
                                        (inst-cp -4 "x!2")
                                        (("2"
                                          (lemma "member_nth[T]")
                                          (("2"
                                            (inst-cp
                                             -1
                                             "data(cd)"
                                             "x!1")
                                            (("2"
                                              (assert)
                                              (("2"
                                                (inst
                                                 -1
                                                 "data(cd)"
                                                 "x!2")
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (skeep -1)
                                                    (("2"
                                                      (skeep -2)
                                                      (("2"
                                                        (inst
                                                         1
                                                         "i!1"
                                                         "i")
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (inst
                                                             -10
                                                             "i!1"
                                                             "i")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (expand
                                                                 "member")
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (grind)
                                                          nil
                                                          nil)
                                                         ("3"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (typepred "cd") (("2" (grind) nil nil)) nil)
                   ("3" (grind) nil nil) ("4" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "set_as_list.list2set(data(cd))")
              (("2" (replace -2 :hide? t)
                (("2" (decompose-equality -2)
                  (("2" (apply-extensionality 1)
                    (("1" (hide 2)
                      (("1" (inst -1 "x!1")
                        (("1" (iff)
                          (("1" (split 1)
                            (("1" (flatten)
                              (("1"
                                (skeep -1)
                                (("1"
                                  (use "nth_member[T]")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (assert)
                                (("2"
                                  (use "member_nth[T]")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (skeep)
                                      (("2"
                                        (inst 1 "i")
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (typepred "cd") (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (grind) nil nil)
             ("4" (hide-all-but 1)
              (("4" (skeep :preds? t)
                (("4" (typepred "cd") (("4" (grind) nil nil)) nil))
                nil))
              nil)
             ("5" (typepred "cd") (("5" (grind) nil nil)) nil)
             ("6" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((eq const-decl "bool" cdigraphs nil)
    (to_digraph const-decl "digraph_eq(cd)" cdigraphs nil)
    (i skolem-const-decl "below(length(data(cd)))" cdigraphs nil)
    (nth_member formula-decl nil more_list_props "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (list2set def-decl "{s: finite_set[T] | s = ({x | member(x, l)})}"
     set_as_list "structures/")
    (member const-decl "bool" sets nil)
    (member_nth formula-decl nil more_list_props "structures/")
    (i skolem-const-decl "below(length(data(cd)))" cdigraphs nil)
    (i!1 skolem-const-decl "below(length(data(cd)))" cdigraphs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_of_idxs const-decl "bool" cdigraphs nil)
    (/= const-decl "boolean" notequal nil)
    (no_repetitions? const-decl "bool" more_list_props "structures/")
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (T formal-type-decl nil cdigraphs nil)
    (boolean nonempty-type-decl nil booleans nil)
    (digraph type-eq-decl nil digraphs nil)
    (predigraph type-eq-decl nil digraphs nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (edgetype type-eq-decl nil digraphs nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ComputableDigraph type-eq-decl nil cdigraphs nil)
    (size const-decl "nat" cdigraphs nil)
    (cdigraph const-decl "bool" cdigraphs nil)
    (cd skolem-const-decl "(cdigraph)" cdigraphs nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil))
   shostak)))

