;;
;; Patch intended to solve the bug that provokes any equality between functions
;; to be evaluated to FALSE by the ground-evaluator.
;; 

;; Taken from PVS 7.0 code (src/groundeval/eval-macros.lisp)
;;; The top-level condition for ground evaluator errors
(define-condition groundeval-error (simple-error) ())

(define-condition equality-unknown (groundeval-error)
  ((obj1 :initarg :obj1 :reader obj1)
   (obj2 :initarg :obj2 :reader obj2))
  (:report (lambda (condition stream)
	      (format stream "Equality unknown between objects ~a and ~a of LISP types ~a and ~a, respectively."
		      (obj1 condition) (obj2 condition) (type-of (obj1 condition)) (type-of (obj2 condition))))))

;; Taken from PVS 6.0 code (src/groundeval/eval-macros.lisp)
(defun pvs_equalp (x y)
  "From CMULisp's equalp definition - adds pvs-array-closure-p test"
  (cond ((eq x y) t)
        ((characterp x) (and (characterp y) (char-equal x y)))
        ((numberp x) (and (numberp y) (= x y)))
        ((consp x)
         (and (consp y)
              (pvs_equalp (car x) (car y))
              (pvs_equalp (cdr x) (cdr y))))
        ((hash-table-p x)
         (and (hash-table-p y)
              (eql (hash-table-count x) (hash-table-count y))
              (eql (hash-table-test x) (hash-table-test y))
              (with-hash-table-iterator (next x)
                (loop
                 (multiple-value-bind (more x-key x-value)
                     (next)
                   (cond (more
                          (multiple-value-bind (y-value foundp)
                              (gethash x-key y)
                            (unless (and foundp (pvs_equalp x-value y-value))
                              (return nil))))
                         (t
                          (return t))))))))
	((pvs-array-closure-p x)
	 (and (pvs-array-closure-p y)
	      (let ((x-size (pvs-array-closure-size x))
		    (y-size (pvs-array-closure-size y)))
		(= x-size y-size)
		(pvs_equalp (mk-fun-array (pvs-array-closure-closure x) x-size)
			    (mk-fun-array (pvs-array-closure-closure y) y-size)))))
	((typep x 'structure-object)
	 (and (typep y 'structure-object)
	      (eq (class-of x) (class-of y))
	      (dolist (slotd (class-slots (class-of x)) t)
		(let ((slotn (slot-definition-name slotd)))
		  (unless (pvs_equalp (slot-value x slotn) (slot-value y slotn))
		    (return nil))))))
        ((vectorp x)
         (let ((length (length x)))
           (and (vectorp y)
                (= length (length y))
                (dotimes (i length t)
                  (let ((x-el (aref x i))
                        (y-el (aref y i)))
                    (unless (or (eq x-el y-el)
                                (pvs_equalp x-el y-el))
                      (return nil)))))))
        ((arrayp x)
         (and (arrayp y)
              (= (array-rank x) (array-rank y))
              (dotimes (axis (array-rank x) t)
                (unless (= (array-dimension x axis)
                           (array-dimension y axis))
                  (return nil)))
              (dotimes (index (array-total-size x) t)
                (let ((x-el (row-major-aref x index))
                      (y-el (row-major-aref y index)))
                  (unless (or (eq x-el y-el)
                              (pvs_equalp x-el y-el))
                    (return nil))))))
	;; BEGIN CM/MM: Added case
	(t (error 'equality-unknown :obj1 x :obj2 y))))
	;; END CM/MM
