for_examples : THEORY
BEGIN
  
  IMPORTING for_iterate,
            ints@factorial

  %% //@ assert n >= 0; 
  %% int a = 1;
  %% for (int i=1; i <= n; i++) {
  %%   /*@ loop invariant
  %%       a == x^i;
  %%     @ loop variant n-i;
  %%   */
  %%   a = a*x;
  %% }
  %% //@ assert a == x^n

  expit(x:real,n:nat): real =
    for[real](1,n,1,LAMBDA(i:subrange(1,n),a:real):a*x)

  expit_test : LEMMA
    expit(2,10) = 1024

  expit_inv(x:real,n:nat)(i:upto(n),a:real) : MACRO bool =
    a = x^i

  expit_post(x:real,n:nat)(a:real) : MACRO bool = a = x^n

  %% Proved using for_induction. 
  %% Invariant is LAMBDA(i:upto(n),a:real): a = x^i
  expit_sound : LEMMA
    FORALL(x:real,n:nat): expit_post(x,n)(expit(x,n))

  %% a = 1;
  %% for (i=n; i >= 1; i--) {
  %%   a = a*i;
  %% }

  factit(n:nat) : nat =
    for_down[nat](n,1,1,LAMBDA(i:subrange(1,n),a:nat):a*i)

  factit_test : LEMMA
    factit(10) = 3628800

  %% Proved using for_down_induction. 
  %% Invariant is LAMBDA(i:upto(n),a:nat): a = factorial(n)/factorial(n-i)
  factit_sound : LEMMA
    FORALL(n:nat): factit(n) = factorial(n)

  %% a = nth(l,0);
  %% for (i=1;i<=length(l)-1;i++) {
  %%   a = max(a,nth(l,i))
  %% }

  maxit(l:(cons?[real])) : real =
    iterate_left(0,length(l)-1,LAMBDA(i:below(length(l))):nth(l,i),max)
 
  maxit_test : LEMMA
    maxit((:2,3,4,1,2:)) = 4

  %% Proved using iterate_left_induction. 
  %% Invariant is LAMBDA(n:below(length(l)),a:real):FORALL(k:upto(n)) : nth(l,k) <= a
  maxit_sound : LEMMA
    FORALL (l:(cons?[real]),i:below(length(l))) :
      nth(l,i) <= maxit(l) 

  %% a = nth(l,0);
  %% for (i=1;i<=length(l)-1;i++) {
  %%   a = min(nth(l,i),a)
  %% }

  minit(l:(cons?[real])) : real =
    iterate_right(0,length(l)-1,LAMBDA(i:below(length(l))):nth(l,i),min)
 
  minit_test : LEMMA
    minit((:2,3,4,1,2:)) = 1

  %% Proved using iterate_right_induction. 
  %% Invariant is LAMBDA(n:below(length(l)),a:real): LET ll = length(l)-1 IN 
  %% FORALL(k:subrange(ll-n,ll)) :a <= nth(l,k)
  minit_sound : LEMMA
    FORALL (l:(cons?[real]),i:below(length(l))) :
       minit(l) <= nth(l,i)

  %% The following lemmas transform FORALL and EXISTS of subranges to
  %% computable boolean functions.

  %% Invariant is LAMBDA(j:upto(n),a:bool):(FORALL(k:upto(j)):P(k)) = a
  forall_and_upto : LEMMA
    FORALL(n:nat,P:[upto(n)->bool]):
      ((FORALL (j:upto(n)) : P(j)) =
        iterate_left[bool](0,n,P,AND))

  forall_and_below : LEMMA
    FORALL(n:posnat,P:[below(n)->bool]):
      ((FORALL (j:below(n)) : P(j)) =
        iterate_left[bool](0,n-1,P,AND))
	
  %% Invariant is LAMBDA(j:upto(n-m),a:bool):(FORALL(k:subrange(m,m+j)):P(k)) = a
  forall_and_subrange : LEMMA
    FORALL(m:int,n:upfrom(m),P:[subrange(m,n)->bool]):
      ((FORALL (j:subrange(m,n)) : P(j)) =
        iterate_left[bool](m,n,P,AND))

  %% Invariant is LAMBDA(j:upto(n),a:bool):(EXISTS(k:upto(j)):P(k)) = a
  exists_and_upto : LEMMA
    FORALL(n:nat,P:[upto(n)->bool]):
      ((EXISTS (j:upto(n)) : P(j)) =
        iterate_left[bool](0,n,P,OR))

  exists_and_below : LEMMA
    FORALL(n:posnat,P:[below(n)->bool]):
      ((EXISTS (j:below(n)) : P(j)) =
        iterate_left[bool](0,n-1,P,OR))
	
  %% Invariant is LAMBDA(j:upto(n-m),a:bool):(EXISTS(k:subrange(m,m+j)):P(k)) = a
  exists_and_subrange : LEMMA
    FORALL(m:int,n:upfrom(m),P:[subrange(m,n)->bool]):
      ((EXISTS (j:subrange(m,n)) : P(j)) =
    iterate_left[bool](m,n,P,OR))

  IMPORTING Maybe[real]

  sum_array_logic(n:nat,A:ARRAY[below(n)->Maybe[real]])(i:upto(n)) : RECURSIVE real =
    IF i=0 THEN 0
    ELSE (IF some?(A(i-1)) THEN val(A(i-1)) ELSE 0 ENDIF) +
          sum_array_logic(n,A)(i-1)
    ENDIF
  MEASURE i

  %% //@ assert n >= 0; 
  %% real a = 0;
  %% for (int i=1; i <= n; i++) {
  %%   /*@ loop invariant
  %%       a == sum_array_logic(n,A)(i);
  %%     @ loop variant n-i;
  %%   */
  %%   a = some?(A(i-1)) ? a+val(A(i-1)) : 0;
  %% }
  %% //@ assert a == sum_array_logic(n,A)(n) 

  %% Sum elements of array that are Some
  sum_array_body(n:nat,A:ARRAY[below(n)->Maybe[real]])(i:subrange(1,n),a:real) : MACRO real =
    IF some?(A(i-1)) THEN a+val(A(i-1))
    ELSE a
    ENDIF

  sum_array(n:nat,A:ARRAY[below(n)->Maybe[real]]) : real =
    for[real](1,n,0,sum_array_body(n,A))

  sum_array_inv(n:nat,A:ARRAY[below(n)->Maybe[real]])(i:upto(n),a:real) : MACRO bool =
    a = sum_array_logic(n,A)(i)

  sum_array_post(n:nat,A:ARRAY[below(n)->Maybe[real]])(a:real) : MACRO bool =
    a = sum_array_logic(n,A)(n)

  sum_array_sound : LEMMA
    FORALL(n:nat,A:ARRAY[below(n)->Maybe[real]]): sum_array_post(n,A)(sum_array(n,A))

END for_examples
