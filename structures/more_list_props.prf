(more_list_props
 (prefix?_TCC1 0
  (prefix?_TCC1-1 nil 3286895430 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   shostak))
 (suffix?_TCC1 0
  (suffix?_TCC1-1 nil 3286897128
   ("" (skeep*)
    (("" (use "length_reverse[T]")
      (("" (replaces -1)
        (("" (use "length_reverse[T]")
          (("" (replaces -2)
            (("" (replaces -1 :dir rl)
              (("" (expand "length" 2)
                (("" (assert) (("" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((length_reverse formula-decl nil list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   shostak))
 (caret_TCC1 0
  (caret_TCC1-1 nil 3287764724 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (caret_TCC2 0
  (caret_TCC2-1 nil 3287764724 ("" (termination-tcc) nil nil) nil
   shostak))
 (caret_TCC3 0
  (caret_TCC3-1 nil 3287771390 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (caret_TCC4 0
  (caret_TCC4-1 nil 3287771390 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (caret_TCC5 0
  (caret_TCC5-1 nil 3287771390
   ("" (termination-tcc) (("" (postpone) nil nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (caret_TCC6 0
  (caret_TCC6-1 nil 3287774349 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil))
   shostak))
 (prefix_length 0
  (prefix_length-1 nil 3287327236
   ("" (skosimp*) (("" (expand "prefix?") (("" (assert) nil nil)) nil))
    nil)
   ((prefix? def-decl "bool" more_list_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (suffix_length 0
  (suffix_length-1 nil 3287327263
   ("" (skosimp*) (("" (expand "suffix?") (("" (assert) nil nil)) nil))
    nil)
   ((suffix? def-decl "bool" more_list_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (every_forall 0
  (every_forall-1 nil 3286897625
   ("" (skeep) (("" (rewrite "every_nth") nil nil)) nil)
   ((every_nth formula-decl nil list_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil))
   shostak))
 (some_exists 0
  (some_exists-1 nil 3287148696
   ("" (induct "L")
    (("1" (grind) nil nil)
     ("2" (skosimp*)
      (("2" (inst?)
        (("2" (rewrite "some" +)
          (("2" (replace -1)
            (("2" (hide -1)
              (("2" (prop)
                (("1" (rewrite "nth")
                  (("1" (inst?)
                    (("1" (assert) nil nil)
                     ("2" (assert)
                      (("2" (rewrite "length") (("2" (ground) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skosimp*)
                  (("2" (inst 1 "n!1+1")
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                  nil)
                 ("3" (skosimp*)
                  (("3" (inst + "n!1-1")
                    (("1" (grind)
                      (("1" (expand "nth")
                        (("1" (prop)
                          (("1" (assert) nil nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (typepred "n!1")
                      (("2" (rewrite "length" -)
                        (("2" (assert)
                          (("2" (hide -1)
                            (("2" (rewrite "nth" -) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (n!1 skolem-const-decl
     "below(length(cons(cons1_var!1, cons2_var!1)))" more_list_props
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (n!1 skolem-const-decl "below(length(cons2_var!1))" more_list_props
     nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (cons2_var!1 skolem-const-decl "list[T]" more_list_props nil)
    (cons1_var!1 skolem-const-decl "T" more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (some adt-def-decl "boolean" list_adt nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (list_extensionality_TCC1 0
  (list_extensionality_TCC1-1 nil 3546992291 ("" (subtype-tcc) nil nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (list_extensionality 0
  (list_extensionality-1 nil 3546992303
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (case "null?(l2)")
          (("1" (grind) nil nil)
           ("2" (lemma "list_cons_eta[T]")
            (("2" (inst -1 "l2")
              (("1" (replaces -1 :dir rl)
                (("1" (split)
                  (("1" (flatten)
                    (("1" (replaces -1) (("1" (skeep) nil nil)) nil))
                    nil)
                   ("2" (flatten)
                    (("2" (rewrite "list_cons_extensionality[T]")
                      (("1" (inst -2 "0")
                        (("1" (expand "nth") (("1" (propax) nil nil))
                          nil)
                         ("2" (expand "length" 1)
                          (("2" (assert) nil nil)) nil))
                        nil)
                       ("2" (expand "length" -1)
                        (("2" (inst -3 "cdr(l2)")
                          (("2" (assert)
                            (("2" (skeep 4)
                              (("2"
                                (inst -2 "n+1")
                                (("1"
                                  (expand "nth" -2)
                                  (("1" (propax) nil nil))
                                  nil)
                                 ("2"
                                  (expand "length" 1)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (skosimp*) (("3" (assert) nil nil)) nil))
      nil))
    nil)
   ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (l2 skolem-const-decl "list[T]" more_list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (cons2_var skolem-const-decl "list[T]" more_list_props nil)
    (cons1_var skolem-const-decl "T" more_list_props nil)
    (n skolem-const-decl "below(length(cons2_var))" more_list_props
     nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil))
   shostak))
 (list_pigeonhole 0
  (list_pigeonhole-1 nil 3287156645
   ("" (measure-induct "card(A)" "A" 1)
    (("" (skosimp*)
      (("" (rewrite "length" -)
        (("" (lift-if)
          (("" (ground)
            (("" (inst - "remove(car(B!1), x!1)")
              (("" (rewrite "card_remove")
                (("" (rewrite "every")
                  (("" (flatten)
                    (("" (assert)
                      (("" (inst - "cdr(B!1)")
                        (("" (prop)
                          (("1" (skosimp*)
                            (("1" (inst + "n!1+1" "m!1+1")
                              (("1"
                                (expand "nth" +)
                                (("1" (assert) nil nil))
                                nil)
                               ("2"
                                (typepred "m!1")
                                (("2"
                                  (assert)
                                  (("2"
                                    (rewrite "length" +)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("3"
                                (typepred "n!1")
                                (("3"
                                  (rewrite "length" +)
                                  (("3" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (inst + 0 _)
                            (("1" (rewrite "nth" +)
                              (("1"
                                (expand "remove")
                                (("1"
                                  (expand "member")
                                  (("1"
                                    (rewrite "every_forall")
                                    (("1"
                                      (rewrite "every_forall")
                                      (("1"
                                        (skosimp*)
                                        (("1"
                                          (inst 3 "n!1+1")
                                          (("1"
                                            (inst -3 "n!1")
                                            (("1"
                                              (assert)
                                              (("1"
                                                (rewrite "nth" 3)
                                                (("1" (assert) nil nil)
                                                 ("2"
                                                  (typepred "n!1")
                                                  (("2"
                                                    (rewrite
                                                     "length"
                                                     1)
                                                    (("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (typepred "n!1")
                                            (("2"
                                              (rewrite "length" 1)
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (rewrite "length" 1)
                                (("2" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (rewrite "length" 1)
                              (("2" (assert) nil nil)) nil))
                            nil)
                           ("3" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_remove application-judgement "finite_set" finite_sets nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (remove const-decl "set" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (B!1 skolem-const-decl "list[T]" more_list_props nil)
    (n!1 skolem-const-decl "below[length(cdr(B!1))]" more_list_props
     nil)
    (m!1 skolem-const-decl "below[length(cdr(B!1))]" more_list_props
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (n!1 skolem-const-decl "below(length(cdr(B!1)))" more_list_props
     nil)
    (every_forall formula-decl nil more_list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (card_remove formula-decl nil finite_sets nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth def-decl "T" list_props nil)
    (/= const-decl "boolean" notequal nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (> const-decl "bool" reals nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (nth_append_TCC1 0
  (nth_append_TCC1-1 nil 3577469759
   ("" (skeep) (("" (rewrite "length_append") nil nil)) nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_append formula-decl nil list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil))
   nil))
 (nth_append_TCC2 0
  (nth_append_TCC2-1 nil 3577469759 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (nth_append 0
  (nth_append-1 nil 3577469817
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("a" "l"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (case-replace "length(cons(a,l))=length(l)+1")
            (("1" (hide -1)
              (("1" (expand "append" 1)
                (("1" (lift-if)
                  (("1" (case-replace "i < 1 + length(l)")
                    (("1" (expand "nth" 1)
                      (("1" (case-replace "i=0")
                        (("1" (assert)
                          (("1" (inst? -2) (("1" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (expand "nth" 2 1)
                        (("2" (inst? -) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "length" 1 1) (("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)
     ("4" (hide 2)
      (("4" (skeep) (("4" (rewrite "length_append") nil nil)) nil))
      nil))
    nil)
   ((length_append formula-decl nil list_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (append def-decl "list[T]" list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (length_null 0
  (length_null-1 nil 3580049561 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)) shostak))
 (length_singleton 0
  (length_singleton-1 nil 3580049452 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)) shostak))
 (length_null_list 0
  (length_null_list-1 nil 3601030512
   ("" (skeep)
    (("" (ground)
      (("1" (expand "length" -1) (("1" (assert) nil nil)) nil)
       ("2" (expand "length") (("2" (propax) nil nil)) nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   shostak))
 (reverse_def_TCC1 0
  (reverse_def_TCC1-1 nil 3601030498
   ("" (skeep) (("" (rewrite "length_reverse") nil nil)) nil)
   ((length_reverse formula-decl nil list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil))
   nil))
 (reverse_def_TCC2 0
  (reverse_def_TCC2-1 nil 3601030498 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (reverse_def 0
  (reverse_def-1 nil 3601030538
   (""
    (case "NOT forall (lpr:list[T],j:nat,k:nat): k+1=length(lpr) AND j<length(lpr) IMPLIES nth(lpr,j) = nth(reverse(lpr),length(lpr)-1-j)")
    (("1" (hide 2)
      (("1" (induct "k")
        (("1" (skeep)
          (("1" (assert)
            (("1" (case "NOT j = 0")
              (("1" (assert) nil nil)
               ("2" (replaces -1)
                (("2" (assert)
                  (("2" (copy -1)
                    (("2" (hide -3)
                      (("2" (replace -1 :dir rl)
                        (("2" (assert)
                          (("2" (expand "nth" +)
                            (("2" (copy -1)
                              (("2"
                                (expand "length" -1)
                                (("2"
                                  (expand "length" -1)
                                  (("2"
                                    (lift-if)
                                    (("2"
                                      (ground)
                                      (("2"
                                        (expand "reverse" +)
                                        (("2"
                                          (expand "reverse" +)
                                          (("2"
                                            (expand "append")
                                            (("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skosimp*)
          (("2" (assert)
            (("2" (expand "reverse" +)
              (("2" (lemma "length_null_list")
                (("2" (inst - "lpr!1")
                  (("2" (assert)
                    (("2" (rewrite "nth_append")
                      (("1" (lift-if)
                        (("1" (ground)
                          (("1" (name "kk" "j!1")
                            (("1" (replaces -1)
                              (("1"
                                (assert)
                                (("1"
                                  (inst - "cdr(lpr!1)" "j!2-1")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (split -)
                                      (("1"
                                        (case
                                         "length(cdr(lpr!1)) = length(lpr!1)-1")
                                        (("1"
                                          (replaces -1)
                                          (("1"
                                            (replaces -1 :dir rl)
                                            (("1"
                                              (expand "nth" + 1)
                                              (("1"
                                                (lift-if)
                                                (("1"
                                                  (ground)
                                                  (("1"
                                                    (replaces -1)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (rewrite
                                                         "length_reverse")
                                                        (("1"
                                                          (expand
                                                           "length"
                                                           -
                                                           1)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (expand "length" 1 2)
                                          (("2" (propax) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand "length" -2)
                                        (("2" (assert) nil nil))
                                        nil)
                                       ("3"
                                        (expand "length" -3)
                                        (("3" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (assert)
                                    (("2"
                                      (case "NOT j!2 = 0")
                                      (("1" (assert) nil nil)
                                       ("2"
                                        (replaces -1)
                                        (("2"
                                          (rewrite "length_reverse")
                                          (("2"
                                            (expand "length" -1 1)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (rewrite "length_reverse")
                            (("2" (expand "length" 1 1)
                              (("2"
                                (assert)
                                (("2"
                                  (case "NOT j!2 = 0")
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (replaces -1)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (expand "length" 2 1)
                                        (("2"
                                          (hide -)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (rewrite "length_reverse")
                        (("2" (expand "length" 1 1)
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (hide 2)
          (("3" (skosimp*)
            (("3" (assert)
              (("3" (rewrite "length_reverse") (("3" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep)
      (("2" (inst - "L" "length(L)-1-j" "length(L)-1")
        (("1" (assert) nil nil) ("2" (assert) nil nil)
         ("3" (assert) nil nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skosimp*)
        (("3" (assert)
          (("3" (rewrite "length_reverse") (("3" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_plus_int_is_int application-judgement "int" integers nil)
    (j skolem-const-decl "nat" more_list_props nil)
    (L skolem-const-decl "list[T]" more_list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nth_append formula-decl nil more_list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_singleton formula-decl nil more_list_props nil)
    (j!2 skolem-const-decl "nat" more_list_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (length_reverse formula-decl nil list_props nil)
    (length_null_list formula-decl nil more_list_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (append def-decl "list[T]" list_props nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   shostak))
 (cons_append 0
  (cons_append-1 nil 3613292587
   ("" (skeep)
    (("" (rewrite "list_extensionality")
      (("" (split)
        (("1" (expand "length" 1 1)
          (("1" (rewrite "length_append") nil nil)) nil)
         ("2" (skeep)
          (("2" (rewrite "nth_append")
            (("1" (expand "nth" 1)
              (("1" (lift-if)
                (("1" (lift-if)
                  (("1" (lift-if)
                    (("1" (assert)
                      (("1" (ground)
                        (("1" (expand "nth") (("1" (propax) nil nil))
                          nil)
                         ("2" (expand "nth" + 1)
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "n")
              (("2" (expand "length" -1) (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list_extensionality formula-decl nil more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (nth_append formula-decl nil more_list_props nil)
    (length def-decl "nat" list_props nil)
    (length_append formula-decl nil list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_singleton formula-decl nil more_list_props nil))
   shostak))
 (expand_list_TCC1 0
  (expand_list_TCC1-1 nil 3613298395 ("" (subtype-tcc) nil nil) nil
   nil))
 (expand_list 0
  (expand_list-1 nil 3613298397
   ("" (skeep)
    (("" (lemma "list_extensionality")
      (("" (inst?)
        (("" (assert)
          (("" (hide 3)
            (("" (split)
              (("1" (expand "length") (("1" (propax) nil nil)) nil)
               ("2" (skeep)
                (("2" (expand "nth") (("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list_extensionality formula-decl nil more_list_props nil)
    (length def-decl "nat" list_props nil)
    (nth def-decl "T" list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil))
   shostak))
 (append_null_left 0
  (append_null_left-1 nil 3613298991 ("" (grind) nil nil)
   ((append def-decl "list[T]" list_props nil)) shostak))
 (member_append_fi 0
  (member_append_fi-1 nil 3645178866
   ("" (skosimp*)
    (("" (name "L_" "length(l1!1)+length(l2!1)")
      (("" (generalize-skolem-constants)
        (("" (induct "L_1")
          (("1" (skolem 1 ("i" "l1" "l2"))
            (("1" (flatten)
              (("1" (case "l1 = null AND l2 = null")
                (("1" (flatten)
                  (("1" (replaces -1)
                    (("1" (replaces -1) (("1" (grind) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (skolem 1 ("i" "l1" "l2"))
              (("2" (flatten)
                (("2" (expand "append" -3)
                  (("2" (lift-if -3)
                    (("2" (split -3)
                      (("1" (flatten) nil nil)
                       ("2" (flatten)
                        (("2" (expand "member" -1)
                          (("2" (split -1)
                            (("1" (replaces -1) (("1" (grind) nil nil))
                              nil)
                             ("2" (inst -2 "i" "cdr(l1)" "l2")
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonneg_int nonempty-type-eq-decl nil integers nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pred type-eq-decl nil defined_types nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (append def-decl "list[T]" list_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil))
   nil))
 (null_append 0
  (null_append-1 nil 3645179039
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("h1" "t1"))
      (("2" (flatten) (("2" (grind) nil nil)) nil)) nil))
    nil)
   ((list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (append def-decl "list[T]" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (member_nth 0
  (member_nth-1 nil 3644930816
   ("" (induct "l")
    (("1" (skeep) (("1" (grind) nil nil)) nil)
     ("2" (skolem 1 ("x" "xs"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (inst -1 "t")
            (("2" (expand "member" -2)
              (("2" (split -2)
                (("1" (inst 1 "0")
                  (("1" (grind) nil nil)
                   ("2" (expand "length") (("2" (assert) nil nil))
                    nil))
                  nil)
                 ("2" (expand "nth" 1)
                  (("2" (assert)
                    (("2" (skeep)
                      (("2" (inst 1 "i+1")
                        (("1" (assert) nil nil)
                         ("2" (typepred "i") (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (i skolem-const-decl "below(length(xs))" more_list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (x skolem-const-decl "T" more_list_props nil)
    (xs skolem-const-decl "list[T]" more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (nnprefixes_same_head_TCC1 0
  (nnprefixes_same_head_TCC1-1 nil 3645179212
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (prefixes const-decl "bool" more_list_props nil))
   nil))
 (nnprefixes_same_head 0
  (nnprefixes_same_head-1 nil 3645179230
   ("" (skeep)
    (("" (typepred "l2")
      (("" (grind)
        (("" (case "l1 = cons(car(l1), cdr(l1))")
          (("1" (replaces -1)
            (("1" (grind) (("1" (decompose-equality) nil nil)) nil))
            nil)
           ("2" (grind)
            (("2" (use "list_cons_eta[T]") (("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((prefixes const-decl "bool" more_list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (append def-decl "list[T]" list_props nil))
   nil))
 (member_append_r 0
  (member_append_r-1 nil 3645179340
   ("" (skeep)
    (("" (name "L_" "length(l1) + length(l2)")
      (("" (generalize-skolem-constants)
        (("" (induct "L_1")
          (("1" (skeep)
            (("1" (case "l1_1 = null AND l2_1 = null")
              (("1" (flatten)
                (("1" (replaces -1)
                  (("1" (replaces -1) (("1" (grind) nil nil)) nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (skeep)
              (("2" (expand "append" 1)
                (("2" (lift-if 1)
                  (("2" (split 1)
                    (("1" (flatten) nil nil)
                     ("2" (flatten)
                      (("2" (expand "member" 2)
                        (("2" (flatten)
                          (("2" (inst -1 "i_1" "cdr(l1_1)" "l2_1")
                            (("2" (assert) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonneg_int nonempty-type-eq-decl nil integers nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pred type-eq-decl nil defined_types nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (append def-decl "list[T]" list_props nil))
   nil))
 (member_append_l 0
  (member_append_l-1 nil 3645179454
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("hl" "tl"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "member" -2)
            (("2" (split -2)
              (("1" (replaces -1) (("1" (grind) nil nil)) nil)
               ("2" (expand "append" 1) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (every_implies 0
  (every_implies-1 nil 3645179531
   ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
   ((list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (every adt-def-decl "boolean" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (append_right_inj 0
  (append_right_inj-1 nil 3645265347
   ("" (induct "l")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("a" "l"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "append" -2)
            (("2" (inst -1 "l1" "l2")
              (("2" (decompose-equality -2) (("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (subl_over_len_TCC1 0
  (subl_over_len_TCC1-1 nil 3644927435 ("" (subtype-tcc) nil nil) nil
   nil))
 (subl_over_len 0
  (subl_over_len-1 nil 3644927452
   ("" (skolem 1 ("m_" "l_" "i_") :skolem-typepreds? t)
    (("" (name "k_" "i_ - m_")
      (("" (generalize "k_" "k" "nat")
        (("1" (grind) nil nil)
         ("2" (generalize-skolem-constants)
          (("2" (induct "k")
            (("1" (skolem 1 ("m" "l" "i") :skolem-typepreds? t)
              (("1" (assert) nil nil)) nil)
             ("2" (skeep)
              (("2" (skolem 1 ("m" "l" "i") :skolem-typepreds? t)
                (("2" (assert)
                  (("2" (flatten)
                    (("2" (expand "^" 1)
                      (("2" (case "m=length(l)-1")
                        (("1" (replaces -1)
                          (("1" (assert) (("1" (grind) nil nil)) nil))
                          nil)
                         ("2" (inst -4 "1+m" "l" "i")
                          (("1" (assert) nil nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((upfrom nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (m skolem-const-decl "nat" more_list_props nil)
    (l skolem-const-decl "{l: list[T] | m < length(l)}" more_list_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (k_ skolem-const-decl "int" more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (^ def-decl "list[T]" more_list_props nil))
   nil))
 (subl_shr_TCC1 0
  (subl_shr_TCC1-1 nil 3644927489 ("" (subtype-tcc) nil nil) nil nil))
 (subl_shr 0
  (subl_shr-2 nil 3644927609
   ("" (skolem 1 ("a_" "l_" "m_" "n_") :skolem-typepreds? t)
    (("" (case "m_ > n_")
      (("1" (grind) nil nil)
       ("2" (case "m_ = n_")
        (("1" (replaces -1)
          (("1" (hide -1 1)
            (("1" (expand "^" 1)
              (("1" (expand "length" 1 1)
                (("1" (lift-if 1)
                  (("1" (lift-if 1)
                    (("1" (assert)
                      (("1" (split 1)
                        (("1" (propax) nil nil)
                         ("2" (flatten)
                          (("2" (expand "nth" 2 1)
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (case "m_ < n_")
          (("1" (hide (1 2))
            (("1" (name "k_" "n_ - m_")
              (("1" (generalize "k_" "k_" "nat")
                (("1" (assert) nil nil)
                 ("2" (generalize-skolem-constants)
                  (("2" (induct "k_")
                    (("1" (grind) nil nil)
                     ("2" (skeep)
                      (("2"
                        (skolem 1 ("a" "l" "m" "n") :skolem-typepreds?
                         t)
                        (("2" (assert)
                          (("2" (flatten)
                            (("2" (expand "^" 1 1)
                              (("2"
                                (assert)
                                (("2"
                                  (lift-if 1)
                                  (("2"
                                    (split 1)
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (case "m+1 = n")
                                        (("1"
                                          (replaces -1 :dir rl)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (expand "^" 2 1)
                                              (("1"
                                                (lift-if 2)
                                                (("1"
                                                  (split 2)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (inst -3 "a" "l" "1+m" "n")
                                          (("2"
                                            (assert)
                                            (("2"
                                              (replaces -3)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((above nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (^ def-decl "list[T]" more_list_props nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (k_ skolem-const-decl "int" more_list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil) (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   nil)
  (subl_shr-1 nil 3644927506
   ("" (skeep)
    (("" (case "l=null")
      (("1" (replaces -1) (("1" (grind) nil)))
       ("2" (generalize-skolem-constants)
        (("1" (induct "l_1")
          (("1" (skolem 1 ("a_" "l_"))
            (("1" (flatten)
              (("1" (split -1)
                (("1" (replaces -1)
                  (("1" (hide 1) (("1" (grind) nil)))))
                 ("2" (hide 1)
                  (("2" (expand "^" 1)
                    (("2" (lift-if 1)
                      (("2" (split 1)
                        (("1" (grind) nil)
                         ("2" (flatten)
                          (("2" (split 3)
                            (("1" (grind) nil)
                             ("2" (flatten)
                              (("2"
                                (use "subl_shr")
                                (("1"
                                  (replaces -1)
                                  (("1"
                                    (expand "length" 2)
                                    (("1" (grind) nil)))))
                                 ("2"
                                  (grind)
                                  nil)))))))))))))))))))))))
           ("2" (grind) nil)))
         ("2" (grind) nil) ("3" (grind) nil))))))
    nil)
   nil nil))
 (subl_idemp_TCC1 0
  (subl_idemp_TCC1-1 nil 3644927635 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length def-decl "nat" list_props nil))
   nil))
 (subl_idemp 0
  (subl_idemp-1 nil 3644927656
   ("" (skeep)
    (("" (case "l=null")
      (("1" (replaces -1) (("1" (grind) nil nil)) nil)
       ("2" (generalize-skolem-constants)
        (("1" (induct "l_1")
          (("1" (assert) nil nil)
           ("2" (skolem 1 ("a_" "l_"))
            (("2" (flatten)
              (("2" (split -1)
                (("1" (replaces -1)
                  (("1" (hide 1) (("1" (grind) nil nil)) nil)) nil)
                 ("2" (hide 1)
                  (("2" (expand "^" 1)
                    (("2" (lift-if 1)
                      (("2" (split 1)
                        (("1" (grind) nil nil)
                         ("2" (flatten)
                          (("2" (split 3)
                            (("1" (grind) nil nil)
                             ("2" (flatten)
                              (("2"
                                (use "subl_shr")
                                (("1"
                                  (replaces -1)
                                  (("1"
                                    (expand "length" 2)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil)
           ("3" (grind) nil nil))
          nil)
         ("2" (grind) nil nil) ("3" (grind) nil nil))
        nil))
      nil))
    nil)
   ((null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (^ def-decl "list[T]" more_list_props nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (> const-decl "bool" reals nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (a_ skolem-const-decl "T" more_list_props nil)
    (l_ skolem-const-decl "list[T]" more_list_props nil)
    (above nonempty-type-eq-decl nil integers nil)
    (subl_shr formula-decl nil more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   nil))
 (length_subl 0
  (length_subl-1 nil 3644927692
   ("" (skeep :preds? t)
    (("" (case "n>=length(l)")
      (("1" (use "subl_over_len")
        (("1" (replace -1 1 :hide? t)
          (("1" (case "min(length(l), n + 1) = length(l)")
            (("1" (replace -1 1 :hide? t)
              (("1" (hide -1 -2 -3)
                (("1" (generalize "l" "l_" "(cons?[T])")
                  (("1" (grind) nil nil)
                   ("2" (generalize "m" "m_")
                    (("1" (induct "l_")
                      (("1" (grind) nil nil) ("2" (assert) nil nil)
                       ("3" (skolem 1 ("a_" "l_"))
                        (("3" (flatten)
                          (("3" (skeep)
                            (("3" (case "l_=null")
                              (("1"
                                (hide -2)
                                (("1"
                                  (replaces -1)
                                  (("1"
                                    (expand "length" -1)
                                    (("1"
                                      (expand "length" -1)
                                      (("1"
                                        (expand "length" 1 2)
                                        (("1"
                                          (expand "length" 1 2)
                                          (("1"
                                            (expand "length" 1 2)
                                            (("1"
                                              (expand "length" 1 2)
                                              (("1"
                                                (case "m_=0")
                                                (("1"
                                                  (replaces -1)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (assert)
                                (("2"
                                  (expand "length" -2)
                                  (("2"
                                    (case "m_ =0 ")
                                    (("1"
                                      (replaces -1)
                                      (("1"
                                        (hide -1)
                                        (("1"
                                          (use "subl_idemp")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (use "subl_shr")
                                      (("1"
                                        (replace -1 3 :hide? t)
                                        (("1"
                                          (inst -1 "m_ - 1")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (expand "length" 3 2)
                                              (("1"
                                                (replace -1 3 :hide? t)
                                                (("1" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2" (grind) nil nil)
                                       ("3" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (assert) (("4" (grind) nil nil)) nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil)
                   ("3" (grind) nil nil) ("4" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil)
         ("2" (grind) nil nil))
        nil)
       ("2" (name "k" "n-m")
        (("2" (generalize "k" "k" "nat")
          (("1" (assert) nil nil)
           ("2" (generalize-skolem-constants)
            (("2" (induct "k")
              (("1" (grind) nil nil)
               ("2" (skeep)
                (("2" (skolem 1 ("m_" "l_" "n_") :skolem-typepreds? t)
                  (("2" (assert)
                    (("2" (flatten)
                      (("2" (case "m_ = length(l_)")
                        (("1" (replaces -1) nil nil)
                         ("2" (inst -4 "1+m_" "l_" "n_")
                          (("1" (assert)
                            (("1" (expand "^" 3)
                              (("1"
                                (expand "length" 3 1)
                                (("1"
                                  (replace -4 3 :hide? t)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil)
                           ("3" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (^ def-decl "list[T]" more_list_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (length_null formula-decl nil more_list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (nth def-decl "T" list_props nil)
    (subl_shr formula-decl nil more_list_props nil)
    (above nonempty-type-eq-decl nil integers nil)
    (l_ skolem-const-decl "list[T]" more_list_props nil)
    (a_ skolem-const-decl "T" more_list_props nil)
    (m_ skolem-const-decl "nat" more_list_props nil)
    (> const-decl "bool" reals nil)
    (subl_idemp formula-decl nil more_list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (l skolem-const-decl "{l: list[T] | length(l) >= m}"
     more_list_props nil)
    (n skolem-const-decl "upfrom(m)" more_list_props nil)
    (m skolem-const-decl "nat" more_list_props nil)
    (< const-decl "bool" reals nil)
    (subl_over_len formula-decl nil more_list_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (k skolem-const-decl "int" more_list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (m_ skolem-const-decl "nat" more_list_props nil)
    (l_ skolem-const-decl "{l: list[T] | length(l) >= m_}"
     more_list_props nil)
    (n_ skolem-const-decl "upfrom(m_)" more_list_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   nil))
 (cdr_subl_TCC1 0
  (cdr_subl_TCC1-1 nil 3644927727 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (cdr_subl_TCC2 0
  (cdr_subl_TCC2-1 nil 3644927727 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (^ def-decl "list[T]" more_list_props nil)
    (length def-decl "nat" list_props nil))
   nil))
 (cdr_subl_TCC3 0
  (cdr_subl_TCC3-1 nil 3644927727 ("" (subtype-tcc) nil nil) nil nil))
 (cdr_subl 0
  (cdr_subl-1 nil 3644927744
   ("" (skeep)
    (("" (expand "^" 2 1)
      (("" (lift-if 2)
        (("" (split 2)
          (("1" (grind) nil nil)
           ("2" (flatten)
            (("2" (lemma "subl_shr")
              (("2" (inst -1 "car(l)" "cdr(l)" "1+m" "n")
                (("2" (assert)
                  (("2" (replaces -1 :dir rl)
                    (("2" (case "l = cons(car(l),cdr(l))")
                      (("1" (assert) nil nil)
                       ("2" (apply-extensionality) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((^ def-decl "list[T]" more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (subl_shr formula-decl nil more_list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (member_nth_subl_TCC1 0
  (member_nth_subl_TCC1-1 nil 3644930796 ("" (subtype-tcc) nil nil) nil
   nil))
 (member_nth_subl 0
  (member_nth_subl-1 nil 3644927781
   ("" (induct "j")
    (("1" (grind) nil nil)
     ("2" (skolem 1 "k")
      (("2" (flatten)
        (("2" (skeep :preds? t)
          (("2" (expand "member" 1)
            (("2" (lift-if 1)
              (("2" (split 1)
                (("1" (grind) nil nil)
                 ("2" (flatten)
                  (("2" (expand "nth" 3)
                    (("2" (inst -4 "cdr(l)" "m" "n-1")
                      (("1" (use "cdr_subl")
                        (("1" (assert) nil nil)
                         ("2" (case "n=m")
                          (("1" (replaces -1)
                            (("1" (case "m=k+1")
                              (("1"
                                (replaces -1)
                                (("1" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (case "m=k+1")
                        (("1" (replaces -1)
                          (("1" (expand "^" 3) (("1" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil)
                       ("3" (expand "length" -1)
                        (("3" (lift-if -1)
                          (("3" (split -1)
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (l skolem-const-decl "{l: list[T] | 1 + k < length(l)}"
     more_list_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (> const-decl "bool" reals nil)
    (n skolem-const-decl "upfrom(1 + k)" more_list_props nil)
    (above nonempty-type-eq-decl nil integers nil)
    (cdr_subl formula-decl nil more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (k skolem-const-decl "nat" more_list_props nil)
    (m skolem-const-decl "upto(1 + k)" more_list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (^ def-decl "list[T]" more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (member def-decl "bool" list_props nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (nth_subl_prefix_TCC1 0
  (nth_subl_prefix_TCC1-1 nil 3644927801 ("" (subtype-tcc) nil nil) nil
   nil))
 (nth_subl_prefix_TCC2 0
  (nth_subl_prefix_TCC2-1 nil 3644927801
   ("" (skeep :preds? t)
    (("" (use "length_subl")
      (("1" (assert) nil nil)
       ("2" (assert) (("2" (grind) nil nil)) nil)
       ("3" (grind) nil nil))
      nil))
    nil)
   ((length_subl formula-decl nil more_list_props nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (j skolem-const-decl "nat" more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (^ def-decl "list[T]" more_list_props nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (m skolem-const-decl "nat" more_list_props nil)
    (n skolem-const-decl "{n: nat | j < length(l ^ (m, n))}"
     more_list_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (nth_subl_prefix 0
  (nth_subl_prefix-1 nil 3644927815
   ("" (induct "j")
    (("1" (skeep :preds? t)
      (("1" (expand "nth" 1 1)
        (("1" (expand "^" 1)
          (("1" (lift-if 1)
            (("1" (split 1)
              (("1" (grind) nil nil) ("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skolem 1 "k")
      (("2" (flatten)
        (("2" (skeep :preds? t)
          (("2" (expand "nth" 1)
            (("2" (inst -3 "cdr(l)" "m" "n-1")
              (("1" (use "cdr_subl")
                (("1" (assert) (("1" (grind) nil nil)) nil)
                 ("2" (hide-all-but (-2 1))
                  (("2" (expand "^" -1)
                    (("2" (lift-if -1)
                      (("2" (split -1)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (split 1)
                (("1" (case "n=1")
                  (("1" (replaces -1) (("1" (grind) nil nil)) nil)
                   ("2" (case "n=0")
                    (("1" (replaces -1)
                      (("1" (case "m=0")
                        (("1" (replaces -1)
                          (("1" (expand "^" -2)
                            (("1" (lift-if -2)
                              (("1"
                                (split -2)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (case "NOT null?(l ^ (m, n))")
                  (("1" (use "cdr_subl")
                    (("1" (assert)
                      (("1" (replaces -1 :dir rl)
                        (("1" (expand "length" -2)
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (hide-all-but (-2 1))
                      (("2" (expand "^" -1)
                        (("2" (lift-if -1) (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skeep :preds? t)
        (("3" (use "length_subl")
          (("1" (assert) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((length_subl formula-decl nil more_list_props nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (n skolem-const-decl "{n: nat | j < length(l ^ (m, n))}"
     more_list_props nil)
    (m skolem-const-decl "nat" more_list_props nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (j skolem-const-decl "nat" more_list_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (k skolem-const-decl "nat" more_list_props nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (m skolem-const-decl "nat" more_list_props nil)
    (n skolem-const-decl "{n: nat | 1 + k < length(l ^ (m, n))}"
     more_list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (cdr_subl formula-decl nil more_list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil) (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (^ def-decl "list[T]" more_list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (subl_incl 0
  (subl_incl-1 nil 3644930849
   ("" (skeep :preds? t)
    (("" (skeep :preds? t)
      (("" (use "member_nth")
        (("" (assert)
          (("" (skeep)
            (("" (use "nth_subl_prefix")
              (("" (lemma "member_nth_subl")
                (("" (inst -1 "m+i" "l" "m_" "n_")
                  (("1" (assert) nil nil)
                   ("2" (typepred "i")
                    (("2" (use "length_subl")
                      (("1" (assert) nil nil)
                       ("2" (assert) (("2" (grind) nil nil)) nil)
                       ("3" (grind) nil nil))
                      nil))
                    nil)
                   ("3" (typepred "i")
                    (("3" (use "length_subl")
                      (("1" (assert) nil nil) ("2" (grind) nil nil)
                       ("3" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nth_subl_prefix formula-decl nil more_list_props nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (m skolem-const-decl "nat" more_list_props nil)
    (n skolem-const-decl "nat" more_list_props nil)
    (i skolem-const-decl "below(length(l ^ (m, n)))" more_list_props
     nil)
    (n_ skolem-const-decl "upfrom(n)" more_list_props nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (length_subl formula-decl nil more_list_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member_nth_subl formula-decl nil more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (^ def-decl "list[T]" more_list_props nil)
    (member_nth formula-decl nil more_list_props nil))
   shostak))
 (take_TCC1 0
  (take_TCC1-1 nil 3647949757 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (take_TCC2 0
  (take_TCC2-1 nil 3647949757 ("" (termination-tcc) nil nil) nil nil))
 (take_TCC3 0
  (take_TCC3-1 nil 3647949757 ("" (tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length def-decl "nat" list_props nil))
   nil))
 (length_take 0
  (length_take-1 nil 3647949758
   ("" (induct "n")
    (("1" (expand "take" 1)
      (("1" (skolem 1 ("l_"))
        (("1" (lift-if)
          (("1" (split)
            (("1" (flatten) (("1" (grind) nil nil)) nil)
             ("2" (flatten) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skolem 1 ("n_"))
      (("2" (flatten)
        (("2" (skolem 1 ("l_"))
          (("2" (expand "take" 1)
            (("2" (lift-if)
              (("2" (split)
                (("1" (flatten) (("1" (grind) nil nil)) nil)
                 ("2" (flatten)
                  (("2" (inst -1 "cdr(l_)")
                    (("2" (expand "length" 2 1)
                      (("2" (replace -1 2)
                        (("2" (expand "length" 2 2)
                          (("2" (lift-if)
                            (("2" (split)
                              (("1"
                                (flatten)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (take def-decl "list[T]" more_list_props nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (nth_take_TCC1 0
  (nth_take_TCC1-1 nil 3647949757 ("" (subtype-tcc) nil nil) nil nil))
 (nth_take 0
  (nth_take-1 nil 3647949867
   ("" (induct "l")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("h" "t"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "nth" 1)
            (("2" (lift-if 1)
              (("2" (split 1)
                (("1" (flatten)
                  (("1" (expand "take" 1)
                    (("1" (expand "member" 1) (("1" (propax) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "take" 2)
                    (("2" (expand "member" 2)
                      (("2" (flatten)
                        (("2" (inst -1 "i-1" "j-1")
                          (("1" (assert) nil nil)
                           ("2" (typepred "i")
                            (("2" (expand "length" -1)
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (h skolem-const-decl "T" more_list_props nil)
    (t skolem-const-decl "list[T]" more_list_props nil)
    (i skolem-const-decl "below(1 + length(cons(h, t)))"
     more_list_props nil)
    (j skolem-const-decl "{j: nat | j < i}" more_list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (take def-decl "list[T]" more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (member def-decl "bool" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (nth_take2_TCC1 0
  (nth_take2_TCC1-1 nil 3647949757
   ("" (skeep)
    (("" (typepred "j")
      (("" (use "length_take") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (take def-decl "list[T]" more_list_props nil)
    (length_take formula-decl nil more_list_props nil))
   nil))
 (nth_take2 0
  (nth_take2-1 nil 3647949887
   ("" (induct "i")
    (("1" (grind) nil nil)
     ("2" (skolem 1 "i")
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "take" 1)
            (("2" (lift-if 1)
              (("2" (split 1)
                (("1" (flatten)
                  (("1" (inst -2 "l" "j")
                    (("1" (typepred "j") (("1" (assert) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "nth" 2 1)
                    (("2" (lift-if 2)
                      (("2" (split 2)
                        (("1" (flatten)
                          (("1" (replaces -1)
                            (("1" (expand "nth" 1)
                              (("1" (propax) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (expand "nth" 2 2)
                            (("2" (assert)
                              (("2"
                                (inst -1 "cdr(l)" "j-1")
                                (("2"
                                  (typepred "j")
                                  (("2"
                                    (expand "length" -2 1)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skeep)
        (("3" (use "length_take")
          (("3" (typepred "j") (("3" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((length_take formula-decl nil more_list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (j skolem-const-decl "{j: nat | j < 1 + i AND j < length(l)}"
     more_list_props nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (i skolem-const-decl "nat" more_list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (take def-decl "list[T]" more_list_props nil))
   shostak))
 (take_null 0
  (take_null-1 nil 3647949914
   ("" (induct "i")
    (("1" (grind) nil nil)
     ("2" (skeep)
      (("2" (expand "take" 1)
        (("2" (lift-if 1)
          (("2" (split 1)
            (("1" (flatten) nil nil)
             ("2" (flatten) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (take def-decl "list[T]" more_list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (take_prop_1 0
  (take_prop_1-1 nil 3647949930
   ("" (skeep)
    (("" (typepred "i")
      (("" (merge-fnums *)
        ((""
          (case "FORALL(i: nat): i > length(l) IMPLIES take(l, i) = take(l, length(l))")
          (("1" (inst?) nil nil)
           ("2" (hide 2)
            (("2" (induct "i")
              (("1" (typepred "length(l)") (("1" (assert) nil nil))
                nil)
               ("2" (skeep)
                (("2" (case "j=length(l)")
                  (("1" (replace -1 1) (("1" (grind) nil nil)) nil)
                   ("2" (split -1)
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((above nonempty-type-eq-decl nil integers nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (take def-decl "list[T]" more_list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   shostak))
 (take_prop_2 0
  (take_prop_2-1 nil 3647949952
   ("" (induct " l") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (length def-decl "nat" list_props nil)
    (take def-decl "list[T]" more_list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (member_take_1 0
  (member_take_1-1 nil 3647949973
   ("" (induct "i")
    (("1" (grind) nil nil)
     ("2" (skolem 1 "i_")
      (("2" (flatten)
        (("2" (skeep*)
          (("2" (expand "take" -2)
            (("2" (lift-if -2)
              (("2" (split -2)
                (("1" (flatten)
                  (("1" (inst?)
                    (("1" (inst -3 "j" "x") (("1" (assert) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "member" -1)
                    (("2" (case "j>length(l)")
                      (("1" (use "take_prop_1")
                        (("1" (replace -1 2 :hide? t)
                          (("1" (expand "take" 2)
                            (("1" (lift-if 2)
                              (("1"
                                (split 2)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "take" 3)
                        (("2" (assert)
                          (("2" (case "j-1 = i_")
                            (("1" (assert) nil nil)
                             ("2" (inst -2 "cdr(l)" "j-1" "x")
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i_ skolem-const-decl "nat" more_list_props nil)
    (j skolem-const-decl "above(1 + i_)" more_list_props nil)
    (l skolem-const-decl "list[T]" more_list_props nil)
    (take_prop_1 formula-decl nil more_list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (take def-decl "list[T]" more_list_props nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak)))

