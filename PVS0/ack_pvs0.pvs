ack_pvs0 : THEORY

  BEGIN

  T : TYPE = [nat,nat]

  IMPORTING pvs0_cc[T]

  boole(b:bool) : Val = IF NOT b THEN (0,0) ELSE (1,1) ENDIF

  eop1(op:nat)(m,n:nat) : Val = 
    COND op = 0 -> boole(m=0),
         op = 1 -> boole(n=0),
         op = 2 -> (n+1,0),
         op = 3 -> IF m /= 0 THEN (m-1,1) ELSE (m,n) ENDIF,
	 op = 4 -> IF n /= 0 THEN (m,n-1) ELSE (m,n) ENDIF,
         ELSE -> (m,n)
    ENDCOND

  eop2(op:nat)(v1,v2:Val) : Val = 
    IF v1`1 > 0 THEN (v1`1-1,v2`1) ELSE v1 ENDIF


  pvs0_ack : PVS0 = ((0,0),eop1,eop2,
  	             ite(op1(0,vr), op1(2,vr),
                         ite(op1(1,vr),rec(op1(3,vr)),
                             rec(op2(0,vr,rec(op1(4,vr)))))))

  MT : TYPE = nat
  lt : (well_founded?[MT]) = LAMBDA (m,n:nat): m < n
  N  : posnat = 2

  IMPORTING CCG@ccg_to_mwg[Val[T], PVS0Expr[Val[T]], Conditions[T],
             MT,lt,N,
             LAMBDA (expr: PVS0Expr[Val[T]], env, val: Val[T]):
             semantic_rel_expr(pvs0_ack`1,pvs0_ack`2,pvs0_ack`3)
                              (expr, pvs0_ack`4,
                               env, val),
           LAMBDA (conds: Conditions[T], env: Val[T]):
             eval_conds(pvs0_ack, conds, env)]

  M1 : FunMeasure = LAMBDA (v:Val) : v`1
  M2 : FunMeasure = LAMBDA (v:Val) : v`2

  ack_measures: FunMeasures = 
     LAMBDA (i:below(2)): 
       IF i = 0 THEN M1
       ELSE M2
       ENDIF 

  IMPORTING ccg_to_pvs0 [T,MT,lt,N]	 

  IMPORTING scp_iff_pvs0[T]

  IMPORTING CCG@bounding_circuits[CallingContext,N]

  % Matrices taken from Andrea's slides
  
  A0: Measure_Matrix = (: (:  1 ,  0 :),
      		          (: -1 , -1 :) :)
  
  A1: Measure_Matrix = (: (:  1 , -1 :),
      		          (: -1 , -1 :) :)

  A2: Measure_Matrix = (: (:  0 , -1 :),
      		          (: -1 , -1 :) :)
 
  ack_dg : (cdigraph) = pvs0_to_dg(pvs0_ack)

  ack_ccg: CCG = make_ccg(ack_dg,ack_measures)

  ack_mm: (indi_f_sound(ack_ccg)) =
   LAMBDA(v: vert(dg(ack_ccg))):
     IF v`actuals = op1(3, vr)  THEN A0  % node 0
     ELSIF v`actuals = op2(0, vr, rec(op1(4, vr))) THEN A1 % node 1
     ELSE A2 % node 2
     ENDIF

  ack_wgd: wdg = ccg_to_mwg(ack_ccg)(ack_mm)

  pvs0_ack_tcc_termination: JUDGEMENT
    pvs0_ack HAS_TYPE (pvs0_tcc_termination)

  ack_msr : CONJECTURE
    EXISTS (m:WFM): pvs0_tcc_termination_pred(pvs0_ack)(m)
    
  ack_terminates: CONJECTURE terminating?(pvs0_ack)
    
  ack_wfm  : (pvs0_tcc_termination_pred(pvs0_ack))

  ack_pvs0(m,n:nat): nat = Omega_eval(pvs0_ack)(m,n)`1

  ack_pvs0_m_n : LEMMA
    FORALL (m:nat,n:nat): ack_pvs0(m,n) = 
      IF m = 0 THEN n+1
      ELSIF n = 0 THEN ack_pvs0(m-1,1)
      ELSE ack_pvs0(m-1,ack_pvs0(m,n-1))
      ENDIF

END ack_pvs0
