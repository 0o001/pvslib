ack : THEORY
BEGIN

  ack(m,n:nat) : RECURSIVE nat =
    IF m = 0 THEN n+1
    ELSIF n = 0 THEN ack(m-1,1)
      ELSE ack(m-1,ack(m,n-1))
    ENDIF
  MEASURE lex2(m,n)


  IMPORTING lang[[nat,nat]]

  ebool(m,n:nat) : bool = m /= 0

  boole(b:bool) : Val = (IF NOT b THEN 0 ELSE 1 ENDIF,0)

  eop1(op:nat)(m,n:nat) : Val = 
    COND op = 0 -> boole(m=0),
         op = 1 -> boole(n=0),
         op = 2 -> (n+1,0),
         op = 3 -> IF m /= 0 THEN (m-1,1) ELSE (m,n) ENDIF,
	 op = 4 -> IF n /= 0 THEN (m,n-1) ELSE (m,n) ENDIF,
         ELSE -> (m,n)
    ENDCOND

  eop2(op:nat)(v1,v2:Val) : Val = 
    IF v1`1 > 0 THEN (v1`1-1,v2`1) ELSE v1 ENDIF

% Interpretation:
%   vr        : (m,n)
%   bool(m,n) : m /= 0
%   op1 0     : (m,n) -> bool(m=0)
%   op1 1     : (m,n) -> bool(n=0)
%   op1 2     : (m,n) -> (n+1,0)
%   op1 3     : (m,n) -> (m-1,1)
%   op1 4     : (m,n) -> (m,n-1)
%   op2 0     : (m1,n1),(m2,n2) -> (m1-1,m2)

  pvs0_ack : PVS0 = def(ite(op1(0,vr),
                            op1(2,vr),
                            ite(op1(1,vr),
                                rec(op1(3,vr)),
                                rec(op2(0,vr,rec(op1(4,vr))))
				)
                           )
                        )

  eval_ack(m,n:nat) : nat =
    LET v = eval(ebool,eop1,eop2)(100,pvs0_ack)(val2env(m,n)) IN
    IF some?(v) THEN val(v)`1
    ELSE 0
    ENDIF

  pvs0_ack02 : LEMMA
    ack(0,2) = eval_ack(0,2)

  pvs0_ack20 : LEMMA
    ack(2,0) = eval_ack(2,0)

  pvs0_ack23 : LEMMA
    ack(2,3) = eval_ack(2,3)

  IMPORTING pvs0_to_ccg[[nat,nat],nat,<,2]

  verts : list[CallingContext] = pvs0_to_ccg_verts_sl(pvs0_ack)

  cc1 : CallingContext = nth(verts,2)

  cc2 : CallingContext = nth(verts,1)

  cc3 : CallingContext = nth(verts,0)

  remove_cc1_cc1 : LEMMA 
    remove_edge(ebool,eop1,eop2)(pvs0_ack,cc1,cc1)

  remove_cc2_cc2 : LEMMA 
    remove_edge(ebool,eop1,eop2)(pvs0_ack,cc2,cc2)

  remove_cc3_cc3 : LEMMA 
    remove_edge(ebool,eop1,eop2)(pvs0_ack,cc3,cc3)


END ack
