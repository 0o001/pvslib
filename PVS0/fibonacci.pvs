fibonacci : THEORY
BEGIN

  fibonacci(n:nat) : RECURSIVE nat =
    IF n = 0 OR n = 1 THEN 1
    ELSE fibonacci(n - 1) + fibonacci(n - 2)
    ENDIF
  MEASURE n

  IMPORTING lang[nat]

  ebool(n:nat) : bool = n /= 0

  eop1(op:nat)(n:nat) : nat = 
    COND op = 0 -> IF n = 0 THEN 1 ELSE 0 ENDIF,
         op = 1 -> IF n = 0 THEN 0 ELSE n-1 ENDIF,
         op = 2 -> IF (n = 0 OR n = 1) THEN 1 ELSE 0 ENDIF,
         ELSE -> 0
    ENDCOND

  eop2(op:nat)(n,m:nat) : nat = 
    COND op = 0 ->  n*m,
         op = 1 ->  n+m,
         ELSE -> 0
    ENDCOND

  pvs0_fibonacci : PVS0 = 
     def(ite(op1(2,vr),cnst(1),op2(1,rec(op1(1,vr)), rec(op1(1,op1(1,vr))))))

  eval_fibo(n : nat) : nat =
     val(eval(ebool, eop1, eop2)(n + 1, pvs0_fibonacci)(val2env(n)))

  pvs0_fibo1 : LEMMA
     eval_fibo(5) = fibonacci(5)

  pvs0_fibo0 : LEMMA
     eval_fibo(0) = fibonacci(0)

  pvs0_fibo2 : LEMMA
    FORALL (n:nat) : eval_fibo(n) = fibonacci(n)

  IMPORTING pvs0_to_ccg[nat,nat,<,2]

  verts : list[CallingContext] = pvs0_to_ccg_verts_sl(pvs0_fibonacci)

  cc1 : CallingContext = nth(verts,1)

  cc2 : CallingContext = nth(verts,0)

  remove_cc1_cc1 : LEMMA  % No edge is eliminated
    remove_edge(ebool, eop1, eop2)(pvs0_fibonacci,cc1,cc1)

  remove_cc1_cc2 : LEMMA   % No edge is eliminated
    remove_edge(ebool, eop1, eop2)(pvs0_fibonacci,cc1,cc2)

  remove_cc2_cc1 : LEMMA   % No edge is eliminated
    remove_edge(ebool, eop1, eop2)(pvs0_fibonacci,cc2,cc1)

  remove_cc2_cc2 : LEMMA   % No edge is eliminated
    remove_edge(ebool, eop1, eop2)(pvs0_fibonacci,cc2,cc2)

END fibonacci
