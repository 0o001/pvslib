(pvs0_lang
 (semantic_rel_expr_TCC1 0
  (semantic_rel_expr_TCC1-1 nil 3603051502 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil))
   nil))
 (semantic_rel_expr_TCC2 0
  (semantic_rel_expr_TCC2-1 nil 3603051502 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil))
   nil))
 (semantic_rel_expr_TCC3 0
  (semantic_rel_expr_TCC3-1 nil 3603051502 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil))
   nil))
 (semantic_rel_expr_TCC4 0
  (semantic_rel_expr_TCC4-1 nil 3603051502 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil))
   nil))
 (eval_expr_TCC1 0
  (eval_expr_TCC1-1 nil 3602330945
   ("" (skeep*)
    (("" (lemma "lex2_lt")
      (("" (inst -1 "i" "sizepvs0(arg)" "i" "sizepvs0(expr)")
        (("" (assert)
          (("" (hide 3)
            (("" (expand* "sizepvs0" "restrict")
              (("" (replaces -1)
                (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[PVS0 -> nat]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (sizepvs0 const-decl "[PVS0 -> nat]" pvs0_lang nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (eval_expr_TCC2 0
  (eval_expr_TCC2-1 nil 3602330945
   ("" (skeep*)
    (("" (replaces -1)
      (("" (hide -1)
        (("" (lemma "lex2_lt")
          ((""
            (inst -1 "i" "sizepvs0(arg2)" "i"
             "sizepvs0(op2(op, arg1, arg2))")
            (("" (assert)
              (("" (hide 3)
                (("" (expand "sizepvs0")
                  (("" (expand "reduce_nat" 1 2)
                    (("" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reduce_nat adt-def-decl "[PVS0 -> nat]" PVS0_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (op2 adt-constructor-decl "[[nat, Expr, Expr] -> (op2?)]" PVS0_adt
     nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (sizepvs0 const-decl "[PVS0 -> nat]" pvs0_lang nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (eval_expr_TCC3 0
  (eval_expr_TCC3-1 nil 3602330945
   ("" (skeep*)
    (("" (lemma "lex2_lt")
      (("" (inst -1 "i" "sizepvs0(arg1)" "i" "sizepvs0(expr)")
        (("" (assert)
          (("" (hide 3)
            (("" (expand* "sizepvs0" "restrict")
              (("" (replaces -1)
                (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[PVS0 -> nat]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (sizepvs0 const-decl "[PVS0 -> nat]" pvs0_lang nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (eval_expr_TCC4 0
  (eval_expr_TCC4-1 nil 3602330945
   ("" (skeep*)
    (("" (hide -2 -3 -4)
      (("" (lemma "lex2_lt")
        (("" (inst -1 "i" "sizepvs0(arg1)" "i" "sizepvs0(expr)")
          (("" (assert)
            (("" (hide 3)
              (("" (expand* "sizepvs0" "restrict")
                (("" (replaces -1)
                  (("" (expand "reduce_nat" 1 2)
                    (("" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (sizepvs0 const-decl "[PVS0 -> nat]" pvs0_lang nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (reduce_nat adt-def-decl "[PVS0 -> nat]" PVS0_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex2_lt formula-decl nil lex2 nil))
   nil))
 (eval_expr_TCC5 0
  (eval_expr_TCC5-1 nil 3602330945
   ("" (skeep*)
    (("" (hide -2 -3 2)
      (("" (lemma "lex2_lt")
        (("" (inst -1 "i" "sizepvs0(arg2)" "i" "sizepvs0(expr)")
          (("" (assert)
            (("" (hide 3)
              (("" (expand* "sizepvs0" "restrict")
                (("" (replaces -1)
                  (("" (expand "reduce_nat" 1 2)
                    (("" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (sizepvs0 const-decl "[PVS0 -> nat]" pvs0_lang nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (reduce_nat adt-def-decl "[PVS0 -> nat]" PVS0_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lex2_lt formula-decl nil lex2 nil))
   nil))
 (eval_expr_TCC6 0
  (eval_expr_TCC6-1 nil 3602330945
   ("" (skeep*)
    (("" (lemma "lex2_lt")
      (("" (inst -1 "i" "sizepvs0(cnd)" "i" "sizepvs0(expr)")
        (("" (assert)
          (("" (hide 3)
            (("" (replaces -1)
              (("" (expand* "sizepvs0" "restrict")
                (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[PVS0 -> nat]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (sizepvs0 const-decl "[PVS0 -> nat]" pvs0_lang nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (eval_expr_TCC7 0
  (eval_expr_TCC7-1 nil 3602330945 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (eval_expr_TCC8 0
  (eval_expr_TCC8-1 nil 3602330945
   ("" (skeep*)
    (("" (lemma "lex2_lt")
      (("" (inst -1 "i-1" "sizepvs0(body)" "i" "sizepvs0(expr)")
        (("1" (assert) nil nil)
         ("2" (hide 3)
          (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((lex2_lt formula-decl nil lex2 nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (sizepvs0 const-decl "[PVS0 -> nat]" pvs0_lang nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (i skolem-const-decl "nat" pvs0_lang nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (eval_expr_TCC9 0
  (eval_expr_TCC9-1 nil 3602330945
   ("" (skeep*)
    (("" (lemma "lex2_lt")
      (("" (inst -1 "i" "sizepvs0(arg)" "i" "sizepvs0(expr)")
        (("" (assert)
          (("" (hide 3)
            (("" (expand* "sizepvs0" "restrict")
              (("" (replaces -1)
                (("" (expand "reduce_nat" 1 2) (("" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lex2_lt formula-decl nil lex2 nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[PVS0 -> nat]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (sizepvs0 const-decl "[PVS0 -> nat]" pvs0_lang nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (eval_expr_TCC10 0
  (eval_expr_TCC10-1 nil 3602330945
   ("" (skeep) (("" (typepred "expr") (("" (assert) nil nil)) nil))
    nil)
   ((Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (eval_expr_ge_n_j_TCC1 0
  (eval_expr_ge_n_j_TCC1-1 nil 3603101849
   ("" (skeep) (("" (assert) nil nil)) nil) nil nil))
 (eval_expr_ge_n_j_TCC2 0
  (eval_expr_ge_n_j_TCC2-1 nil 3603101849
   ("" (skeep)
    (("" (skeep 2)
      (("" (assert)
        (("" (skeep 2 :preds? t)
          (("" (replaces -2)
            (("" (expand "eval_expr") (("" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((eval_expr def-decl "Maybe[Val]" pvs0_lang nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (eval_expr_ge_n_j_TCC3 0
  (eval_expr_ge_n_j_TCC3-1 nil 3603101849
   ("" (skeep)
    (("" (assert)
      (("" (skeep 2)
        (("" (replaces -1)
          (("" (expand "eval_expr") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_lang nil))
   nil))
 (eval_expr_ge_n_j_TCC4 0
  (eval_expr_ge_n_j_TCC4-1 nil 3603101849
   ("" (skeep)
    (("" (skeep 2)
      (("" (skeep 2 :preds? t)
        (("" (assert)
          (("" (skeep 2)
            (("" (replaces -2)
              (("" (insteep -1)
                (("" (expand "eval_expr" 2) (("" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_lang nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (upfrom nonempty-type-eq-decl nil integers nil))
   nil))
 (eval_expr_ge_n_j_TCC5 0
  (eval_expr_ge_n_j_TCC5-2 nil 3603102572 ("" (assert) nil nil) nil
   nil)
  (eval_expr_ge_n_j_TCC5-1 nil 3603101849
   ("" (recursive-judgement-tcc) nil nil) nil nil))
 (eval_expr_ge_n_j_TCC6 0
  (eval_expr_ge_n_j_TCC6-2 nil 3603102676
   ("" (skeep)
    (("" (skeep 2)
      (("" (skeep 2 :preds? t)
        (("" (assert)
          (("" (skeep 2 :preds? t)
            (("" (assert)
              (("" (skeep 2)
                (("" (replaces -3)
                  (("" (insteep -1)
                    (("" (insteep -2)
                      (("" (expand "eval_expr" 2)
                        (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((eval_expr def-decl "Maybe[Val]" pvs0_lang nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (upfrom nonempty-type-eq-decl nil integers nil))
   nil)
  (eval_expr_ge_n_j_TCC6-1 nil 3603101849
   ("" (recursive-judgement-tcc) nil nil) nil nil))
 (eval_expr_ge_n_j_TCC7 0
  (eval_expr_ge_n_j_TCC7-1 nil 3603101849 ("" (assert) nil nil) nil
   nil))
 (eval_expr_ge_n_j_TCC8 0
  (eval_expr_ge_n_j_TCC8-2 nil 3603103146
   ("" (skeep)
    (("" (skeep 2)
      (("" (skeep 2 :preds? t)
        (("" (assert)
          ((""
            (typepred
             "v3(eval_bool, eval_op1, eval_op2)(n, arg1, body, env)")
            (("" (assert)
              (("" (skeep 2)
                (("" (insteep -1)
                  (("" (insteep -2)
                    (("" (replaces -3)
                      (("" (expand "eval_expr" 2)
                        (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_lang nil))
   nil)
  (eval_expr_ge_n_j_TCC8-1 nil 3603101849
   ("" (recursive-judgement-tcc) nil nil) nil nil))
 (eval_expr_ge_n_j_TCC9 0
  (eval_expr_ge_n_j_TCC9-2 nil 3603103387
   ("" (skeep)
    (("" (skeep 2)
      (("" (skeep 2 :preds? t)
        (("" (assert)
          ((""
            (typepred
             "v3(eval_bool, eval_op1, eval_op2)(n, arg2, body, env)")
            (("" (assert)
              (("" (skeep 3)
                (("" (insteep -1)
                  (("" (insteep -2)
                    (("" (replaces -3)
                      (("" (expand "eval_expr" 3)
                        (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_lang nil))
   nil))
 (eval_expr_ge_n_j_TCC10 0
  (eval_expr_ge_n_j_TCC10-1 nil 3603101849 ("" (assert) nil nil) nil
   nil))
 (eval_expr_ge_n_j_TCC11 0
  (eval_expr_ge_n_j_TCC11-1 nil 3603101849
   ("" (skosimp*) (("" (assert) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (eval_expr_ge_n_j_TCC12 0
  (eval_expr_ge_n_j_TCC12-2 nil 3603103536
   ("" (skeep)
    (("" (skeep 2)
      (("" (skeep 2 :preds? t)
        (("" (assert)
          ((""
            (typepred
             "v3(eval_bool, eval_op1, eval_op2)(n - 1, body, body, LAMBDA(vv:(vr?)):val[T](v))")
            (("" (assert)
              (("" (flatten)
                (("" (skeep 2)
                  (("" (insteep -3)
                    (("" (replaces -4)
                      (("" (expand "eval_expr" 2)
                        (("" (assert)
                          (("" (inst -2 "m-1") (("" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_lang nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/"))
   nil)
  (eval_expr_ge_n_j_TCC12-1 nil 3603101849
   ("" (recursive-judgement-tcc) nil nil) nil nil))
 (eval_expr_ge_n_j_TCC13 0
  (eval_expr_ge_n_j_TCC13-1 nil 3603101849 ("" (assert) nil nil) nil
   nil))
 (eval_expr_ge_n 0
  (eval_expr_ge_n-1 nil 3603061172
   ("" (skeep*)
    (("" (skoletin 1)
      (("" (flatten)
        (("" (lemma "eval_expr_ge_n_j")
          (("" (insteep -1)
            (("" (assert)
              (("" (flatten)
                (("" (insteep -) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_lang nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          n > 0 AND
           (FORALL (m: upfrom(n)):
              myv =
               eval_expr(eval_bool, eval_op1, eval_op2)
                        (m, expr, body, env))}" pvs0_lang nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (eval_expr_ge_n_j recursive-judgement-axiom nil pvs0_lang nil))
   shostak))
 (semantic_rel_eval_expr 0
  (semantic_rel_eval_expr-2 nil 3603111426
   ("" (skeep*)
    (("" (lemma "semantic_rel_expr_induction")
      (("" (insteep -1 :but "P")
        ((""
          (inst -1
           "LAMBDA(x:Expr,e:Environment,v:Val):EXISTS (n:posnat): LET myv = eval_expr(eval_bool,eval_op1,eval_op2)(n,x,body,e) IN
                                    some?(myv) AND v=val(myv)")
          (("" (split -)
            (("1" (inst?)
              (("1" (assert)
                (("1" (skeep)
                  (("1" (inst?) (("1" (assert) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (hide -1 2)
              (("2" (skosimp*)
                (("2" (split -)
                  (("1" (flatten)
                    (("1" (inst 1 "1")
                      (("1" (expand "eval_expr")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (inst 1 "1")
                      (("2" (expand "eval_expr")
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("3" (flatten)
                    (("3" (skeep -2)
                      (("3" (skeep -3)
                        (("3" (insteep 1)
                          (("3" (beta)
                            (("3" (flatten)
                              (("3"
                                (expand "eval_expr" +)
                                (("3" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("4" (flatten)
                    (("4" (skeep -2)
                      (("4" (skolem -3 "n1")
                        (("4" (skoletin -3 :postfix "1")
                          (("4" (skolem -6 "n2")
                            (("4" (skoletin -6 :postfix "2")
                              (("4"
                                (flatten)
                                (("4"
                                  (inst 1 "max(n1,n2)")
                                  (("4"
                                    (skoletin 1)
                                    (("4"
                                      (lemma "eval_expr_ge_n")
                                      (("4"
                                        (copy -1)
                                        (("4"
                                          (insteep
                                           -1
                                           :but
                                           (("n" "n1")
                                            ("m" "max(n1,n2)")
                                            ("expr" "get_arg1(expr!1)")
                                            ("env" "env!1")))
                                          (("1"
                                            (replace -9 :dir rl)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (insteep
                                                   -2
                                                   :but
                                                   (("n" "n2")
                                                    ("m" "max(n1,n2)")
                                                    ("expr"
                                                     "get_arg2(expr!1)")
                                                    ("env" "env!1")))
                                                  (("1"
                                                    (replace
                                                     -6
                                                     :dir
                                                     rl)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand
                                                         "eval_expr"
                                                         -3)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (replaces
                                                             -3)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (rewrite "max_ge")
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("5" (flatten)
                    (("5" (skeep -2)
                      (("5" (skolem -3 "n1")
                        (("5" (skoletin -3 :postfix "1")
                          (("5" (lemma "eval_expr_ge_n")
                            (("5" (copy -1)
                              (("5"
                                (split -7)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (skolem -3 "n2")
                                    (("1"
                                      (skoletin -3 :postfix "2")
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (inst 1 "max(n1,n2)")
                                          (("1"
                                            (skoletin 1)
                                            (("1"
                                              (insteep
                                               -7
                                               :but
                                               (("n" "n1")
                                                ("m" "max(n1,n2)")
                                                ("expr"
                                                 "get_cond(expr!1)")
                                                ("env" "env!1")))
                                              (("1"
                                                (replace -11 :dir rl)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (insteep
                                                       -8
                                                       :but
                                                       (("n" "n2")
                                                        ("m"
                                                         "max(n1,n2)")
                                                        ("expr"
                                                         "get_if(expr!1)")
                                                        ("env"
                                                         "env!1")))
                                                      (("1"
                                                        (replace
                                                         -4
                                                         :dir
                                                         rl)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (expand
                                                             "eval_expr"
                                                             -1)
                                                            (("1"
                                                              (replaces
                                                               -1)
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (rewrite "max_ge")
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (skolem -2 "n2")
                                    (("2"
                                      (skoletin -2 :postfix "2")
                                      (("2"
                                        (flatten)
                                        (("2"
                                          (inst 2 "max(n1,n2)")
                                          (("2"
                                            (skoletin 2)
                                            (("2"
                                              (insteep
                                               -6
                                               :but
                                               (("n" "n1")
                                                ("m" "max(n1,n2)")
                                                ("expr"
                                                 "get_cond(expr!1)")
                                                ("env" "env!1")))
                                              (("1"
                                                (replace -10 :dir rl)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (insteep
                                                       -7
                                                       :but
                                                       (("n" "n2")
                                                        ("m"
                                                         "max(n1,n2)")
                                                        ("expr"
                                                         "get_else(expr!1)")
                                                        ("env"
                                                         "env!1")))
                                                      (("1"
                                                        (replace
                                                         -4
                                                         :dir
                                                         rl)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (expand
                                                             "eval_expr"
                                                             -1)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (rewrite "max_ge")
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("6" (flatten)
                    (("6" (skeep -2)
                      (("6" (skolem -3 "n1")
                        (("6" (skoletin -3 :postfix "1")
                          (("6" (flatten)
                            (("6" (skolem -7 "n2")
                              (("6"
                                (skoletin -7 :postfix "2")
                                (("6"
                                  (flatten)
                                  (("6"
                                    (inst 1 "n1+n2+1")
                                    (("6"
                                      (skoletin 1)
                                      (("6"
                                        (lemma "eval_expr_ge_n")
                                        (("6"
                                          (copy -1)
                                          (("6"
                                            (insteep
                                             -1
                                             :but
                                             (("n" "n1")
                                              ("m" "n1+n2+1")
                                              ("expr"
                                               "get_arg(expr!1)")
                                              ("env" "env!1")))
                                            (("6"
                                              (replace -9 :dir rl)
                                              (("6"
                                                (assert)
                                                (("6"
                                                  (assert)
                                                  (("6"
                                                    (insteep
                                                     -2
                                                     :but
                                                     (("n" "n2")
                                                      ("m" "n1+n2")
                                                      ("expr" "body")
                                                      ("env"
                                                       "LAMBDA(v:(vr?)):valarg")))
                                                    (("6"
                                                      (replace
                                                       -6
                                                       :dir
                                                       rl)
                                                      (("6"
                                                        (assert)
                                                        (("6"
                                                          (expand
                                                           "eval_expr"
                                                           -3)
                                                          (("6"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((semantic_rel_expr_induction formula-decl nil pvs0_lang nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          n > 0 AND
           (FORALL (m: upfrom(n)):
              myv =
               eval_expr(eval_bool, eval_op1, eval_op2)
                        (m, expr, body, env))}" pvs0_lang nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (Maybe type-decl nil Maybe "structures/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_lang nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (get_arg1 adt-accessor-decl "[(op2?) -> Expr]" PVS0_adt nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get_arg2 adt-accessor-decl "[(op2?) -> Expr]" PVS0_adt nil)
    (posrat_max application-judgement "{s: posrat | s >= q AND s >= r}"
     real_defs nil)
    (posint_max application-judgement "{k: posint | i <= k AND j <= k}"
     real_defs nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (eval_expr_ge_n formula-decl nil pvs0_lang nil)
    (n2 skolem-const-decl "posnat" pvs0_lang nil)
    (n1 skolem-const-decl "posnat" pvs0_lang nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max_ge formula-decl nil real_defs nil)
    (get_cond adt-accessor-decl "[(ite?) -> Expr]" PVS0_adt nil)
    (get_else adt-accessor-decl "[(ite?) -> Expr]" PVS0_adt nil)
    (n2 skolem-const-decl "posnat" pvs0_lang nil)
    (get_if adt-accessor-decl "[(ite?) -> Expr]" PVS0_adt nil)
    (n2 skolem-const-decl "posnat" pvs0_lang nil)
    (n1 skolem-const-decl "posnat" pvs0_lang nil)
    (get_arg shared-adt-accessor-decl
     "[{x: PVS0 | rec?(x) OR op1?(x)} -> Expr]" PVS0_adt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil))
   nil)
  (semantic_rel_eval_expr-1 nil 3603110753
   ("" (skeep*)
    (("" (lemma "semantic_rel_expr_induction")
      (("" (insteep -1 :but "P")
        ((""
          (inst -1
           "LAMBDA(x:Expr,e:Environment,v:Val):EXISTS (n:posnat): LET myv = eval_expr(eval_bool,eval_op1,eval_op2)(n,x,body,e) IN
                            some?(myv) AND v=val(myv) AND semantic_rel_expr(eval_bool,eval_op1,eval_op2)(x,body,e,v)")
          (("" (split -)
            (("1" (inst?)
              (("1" (assert)
                (("1" (skeep)
                  (("1" (inst?) (("1" (assert) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (hide -1 2)
              (("2" (skosimp*)
                (("2" (split -)
                  (("1" (flatten)
                    (("1" (inst 1 "1")
                      (("1" (expand "eval_expr")
                        (("1" (assert)
                          (("1" (expand "semantic_rel_expr")
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (inst 1 "1")
                      (("2" (expand "eval_expr")
                        (("2" (assert)
                          (("2" (expand "semantic_rel_expr")
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (flatten)
                    (("3" (skeep -2)
                      (("3" (skeep -3)
                        (("3" (insteep 1)
                          (("3" (beta)
                            (("3" (flatten)
                              (("3"
                                (expand "eval_expr" +)
                                (("3"
                                  (assert)
                                  (("3"
                                    (expand "semantic_rel_expr" 1)
                                    (("3"
                                      (inst?)
                                      (("3" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("4" (flatten)
                    (("4" (skeep -2)
                      (("4" (skolem -3 "n1")
                        (("4" (skoletin -3 :postfix "1")
                          (("4" (skolem -6 "n2")
                            (("4" (skoletin -6 :postfix "2")
                              (("4"
                                (flatten)
                                (("4"
                                  (inst 1 "max(n1,n2)")
                                  (("4"
                                    (skoletin 1)
                                    (("4"
                                      (lemma "eval_expr_ge_n")
                                      (("4"
                                        (copy -1)
                                        (("4"
                                          (insteep
                                           -1
                                           :but
                                           (("n" "n1")
                                            ("m" "max(n1,n2)")
                                            ("expr" "get_arg1(expr!1)")
                                            ("env" "env!1")))
                                          (("1"
                                            (replace -11 :dir rl)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (insteep
                                                   -2
                                                   :but
                                                   (("n" "n2")
                                                    ("m" "max(n1,n2)")
                                                    ("expr"
                                                     "get_arg2(expr!1)")
                                                    ("env" "env!1")))
                                                  (("1"
                                                    (replace
                                                     -7
                                                     :dir
                                                     rl)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand
                                                         "eval_expr"
                                                         -3)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (replaces
                                                             -3)
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (expand
                                                                 "semantic_rel_expr"
                                                                 1)
                                                                (("1"
                                                                  (insteep
                                                                   1)
                                                                  (("1"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (rewrite "max_ge")
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("5" (flatten)
                    (("5" (skeep -2)
                      (("5" (skolem -3 "n1")
                        (("5" (skoletin -3 :postfix "1")
                          (("5" (lemma "eval_expr_ge_n")
                            (("5" (copy -1)
                              (("5"
                                (split -7)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (skolem -3 "n2")
                                    (("1"
                                      (skoletin -3 :postfix "2")
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (inst 1 "max(n1,n2)")
                                          (("1"
                                            (skoletin 1)
                                            (("1"
                                              (insteep
                                               -8
                                               :but
                                               (("n" "n1")
                                                ("m" "max(n1,n2)")
                                                ("expr"
                                                 "get_cond(expr!1)")
                                                ("env" "env!1")))
                                              (("1"
                                                (replace -13 :dir rl)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (insteep
                                                       -9
                                                       :but
                                                       (("n" "n2")
                                                        ("m"
                                                         "max(n1,n2)")
                                                        ("expr"
                                                         "get_if(expr!1)")
                                                        ("env"
                                                         "env!1")))
                                                      (("1"
                                                        (replace
                                                         -5
                                                         :dir
                                                         rl)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (expand
                                                             "eval_expr"
                                                             -1)
                                                            (("1"
                                                              (replaces
                                                               -1)
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (expand
                                                                   "semantic_rel_expr"
                                                                   1)
                                                                  (("1"
                                                                    (insteep
                                                                     1)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (rewrite "max_ge")
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (skolem -2 "n2")
                                    (("2"
                                      (skoletin -2 :postfix "2")
                                      (("2"
                                        (flatten)
                                        (("2"
                                          (inst 2 "max(n1,n2)")
                                          (("2"
                                            (skoletin 2)
                                            (("2"
                                              (insteep
                                               -7
                                               :but
                                               (("n" "n1")
                                                ("m" "max(n1,n2)")
                                                ("expr"
                                                 "get_cond(expr!1)")
                                                ("env" "env!1")))
                                              (("1"
                                                (replace -12 :dir rl)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (insteep
                                                       -8
                                                       :but
                                                       (("n" "n2")
                                                        ("m"
                                                         "max(n1,n2)")
                                                        ("expr"
                                                         "get_else(expr!1)")
                                                        ("env"
                                                         "env!1")))
                                                      (("1"
                                                        (replace
                                                         -5
                                                         :dir
                                                         rl)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (expand
                                                             "eval_expr"
                                                             -1)
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (expand
                                                                 "semantic_rel_expr"
                                                                 1)
                                                                (("1"
                                                                  (insteep
                                                                   1)
                                                                  (("1"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (rewrite "max_ge")
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("6" (flatten)
                    (("6" (skeep -2)
                      (("6" (skolem -3 "n1")
                        (("6" (skoletin -3 :postfix "1")
                          (("6" (flatten)
                            (("6" (skolem -8 "n2")
                              (("6"
                                (skoletin -8 :postfix "2")
                                (("6"
                                  (flatten)
                                  (("6"
                                    (inst 1 "n1+n2+1")
                                    (("6"
                                      (skoletin 1)
                                      (("6"
                                        (lemma "eval_expr_ge_n")
                                        (("6"
                                          (copy -1)
                                          (("6"
                                            (insteep
                                             -1
                                             :but
                                             (("n" "n1")
                                              ("m" "n1+n2+1")
                                              ("expr"
                                               "get_arg(expr!1)")
                                              ("env" "env!1")))
                                            (("6"
                                              (replace -11 :dir rl)
                                              (("6"
                                                (assert)
                                                (("6"
                                                  (assert)
                                                  (("6"
                                                    (insteep
                                                     -2
                                                     :but
                                                     (("n" "n2")
                                                      ("m" "n1+n2")
                                                      ("expr" "body")
                                                      ("env"
                                                       "valarg")))
                                                    (("6"
                                                      (replace
                                                       -7
                                                       :dir
                                                       rl)
                                                      (("6"
                                                        (assert)
                                                        (("6"
                                                          (expand
                                                           "eval_expr"
                                                           -3)
                                                          (("6"
                                                            (assert)
                                                            (("6"
                                                              (expand
                                                               "semantic_rel_expr"
                                                               1)
                                                              (("6"
                                                                (insteep
                                                                 1)
                                                                (("6"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((get_arg1 adt-accessor-decl "[(op2?) -> Expr]" PVS0_adt nil)
    (get_arg2 adt-accessor-decl "[(op2?) -> Expr]" PVS0_adt nil)
    (get_cond adt-accessor-decl "[(ite?) -> Expr]" PVS0_adt nil)
    (get_else adt-accessor-decl "[(ite?) -> Expr]" PVS0_adt nil)
    (get_if adt-accessor-decl "[(ite?) -> Expr]" PVS0_adt nil)
    (get_arg shared-adt-accessor-decl
     "[{x: PVS0 | rec?(x) OR op1?(x)} -> Expr]" PVS0_adt nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil))
   nil))
 (eval_expr_n_pos 0
  (eval_expr_n_pos-1 nil 3642524186
   ("" (skeep)
    (("" (skeep*)
      (("" (beta)
        ((""
          (typepred
           "eval_expr(eval_bool, eval_op1, eval_op2)(n, expr, body, env)")
          (("" (flatten) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_lang nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          n > 0 AND
           (FORALL (m: upfrom(n)):
              myv =
               eval_expr(eval_bool, eval_op1, eval_op2)
                        (m, expr, body, env))}" pvs0_lang nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (deterministic_expr 0
  (deterministic_expr-1 nil 3603044754
   ("" (skeep*)
    (("" (lemma "semantic_rel_eval_expr")
      (("" (copy -1)
        (("" (insteep -1 :but (("val" "val1")))
          (("" (assert)
            (("" (insteep -2 :but (("val" "val2")))
              (("" (assert)
                (("" (skolem -1 "n1")
                  (("" (skolem -2 "n2")
                    (("" (flatten)
                      (("" (lemma "eval_expr_ge_n")
                        (("" (copy -1)
                          ((""
                            (insteep -2 :but
                             (("n" "n1") ("m" "max(n1,n2)")))
                            (("1"
                              (insteep -1 :but
                               (("n" "n2") ("m" "max(n1,n2)")))
                              (("1"
                                (assert)
                                (("1" (ground) nil nil))
                                nil)
                               ("2" (rewrite "max_ge") nil nil))
                              nil)
                             ("2" (rewrite "max_ge") nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((semantic_rel_eval_expr formula-decl nil pvs0_lang nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (max_ge formula-decl nil real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (n1 skolem-const-decl "nat" pvs0_lang nil)
    (n2 skolem-const-decl "nat" pvs0_lang nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (eval_expr_ge_n formula-decl nil pvs0_lang nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          n > 0 AND
           (FORALL (m: upfrom(n)):
              myv =
               eval_expr(eval_bool, eval_op1, eval_op2)
                        (m, expr, body, env))}" pvs0_lang nil))
   shostak))
 (eval_expr_semantic_rel_j_TCC1 0
  (eval_expr_semantic_rel_j_TCC1-1 nil 3642104985
   ("" (skeep) (("" (assert) nil nil)) nil) nil nil))
 (eval_expr_semantic_rel_j_TCC2 0
  (eval_expr_semantic_rel_j_TCC2-1 nil 3642104985
   ("" (skeep*)
    (("" (replaces -1)
      (("" (expand "semantic_rel_expr") (("" (propax) nil nil)) nil))
      nil))
    nil)
   ((semantic_rel_expr inductive-decl "bool" pvs0_lang nil)) nil))
 (eval_expr_semantic_rel_j_TCC3 0
  (eval_expr_semantic_rel_j_TCC3-1 nil 3642104985
   ("" (skeep*)
    (("" (replaces -1)
      (("" (expand "semantic_rel_expr") (("" (propax) nil nil)) nil))
      nil))
    nil)
   ((semantic_rel_expr inductive-decl "bool" pvs0_lang nil)) nil))
 (eval_expr_semantic_rel_j_TCC4 0
  (eval_expr_semantic_rel_j_TCC4-1 nil 3642104985
   ("" (skeep*)
    ((""
      (typepred "v3(eval_bool, eval_op1, eval_op2)(n, arg, body, env)")
      (("" (replaces -4 :dir rl)
        (("" (assert)
          (("" (replaces -2)
            (("" (expand "semantic_rel_expr" 2)
              (("" (inst? 2) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (semantic_rel_expr inductive-decl "bool" pvs0_lang nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (eval_expr_semantic_rel_j_TCC5 0
  (eval_expr_semantic_rel_j_TCC5-1 nil 3642104985
   ("" (skeep*) (("" (assert) nil nil)) nil) nil nil))
 (eval_expr_semantic_rel_j_TCC6 0
  (eval_expr_semantic_rel_j_TCC6-1 nil 3642104985
   ("" (skeep*)
    ((""
      (typepred
       "v3(eval_bool, eval_op1, eval_op2)(n, arg1, body, env)")
      ((""
        (typepred
         "v3(eval_bool, eval_op1, eval_op2)(n, arg2, body, env)")
        (("" (replaces (-4 -7) :dir rl)
          (("" (assert)
            (("" (replaces -3)
              (("" (expand "semantic_rel_expr" 2)
                (("" (inst? 2) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (semantic_rel_expr inductive-decl "bool" pvs0_lang nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (eval_expr_semantic_rel_j_TCC7 0
  (eval_expr_semantic_rel_j_TCC7-1 nil 3642104985
   ("" (skeep*) (("" (assert) nil nil)) nil) nil nil))
 (eval_expr_semantic_rel_j_TCC8 0
  (eval_expr_semantic_rel_j_TCC8-1 nil 3642104985
   ("" (skeep*)
    ((""
      (typepred "v3(eval_bool, eval_op1, eval_op2)(n, cnd, body, env)")
      ((""
        (typepred
         "v3(eval_bool, eval_op1, eval_op2)(n, arg1, body, env)")
        ((""
          (typepred
           "v3(eval_bool, eval_op1, eval_op2)(n, arg2, body, env)")
          (("" (replaces -7 :dir rl)
            (("" (assert)
              ((""
                (name-replace "ARG1"
                 "v3(eval_bool, eval_op1, eval_op2)(n, arg1, body, env)")
                ((""
                  (name-replace "ARG2"
                   "v3(eval_bool, eval_op1, eval_op2)(n, arg2, body, env)")
                  (("" (replaces -4)
                    (("" (expand "semantic_rel_expr" 2)
                      (("" (inst? 2) (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (semantic_rel_expr inductive-decl "bool" pvs0_lang nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   nil))
 (eval_expr_semantic_rel_j_TCC9 0
  (eval_expr_semantic_rel_j_TCC9-1 nil 3642104985
   ("" (skeep*)
    ((""
      (typepred "v3(eval_bool, eval_op1, eval_op2)(n, cnd, body, env)")
      ((""
        (typepred
         "v3(eval_bool, eval_op1, eval_op2)(n, arg1, body, env)")
        ((""
          (typepred
           "v3(eval_bool, eval_op1, eval_op2)(n, arg2, body, env)")
          (("" (replaces -6 :dir rl)
            ((""
              (name-replace "ARG1"
               "v3(eval_bool, eval_op1, eval_op2)(n, arg1, body, env)")
              ((""
                (name-replace "ARG2"
                 "v3(eval_bool, eval_op1, eval_op2)(n, arg2, body, env)")
                (("" (assert)
                  (("" (replaces -4)
                    (("" (expand "semantic_rel_expr" 3)
                      (("" (inst? +) (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (semantic_rel_expr inductive-decl "bool" pvs0_lang nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   nil))
 (eval_expr_semantic_rel_j_TCC10 0
  (eval_expr_semantic_rel_j_TCC10-1 nil 3642104985
   ("" (skeep*) (("" (assert) nil nil)) nil) nil nil))
 (eval_expr_semantic_rel_j_TCC11 0
  (eval_expr_semantic_rel_j_TCC11-1 nil 3642104985
   ("" (skeep*) (("" (assert) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (eval_expr_semantic_rel_j_TCC12 0
  (eval_expr_semantic_rel_j_TCC12-1 nil 3642104985
   ("" (skeep*)
    ((""
      (typepred "v3(eval_bool, eval_op1, eval_op2)(n, arg, body, env)")
      ((""
        (typepred "v3(eval_bool, eval_op1, eval_op2)
                               (n - 1, body, body,
                                LAMBDA (v_1: (vr?[Val])): val[T](v))")
        (("1" (replaces -5 :dir rl)
          (("1"
            (name-replace "REC" "v3(eval_bool, eval_op1, eval_op2)
              (n - 1, body, body, LAMBDA (v_1: (vr?[Val])): val[T](v))")
            (("1" (assert)
              (("1" (replaces -3)
                (("1" (expand "semantic_rel_expr" 2)
                  (("1" (inst? +) (("1" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (propax) nil nil) ("3" (assert) nil nil))
        nil))
      nil))
    nil)
   ((val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (semantic_rel_expr inductive-decl "bool" pvs0_lang nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   nil))
 (eval_expr_semantic_rel_j_TCC13 0
  (eval_expr_semantic_rel_j_TCC13-1 nil 3642104985
   ("" (skeep*) (("" (assert) nil nil)) nil) nil nil))
 (eval_expr_semantic_rel 0
  (eval_expr_semantic_rel-1 nil 3642104637
   ("" (skeep*)
    (("" (skoletin 1)
      ((""
        (typepred
         "eval_expr(eval_bool, eval_op1, eval_op2)(n, expr, body, env)")
        (("" (hide -2)
          (("" (flatten)
            (("" (replaces -4 :dir rl) (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (semantic_rel_expr inductive-decl "bool" pvs0_lang nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_lang nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          semantic_rel_expr(eval_bool, eval_op1, eval_op2)
                           (expr, body, env, val(myv))}" pvs0_lang nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          n > 0 AND
           (FORALL (m: upfrom(n)):
              myv =
               eval_expr(eval_bool, eval_op1, eval_op2)
                        (m, expr, body, env))}" pvs0_lang nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil))
   shostak))
 (eval_expr_terminates 0
  (eval_expr_terminates-1 nil 3603051644
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "eval_expr_termination")
          (("1" (expand "terminates_expr")
            (("1" (skeep*)
              (("1" (insteep*)
                (("1" (skeep) (("1" (inst?) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "terminates_expr")
          (("2" (expand "eval_expr_termination")
            (("2" (skeep*)
              (("2" (insteep*)
                (("2" (skeep)
                  (("2" (lemma "semantic_rel_eval_expr")
                    (("2" (insteep -1)
                      (("2" (assert)
                        (("2" (skeep)
                          (("2" (insteep 1) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          semantic_rel_expr(eval_bool, eval_op1, eval_op2)
                           (expr, body, env, val(myv))}" pvs0_lang nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          n > 0 AND
           (FORALL (m: upfrom(n)):
              myv =
               eval_expr(eval_bool, eval_op1, eval_op2)
                        (m, expr, body, env))}" pvs0_lang nil)
    (eval_expr_termination const-decl "bool" pvs0_lang nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (bool nonempty-type-eq-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (terminates_expr const-decl "bool" pvs0_lang nil)
    (semantic_rel_eval_expr formula-decl nil pvs0_lang nil))
   shostak))
 (deterministic 0
  (deterministic-1 nil 3603114410
   ("" (skeep*)
    (("" (expand "semantic_rel")
      (("" (lemma "deterministic_expr")
        (("" (inst?) (("" (inst?) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((semantic_rel const-decl "bool" pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (def? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Def type-eq-decl nil PVS0_adt nil)
    (get_body adt-accessor-decl "[Def -> Expr]" PVS0_adt nil)
    (deterministic_expr formula-decl nil pvs0_lang nil))
   nil))
 (semantic_rel_eval 0
  (semantic_rel_eval-1 nil 3603114655
   ("" (skeep*)
    (("" (expand "semantic_rel")
      (("" (expand "eval")
        (("" (lemma "semantic_rel_eval_expr")
          (("" (inst?) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((semantic_rel const-decl "bool" pvs0_lang nil)
    (semantic_rel_eval_expr formula-decl nil pvs0_lang nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (get_body adt-accessor-decl "[Def -> Expr]" PVS0_adt nil)
    (Def type-eq-decl nil PVS0_adt nil)
    (def? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (eval const-decl "Maybe[Val]" pvs0_lang nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          n > 0 AND
           (FORALL (m: upfrom(n)):
              myv =
               eval_expr(eval_bool, eval_op1, eval_op2)
                        (m, expr, body, env))}" pvs0_lang nil)
    (eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          semantic_rel_expr(eval_bool, eval_op1, eval_op2)
                           (expr, body, env, val(myv))}" pvs0_lang
     nil))
   shostak))
 (eval_terminates 0
  (eval_terminates-1 nil 3603114994
   ("" (skeep)
    (("" (expand "eval_termination")
      (("" (expand "terminates")
        (("" (lemma "eval_expr_terminates") (("" (inst?) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((eval_termination const-decl "bool" pvs0_lang nil)
    (eval_expr_terminates formula-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (def? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Def type-eq-decl nil PVS0_adt nil)
    (get_body adt-accessor-decl "[Def -> Expr]" PVS0_adt nil)
    (terminates const-decl "bool" pvs0_lang nil))
   shostak))
 (mu_nonempty 0
  (mu_nonempty-1 nil 3642109779
   ("" (skeep)
    (("" (typepred "pvs0")
      (("" (lemma "eval_terminates")
        (("" (inst?)
          (("" (assert)
            (("" (expand "eval_termination")
              (("" (expand "nonempty?")
                (("" (expand "empty?")
                  (("" (expand "eval_expr_termination")
                    (("" (inst?)
                      (("" (inst?)
                        (("" (inst?)
                          (("" (inst?)
                            (("" (skeep)
                              ((""
                                (expand member)
                                ((""
                                  (inst - "n")
                                  ((""
                                    (expand "eval")
                                    (("" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Terminating type-eq-decl nil pvs0_lang nil)
    (terminates const-decl "bool" pvs0_lang nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Def type-eq-decl nil PVS0_adt nil)
    (def? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (eval_termination const-decl "bool" pvs0_lang nil)
    (empty? const-decl "bool" sets nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (member const-decl "bool" sets nil)
    (eval const-decl "Maybe[Val]" pvs0_lang nil)
    (eval_expr_termination const-decl "bool" pvs0_lang nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          n > 0 AND
           (FORALL (m: upfrom(n)):
              myv =
               eval_expr(eval_bool, eval_op1, eval_op2)
                        (m, expr, body, env))}" pvs0_lang nil)
    (eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          semantic_rel_expr(eval_bool, eval_op1, eval_op2)
                           (expr, body, env, val(myv))}" pvs0_lang nil)
    (nonempty? const-decl "bool" sets nil)
    (eval_terminates formula-decl nil pvs0_lang nil))
   nil))
 (mu_TCC1 0
  (mu_TCC1-2 nil 3642108156
   ("" (skeep)
    (("" (lemma "mu_nonempty")
      (("" (inst?) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((mu_nonempty formula-decl nil pvs0_lang nil)
    (Terminating type-eq-decl nil pvs0_lang nil)
    (terminates const-decl "bool" pvs0_lang nil)
    (Def type-eq-decl nil PVS0_adt nil)
    (def? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil))
   nil)
  (mu_TCC1-1 nil 3642108051 ("" (subtype-tcc) nil nil) nil nil))
 (mu_TCC2 0
  (mu_TCC2-2 nil 3642108521
   ("" (skeep)
    (("" (case "nonempty?(S)")
      (("1" (replaces -2)
        (("1" (expand "eval")
          (("1" (lemma "eval_expr_ge_n_j")
            (("1" (inst?)
              (("1"
                (inst -1 "get_body(pvs0)" "val2env(val)"
                 "get_body(pvs0)" _)
                (("1" (inst?)
                  (("1" (prop)
                    (("1" (hide 2) (("1" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma "mu_nonempty")
        (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          semantic_rel_expr(eval_bool, eval_op1, eval_op2)
                           (expr, body, env, val(myv))}" pvs0_lang nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          n > 0 AND
           (FORALL (m: upfrom(n)):
              myv =
               eval_expr(eval_bool, eval_op1, eval_op2)
                        (m, expr, body, env))}" pvs0_lang nil)
    (eval const-decl "Maybe[Val]" pvs0_lang nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (val skolem-const-decl "Val" pvs0_lang nil)
    (pvs0 skolem-const-decl
     "Terminating(eval_bool, eval_op1, eval_op2)" pvs0_lang nil)
    (eval_op2 skolem-const-decl "[nat -> [[Val, Val] -> Val]]"
     pvs0_lang nil)
    (eval_op1 skolem-const-decl "[nat -> [Val -> Val]]" pvs0_lang nil)
    (eval_bool skolem-const-decl "[Val -> bool]" pvs0_lang nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_lang nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
         min_nat nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (Terminating type-eq-decl nil pvs0_lang nil)
    (terminates const-decl "bool" pvs0_lang nil)
    (get_body adt-accessor-decl "[Def -> Expr]" PVS0_adt nil)
    (Def type-eq-decl nil PVS0_adt nil)
    (def? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (eval_expr_ge_n_j recursive-judgement-axiom nil pvs0_lang nil)
    (mu_nonempty formula-decl nil pvs0_lang nil))
   nil)
  (mu_TCC2-1 nil 3642108051 ("" (subtype-tcc) nil nil) nil nil))
 (mu_terminates 0
  (mu_terminates-1 nil 3642109195
   ("" (skeep)
    (("" (skoletin* 1)
      (("" (expand "mu")
        ((""
          (typepred "min({n: nat |
              some?(eval(eval_bool, eval_op1, eval_op2)(n, pvs0)
                        (LAMBDA (v: (vr?)): val))})")
          (("1" (replaces -4 :dir rl) (("1" (assert) nil nil)) nil)
           ("2" (lemma "mu_nonempty")
            (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((IFF const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (def? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Def type-eq-decl nil PVS0_adt nil)
    (terminates const-decl "bool" pvs0_lang nil)
    (Terminating type-eq-decl nil pvs0_lang nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (mu const-decl "posnat" pvs0_lang nil)
    (eval const-decl "Maybe[Val]" pvs0_lang nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
         min_nat nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (mu_nonempty formula-decl nil pvs0_lang nil))
   shostak))
 (mu_eval_TCC1 0
  (mu_eval_TCC1-1 nil 3653231735
   ("" (skeep) (("" (use "mu_terminates") (("" (assert) nil nil)) nil))
    nil)
   ((mu_terminates formula-decl nil pvs0_lang nil)
    (Terminating type-eq-decl nil pvs0_lang nil)
    (terminates const-decl "bool" pvs0_lang nil)
    (Def type-eq-decl nil PVS0_adt nil)
    (def? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil))
   nil))
 (mu_eval_correct 0
  (mu_eval_correct-1 nil 3653316887
   ("" (skeep*)
    (("" (split 1)
      (("1" (flatten)
        (("1" (expand "mu_eval")
          (("1" (expand "eval")
            (("1" (expand "semantic_rel")
              (("1" (use "semantic_rel_eval_expr")
                (("1" (assert)
                  (("1" (skeep)
                    (("1" (use "mu_terminates")
                      (("1" (assert)
                        (("1" (expand "eval")
                          (("1" (lemma "eval_expr_semantic_rel")
                            (("1" (assert)
                              (("1"
                                (inst? -1 :where -2)
                                (("1"
                                  (inst
                                   -1
                                   "val(eval_expr(eval_bool, eval_op1, eval_op2)
                    (mu(eval_bool, eval_op1, eval_op2)(pvs0)(arg),
                     get_body(pvs0), get_body(pvs0),
                     LAMBDA (v_1: (vr?)): arg))")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (hide-all-but (-1 -5 1))
                                      (("1"
                                        (lemma "deterministic_expr")
                                        (("1"
                                          (inst? -1 :where 1)
                                          (("1"
                                            (inst? -1 :where -3)
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (replace -1 :hide? t)
          (("2" (expand "semantic_rel")
            (("2" (expand "mu_eval")
              (("2" (expand "eval")
                (("2" (use "eval_expr_semantic_rel")
                  (("2" (assert)
                    (("2" (assert)
                      (("2" (hide 2)
                        (("2" (use " mu_terminates")
                          (("2" (assert)
                            (("2" (expand "eval")
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((mu_eval const-decl "Val" pvs0_lang nil)
    (semantic_rel const-decl "bool" pvs0_lang nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          n > 0 AND
           (FORALL (m: upfrom(n)):
              myv =
               eval_expr(eval_bool, eval_op1, eval_op2)
                        (m, expr, body, env))}" pvs0_lang nil)
    (eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          semantic_rel_expr(eval_bool, eval_op1, eval_op2)
                           (expr, body, env, val(myv))}" pvs0_lang nil)
    (mu_terminates formula-decl nil pvs0_lang nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_lang nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (deterministic_expr formula-decl nil pvs0_lang nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (mu const-decl "posnat" pvs0_lang nil)
    (eval_expr_semantic_rel formula-decl nil pvs0_lang nil)
    (T formal-nonempty-type-decl nil pvs0_lang nil)
    (Val type-eq-decl nil pvs0_lang nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (def? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Def type-eq-decl nil PVS0_adt nil)
    (get_body adt-accessor-decl "[Def -> Expr]" PVS0_adt nil)
    (terminates const-decl "bool" pvs0_lang nil)
    (Terminating type-eq-decl nil pvs0_lang nil)
    (Environment type-eq-decl nil pvs0_lang nil)
    (semantic_rel_eval_expr formula-decl nil pvs0_lang nil)
    (eval const-decl "Maybe[Val]" pvs0_lang nil))
   shostak)))

