(ex_factorial_pvs0
 (eop1_TCC1 0
  (eop1_TCC1-1 nil 3643188398 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (lessp_TCC1 0
  (lessp_TCC1-1 nil 3643188742
   ("" (use "wf_nat") (("" (grind) nil nil)) nil)
   ((well_founded? const-decl "bool" orders nil)
    (restrict const-decl "R" restrict nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (wf_nat formula-decl nil naturalnumbers nil))
   nil))
 (pvs0_factorial_tcc_termination_TCC1 0
  (pvs0_factorial_tcc_termination_TCC1-1 nil 3643189390
   ("" (subtype-tcc) nil nil)
   ((pvs0_factorial const-decl "PVS0" ex_factorial_pvs0 nil)) nil))
 (pvs0_factorial_tcc_termination 0
  (pvs0_factorial_tcc_termination-1 nil 3643193452
   ("" (expand "pvs0_tcc_termination")
    (("" (inst 1 "id[nat]")
      (("" (skeep)
        (("" (skeep)
          ((""
            (case "cc = (# cnds := (: pvsnot(op1(0, vr)) :),
             path := (: 1, 2 :),
             rec_expr := rec(op1(1, vr)) #)")
            (("1" (replaces -1)
              (("1" (assert)
                (("1" (skeep)
                  (("1" (expand "semantic_rel_expr")
                    (("1" (expand "eop1" -1 2)
                      (("1" (expand "eval_conds_rec")
                        (("1" (expand "eval_conds_rec")
                          (("1" (expand "ebool" -2 2)
                            (("1" (expand "/=")
                              (("1"
                                (skeep -2)
                                (("1"
                                  (replaces -3)
                                  (("1"
                                    (expand "semantic_rel_expr" -2)
                                    (("1"
                                      (expand "eop1" -2 2)
                                      (("1"
                                        (expand "boole")
                                        (("1"
                                          (skolem -2 "n1")
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (lift-if -3)
                                              (("1"
                                                (split -3)
                                                (("1"
                                                  (expand
                                                   "semantic_rel_expr"
                                                   -2)
                                                  (("1"
                                                    (replaces -2)
                                                    (("1"
                                                      (skolem -1 "n2")
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (expand
                                                           "semantic_rel_expr"
                                                           -1)
                                                          (("1"
                                                            (replaces
                                                             -1)
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2)
              (("2" (lemma "pvs0_ccs_completness")
                (("2" (inst -1 "pvs0_factorial" "cc")
                  (("1" (expand "pvs0_factorial")
                    (("1" (expand "pvs0_ccs")
                      (("1"
                        (eval-expr
                         "pvs0_ccs_rec(def(ite(op1(0, vr), cnst(1),
                                        op2(0, vr, rec(op1(1, vr))))))
                               (valid_paths(ite
                                            (op1(0, vr),
                                             cnst(1),
                                             op2(0, vr, rec(op1(1, vr))))))")
                        (("1" (replace -1 -2 :hide? t)
                          (("1"
                            (name-replace "A"
                             "(# cnds := (: pvsnot(op1(0, vr)) :),
          path := (: 1, 2 :),
          rec_expr := rec(op1(1, vr)) #)")
                            (("1" (expand "member")
                              (("1"
                                (assert)
                                (("1"
                                  (expand "member")
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (expand "pvs0_factorial")
                      (("2" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Val type-eq-decl nil lang nil)
    (pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (< const-decl "(well_founded?[nat])" ex_factorial_pvs0 nil)
    (WFM type-eq-decl nil measure_termination_defs nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (pvs0_ccs const-decl "list[(pvs0_tcc_valid_cc(def))]"
     measure_termination_defs nil)
    (valid_path def-decl "bool" eval_props nil)
    (get_body adt-accessor-decl "[Def -> Expr]" PVS0_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (subterm_at def-decl "Expr" eval_props nil)
    (path_conditions def-decl "Conditions" eval_props nil)
    (pvs0_ccs_rec def-decl "{res: list[(pvs0_tcc_valid_cc(def))] |
         FORALL (p: (valid_path(get_body(def)))):
           LET subexpr = subterm_at(get_body(def), p) IN
             member(p, paths) AND rec?(subexpr) IMPLIES
              LET cc: (pvs0_tcc_valid_cc(def)) =
                    (# `path := p,
                       `rec_expr := subexpr,
                       `cnds := path_conditions(get_body(def), p) #)
                IN member(cc, res)}" measure_termination_defs nil)
    (def adt-constructor-decl "[Expr -> (def?)]" PVS0_adt nil)
    (ite adt-constructor-decl "[[Expr, Expr, Expr] -> (ite?)]" PVS0_adt
     nil)
    (cnst adt-constructor-decl "[T -> (cnst?)]" PVS0_adt nil)
    (op2 adt-constructor-decl "[[nat, Expr, Expr] -> (op2?)]" PVS0_adt
     nil)
    (valid_paths def-decl "{res: list[(valid_path(expr))] |
         FORALL (p: (valid_path(expr))): member(p, res)}" eval_props
                 nil)
    (TRUE const-decl "bool" booleans nil)
    (pvs0_ccs_completness formula-decl nil measure_termination_defs
     nil)
    (eop1 const-decl "nat" ex_factorial_pvs0 nil)
    (/= const-decl "boolean" notequal nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (restrict const-decl "R" restrict nil)
    (boole const-decl "nat" ex_factorial_pvs0 nil)
    (ebool const-decl "bool" ex_factorial_pvs0 nil)
    (eval_conds_rec def-decl "bool" conditions nil)
    (semantic_rel_expr inductive-decl "bool" lang nil)
    (BoolPVS0 type-decl nil BoolPVS0_adt nil)
    (list type-decl nil list_adt nil) (PVS0 type-decl nil PVS0_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" PVS0_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Conditions type-eq-decl nil conditions nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (PVS0_CC type-eq-decl nil measure_termination_defs nil)
    (def? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Def type-eq-decl nil PVS0_adt nil)
    (pvs0_tcc_valid_cc const-decl "bool" measure_termination_defs nil)
    (pvs0_factorial const-decl "PVS0" ex_factorial_pvs0 nil)
    (every adt-def-decl "boolean" BoolPVS0_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (pvsnot? adt-recognizer-decl "[BoolPVS0 -> boolean]" BoolPVS0_adt
     nil)
    (pvsnot adt-constructor-decl "[Expr[T] -> (pvsnot?)]" BoolPVS0_adt
     nil)
    (op1 adt-constructor-decl "[[nat, Expr] -> (op1?)]" PVS0_adt nil)
    (vr adt-constructor-decl "(vr?)" PVS0_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (rec adt-constructor-decl "[Expr -> (rec?)]" PVS0_adt nil)
    (pvs0_tcc_termination const-decl "bool" measure_termination_defs
     nil))
   shostak))
 (R__TCC1 0
  (R__TCC1-1 nil 3643390196
   ("" (inst 1 "LAMBDA(x,x_: MT_):FALSE") (("" (grind) nil nil)) nil)
   ((FALSE const-decl "bool" booleans nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (MT_ nonempty-type-decl nil ex_factorial_pvs0 nil))
   nil))
 (IMP_ex_factorial_R_wf_TCC1 0
  (IMP_ex_factorial_R_wf_TCC1-1 nil 3643390196
   ("" (typepred "R_") (("" (grind) nil nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (MT_ nonempty-type-decl nil ex_factorial_pvs0 nil)
    (pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (R_ const-decl "(well_founded?[MT_])" ex_factorial_pvs0 nil))
   nil))
 (IMP_ex_factorial_wfm_f_dec_TCC1 0
  (IMP_ex_factorial_wfm_f_dec_TCC1-1 nil 3643390196
   ("" (skeep)
    (("" (lemma "pvs0_factorial_pvs0_tcc_gen_termination")
      ((""
        (inst -1 "LAMBDA(vr: (vr?)): n"
         "(# cnds := (: pvsnot(op1(0, vr)) :),
        path := (: 1, 2 :),
        rec_expr := rec(op1(1, vr)) #)" "n-1")
        (("1" (assert)
          (("1" (split 1)
            (("1" (expand "semantic_rel_expr")
              (("1" (expand "eop1")
                (("1" (inst 1 "n")
                  (("1" (assert)
                    (("1" (expand "semantic_rel_expr")
                      (("1" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "eval_conds_rec")
              (("2" (expand "eval_conds_rec")
                (("2" (expand "semantic_rel_expr")
                  (("2" (expand "ebool" 1 2)
                    (("2" (expand "/=")
                      (("2" (inst 1 "0")
                        (("2" (expand "eop1" 1 2)
                          (("2" (expand "boole")
                            (("2" (inst 1 "n")
                              (("2"
                                (expand "semantic_rel_expr")
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil)
         ("3" (hide-all-but 1)
          (("3" (expand "pvs0_tcc_valid_cc")
            (("3" (expand "pvs0_factorial")
              (("3" (assert)
                (("3" (split 1)
                  (("1" (expand "valid_path")
                    (("1" (expand "rac")
                      (("1" (expand "rdc")
                        (("1" (expand "length")
                          (("1" (expand "length")
                            (("1" (expand "length")
                              (("1"
                                (assert)
                                (("1"
                                  (expand "nth")
                                  (("1"
                                    (expand "nth")
                                    (("1"
                                      (expand "reverse" 1 2)
                                      (("1"
                                        (expand "reverse" 1 2)
                                        (("1"
                                          (expand "reverse" 1 2)
                                          (("1"
                                            (expand "append" 1 2)
                                            (("1"
                                              (expand "append" 1)
                                              (("1"
                                                (expand "append" 1)
                                                (("1"
                                                  (expand "reverse")
                                                  (("1"
                                                    (expand "reverse")
                                                    (("1"
                                                      (expand "append")
                                                      (("1"
                                                        (expand
                                                         "valid_path")
                                                        (("1"
                                                          (expand
                                                           "rac")
                                                          (("1"
                                                            (expand
                                                             "rdc")
                                                            (("1"
                                                              (expand
                                                               "length")
                                                              (("1"
                                                                (expand
                                                                 "length")
                                                                (("1"
                                                                  (assert)
                                                                  (("1"
                                                                    (expand
                                                                     "nth")
                                                                    (("1"
                                                                      (expand
                                                                       "reverse"
                                                                       1
                                                                       2)
                                                                      (("1"
                                                                        (expand
                                                                         "reverse"
                                                                         1
                                                                         2)
                                                                        (("1"
                                                                          (expand
                                                                           "append")
                                                                          (("1"
                                                                            (expand
                                                                             "reverse"
                                                                             1)
                                                                            (("1"
                                                                              (expand
                                                                               "valid_path")
                                                                              (("1"
                                                                                (propax)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "subterm_at")
                    (("2"
                      (eval-expr
                       "nth((: 1, 2 :), length((: 1, 2 :)) - 1)")
                      (("2" (lift-if 1)
                        (("2" (assert)
                          (("2" (split 1)
                            (("1" (flatten) (("1" (grind) nil nil))
                              nil)
                             ("2" (flatten) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (grind) nil nil))
        nil))
      nil))
    nil)
   ((pvs0_factorial_pvs0_tcc_gen_termination formula-decl nil
     ex_factorial_pvs0 nil)
    (rac const-decl "nat" eval_props nil)
    (length def-decl "nat" list_props nil)
    (nth def-decl "T" list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (append def-decl "list[T]" list_props nil)
    (rdc const-decl "list[nat]" eval_props nil)
    (valid_path def-decl "bool" eval_props nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (subterm_at def-decl "Expr" eval_props nil)
    (add_sl def-decl
            "{ll: (nonempty_sl?) | FORALL y: member(y, ll) IFF (x = y OR member(y, l))}"
            set_as_list "structures/")
    (path_conditions def-decl "Conditions" eval_props nil)
    (eval_conds_rec def-decl "bool" conditions nil)
    (/= const-decl "boolean" notequal nil)
    (boole const-decl "nat" ex_factorial_pvs0 nil)
    (ebool const-decl "bool" ex_factorial_pvs0 nil)
    (semantic_rel_expr inductive-decl "bool" lang nil)
    (eop1 const-decl "nat" ex_factorial_pvs0 nil)
    (Environment type-eq-decl nil lang nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (n skolem-const-decl "nat" ex_factorial_pvs0 nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (every adt-def-decl "boolean" PVS0_adt nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Val type-eq-decl nil lang nil)
    (def? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Def type-eq-decl nil PVS0_adt nil)
    (Conditions type-eq-decl nil conditions nil)
    (rec? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (MT_ nonempty-type-decl nil ex_factorial_pvs0 nil)
    (pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (R_ const-decl "(well_founded?[MT_])" ex_factorial_pvs0 nil)
    (PVS0_CC type-eq-decl nil measure_termination_defs nil)
    (pvs0_tcc_valid_cc const-decl "bool" measure_termination_defs nil)
    (pvs0_factorial const-decl "PVS0" ex_factorial_pvs0 nil)
    (BoolPVS0 type-decl nil BoolPVS0_adt nil)
    (every adt-def-decl "boolean" BoolPVS0_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (cnst? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op1? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (op2? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (ite? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Expr type-eq-decl nil PVS0_adt nil)
    (pvsnot? adt-recognizer-decl "[BoolPVS0 -> boolean]" BoolPVS0_adt
     nil)
    (pvsnot adt-constructor-decl "[Expr[T] -> (pvsnot?)]" BoolPVS0_adt
     nil)
    (op1 adt-constructor-decl "[[nat, Expr] -> (op1?)]" PVS0_adt nil)
    (vr adt-constructor-decl "(vr?)" PVS0_adt nil)
    (rec adt-constructor-decl "[Expr -> (rec?)]" PVS0_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (pvs0_factorial_eval_MT_nonempty_TCC1 0
  (pvs0_factorial_eval_MT_nonempty_TCC1-1 nil 3643189390
   ("" (mapped-axiom-tcc) nil nil) nil nil))
 (pvs0_factorial_eval 0
  (pvs0_factorial_eval-1 nil 3643193436
   ("" (induct "n")
    (("1" (assert) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep) (("4" (grind) nil nil)) nil)
     ("5" (expand "pvs0_factorial") (("5" (propax) nil nil)) nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (eval_expr def-decl "Maybe[Val]" lang nil)
    (boole const-decl "nat" ex_factorial_pvs0 nil)
    (eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          semantic_rel_expr(eval_bool, eval_op1, eval_op2)
                           (expr, body, env, val(myv))}"
     ex_factorial_pvs0 nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          n > 0 AND
           (FORALL (m: upfrom(n)):
              myv =
               eval_expr(eval_bool, eval_op1, eval_op2)
                        (m, expr, body, env))}" ex_factorial_pvs0 nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (eop2 const-decl "nat" ex_factorial_pvs0 nil)
    (eop1 const-decl "nat" ex_factorial_pvs0 nil)
    (ebool const-decl "bool" ex_factorial_pvs0 nil)
    (eval const-decl "Maybe[Val]" lang nil)
    (Environment type-eq-decl nil lang nil)
    (vr? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (Def type-eq-decl nil PVS0_adt nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (factorial def-decl "nat" ex_factorial nil)
    (wfm_f_ const-decl "mt_gen.WFM" ex_factorial_pvs0 nil)
    (WFM type-eq-decl nil measure_termination_defs nil)
    (R_ const-decl "(well_founded?[MT_])" ex_factorial_pvs0 nil)
    (well_founded? const-decl "bool" orders nil)
    (MT_ nonempty-type-decl nil ex_factorial_pvs0 nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (PVS0 type-decl nil PVS0_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" PVS0_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Val type-eq-decl nil lang nil)
    (def? adt-recognizer-decl "[PVS0 -> boolean]" PVS0_adt nil)
    (pvs0_factorial const-decl "PVS0" ex_factorial_pvs0 nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak)))

