pvs0_lang[T:TYPE+] : THEORY
BEGIN
  
  IMPORTING pvs0_expr[T]

  EvalBool : TYPE = [Val -> bool]
  EvalOp1  : TYPE = [nat->[Val->Val]]
  EvalOp2  : TYPE = [nat->[[Val,Val]->Val]]
  PVS0     : TYPE = [EvalBool,EvalOp1,EvalOp2,PVS0Expr]

  pvs0          : VAR PVS0
  env           : VAR Val
  val,val1,val2 : VAR Val

  terminating?(pvs0:PVS0) : bool =
    terminates_expr(pvs0`1,pvs0`2,pvs0`3)(pvs0`4,pvs0`4)

  semantic_rel(pvs0:PVS0,env:Val,val:Val) : bool =
    semantic_rel_expr(pvs0`1,pvs0`2,pvs0`3)(pvs0`4,pvs0`4,env,val)

  deterministic : THEOREM
    semantic_rel(pvs0,env,val1) AND
    semantic_rel(pvs0,env,val2)
    IMPLIES val1 = val2

  eval(pvs0:PVS0)(n:nat)(env:Val) : Maybe[Val] =
    eval_expr(pvs0`1,pvs0`2,pvs0`3)(n,pvs0`4,pvs0`4,env)

  eval_pvs0_ge_n : COROLLARY
    FORALL (n:nat,m:upfrom(n),env:Val):
       LET myv = eval(pvs0)(n)(env) IN
        some?(myv) IMPLIES myv = eval(pvs0)(m)(env)

  semantic_rel_eval : THEOREM
    semantic_rel(pvs0,env,val)
    IMPLIES
        EXISTS (n:nat): LET myv = eval(pvs0)(n)(env) IN
        some?(myv) AND val = val(myv) 

  eval_termination(pvs0) : bool =
    eval_expr_termination(pvs0`1,pvs0`2,pvs0`3)(pvs0`4,pvs0`4)

  eval_terminates: LEMMA
    eval_termination(pvs0) IFF terminating?(pvs0)

  % Concrete counter for terminating functions
  
  mu_nonempty: LEMMA
    FORALL (pvs0:(terminating?)):
      LET S = { n : nat | LET myv = eval(pvs0)(n)(val) IN some?(myv) } IN
      nonempty?(S)

  mu(pvs0:(terminating?))(val:Val): posnat =
    LET  S = { n : nat | LET myv = eval(pvs0)(n)(val) IN  some?(myv) } IN
    min(S)

  mu_terminates : LEMMA
    FORALL (pvs0:(terminating?)):
       LET mun = mu(pvs0)(val),
           myv = eval(pvs0)(mun)(val) IN
       some?(myv)

  mu_min : LEMMA
    FORALL (pvs0:(terminating?),val:Val,n:nat):
       some?(eval(pvs0)(n)(val)) IMPLIES mu(pvs0)(val) <= n

  % Uses mu to evaluate a terminating PVS0 function

  mu_eval(pvs0:(terminating?))(v:Val) : Val =
    LET n = mu(pvs0)(v) IN val(eval(pvs0)(n)(v))

  eval_semantic: LEMMA
   FORALL (pvs0:(terminating?))(arg,val:Val):
    some?(eval(pvs0)(mu(pvs0)(arg))(arg))
     IMPLIES semantic_rel(pvs0, arg, val(eval(pvs0)(mu(pvs0)(arg))(arg)))

  mu_eval_correct : THEOREM
    FORALL (pvs0:(terminating?))(arg,val:Val):
      semantic_rel(pvs0,arg,val) IFF val = mu_eval(pvs0)(arg) 

  % Defining a non-terminating function in PVS0

  eval_bool : VAR EvalBool
  eval_op1  : VAR EvalOp1
  eval_op2  : VAR EvalOp2

  Delta(eval_bool,eval_op1,eval_op2) : PVS0 = (eval_bool,eval_op1,eval_op2,rec(vr))

  TT : T

  Delta_non_terminating : THEOREM
    FORALL (eval_bool,eval_op1,eval_op2) : NOT terminating?(Delta(eval_bool,eval_op1,eval_op2))

END pvs0_lang
