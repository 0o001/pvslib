factorial_pvs0: THEORY
BEGIN
% ------------------------------------------------------------------------------ 
% Part0: Definition of factorial in PVS0
%
  IMPORTING lang[nat]

  ebool(n:nat) : bool = n /= 0

  boole(b:bool) : nat = IF NOT b THEN 0 ELSE 1 ENDIF

  eop1(op:nat)(n:nat) : nat = 
    COND op = 0 -> boole(n = 0),
         op = 1 -> IF n = 0 THEN 0 ELSE n-1 ENDIF,
         ELSE -> n
    ENDCOND

  eop2(op:nat)(n,m:nat) : nat = n*m

  % Interpretation:
  %   vr      : n
  %   bool(n) : n /= 0
  %   op1 0   : n -> bool(n=0)
  %   op1 1   : n -> n-1 
  %   op2 0   : n,m -> n*m

  pvs0_factorial : PVS0 =
    def(ite(op1(0,vr),cnst(1),op2(0,vr,rec(op1(1,vr)))))

% ------------------------------------------------------------------------------ 
% Part1: Proof of termination via pvs0_tccs
%    

  lt_nat: (well_founded?[nat]) = LAMBDA(m,n:nat): m < n

  IMPORTING measure_termination_defs
  	    [ nat    % Base type
	    , nat    % Measure type
	    , lt_nat % Measure relation
	    ] AS mt_nat

  % This lemma assures that there are one measure type and one measure relation 
  % that can be used to prove termination via pvs0_tcc.
  pvs0_factorial_tcc_termination: LEMMA
    mt_nat.pvs0_tcc_termination(ebool,eop1,eop2)(pvs0_factorial)

% ------------------------------------------------------------------------------ 
% Part2: Any measure fulfilling pvs0_tcc can be used to prove PVS's tccs.
%
  MT_: TYPE+
  R_ : (well_founded?[MT_])

  IMPORTING measure_termination_defs
  	    [ nat   % Base type
	    , MT_   % Measure type
	    , R_    % Measure relation
	    ] AS mt_gen

  wfm_f_: mt_gen.WFM

  pvs0_factorial_pvs0_tcc_gen_termination: AXIOM
    mt_gen.pvs0_tcc_termination_(ebool,eop1,eop2)(pvs0_factorial)(wfm_f_)

  % By proving the TCCs generated by this importing clause, we are proving that any
  % measure type and any relation such that pvs0_tcc_termination is valid, can be
  % used to prove termination via TCC in PVS.
  IMPORTING factorial_ax {{ MT := MT_, R := R_ , wfm_f := wfm_f_}}

% ------------------------------------------------------------------------------ 
% Part3: Semantic equivalence between definitions.
%

  IMPORTING measure_termination
  	    [ nat    % Base type
	    , nat    % Measure type
	    , lt_nat % Measure relation
	    ] AS concrete_termination_th

  % concrete measure function
  mf: mt_nat.WFM = LAMBDA(n: nat): n

  % "less than" relation between two vals, based on the concrete instatiation
  % of the measure termination theory.
  lt_concrete_val(n1,n2: nat) : bool = 
    concrete_termination_th.lt_val(ebool,eop1,eop2)(pvs0_factorial)(mf)(n1,n2)

  IMPORTING orders@omega[nat, lt_concrete_val]

  Omega_factorial(n:nat) : nat = Omega(n)

  Omega_factorial_simp: LEMMA
    FORALL(n: nat): Omega_factorial(n) = n+1

  pvs0_factorial_eval: THEOREM
    FORALL(n: nat):
      LET v = eval(ebool,eop1,eop2)(n+1,pvs0_factorial)(val2env(n)) IN
      some?(v) AND factorial(n) = val(v)  

  eval_factorial(n:nat) : nat =
     val(eval(ebool,eop1,eop2)(Omega_factorial(n),pvs0_factorial)(val2env(n)))

  semantic_equivalence: COROLLARY
    FORALL(n: nat): factorial(n) = eval_factorial(n)

% ------------------------------------------------------------------------------ 
% Part4: Termination by CCG
%

  IMPORTING pvs0_to_ccg[nat,nat,lt_nat,2]

% ...

END factorial_pvs0
