measure_termination_defs[ T  : TYPE+
                       , MT : TYPE % measure type.
		       , lt : (well_founded?[MT])
  ] : THEORY
BEGIN
  IMPORTING lang[T],
  	    eval_props[T]

  WFM : TYPE =  [Val -> MT]
  
  eval_bool : VAR [Val -> bool] 
  eval_op1  : VAR [nat->[Val->Val]]
  eval_op2  : VAR [nat->[[Val,Val]->Val]]
  
  %% Termination by TCCs in PVS0  
  %
  pvs0_tcc_termination_(eval_bool,eval_op1,eval_op2)(def:Def)(wfm:WFM) : MACRO bool =
   FORALL (env:Environment) (cc : (pvs0_tcc_valid_cc(def))) (vact : Val):  
    semantic_rel_expr(eval_bool,eval_op1,eval_op2)(get_arg(cc`rec_expr),get_body(def),env,vact) AND
    eval_conds_rec(eval_bool,eval_op1,eval_op2)(get_body(def),cc`cnds,env)  
    IMPLIES lt(wfm(vact), wfm(env(vr)))

  pvs0_tcc_termination(eval_bool,eval_op1,eval_op2)(def:Def) : bool =
    EXISTS (wfm: WFM): pvs0_tcc_termination_(eval_bool,eval_op1,eval_op2)(def)(wfm)

  pvs0_ccs_rec(def: Def)(paths: list[(valid_path(get_body(def)))]) 
    : RECURSIVE { res: list[ (pvs0_tcc_valid_cc(def)) ] | 
      	      	FORALL(p: (valid_path(get_body(def)))):
  		LET subexpr = subterm_at(get_body(def), p) IN
  		member(p, paths) AND
  		rec?(subexpr) IMPLIES
  		LET cc: (pvs0_tcc_valid_cc(def)) = (# `path := p, 
  		       	    `rec_expr := subexpr, 
  		   	    `cnds     := path_conditions(get_body(def), p)  #) 
  	        IN member(cc, res) }
    = CASES paths OF
        null: null,
        cons(p, ps): LET subexpr = subterm_at(get_body(def), p) IN
        	      	   IF rec?(subexpr) 
  		   THEN cons( (# `rec_expr := subexpr, 
  		   	      	 `cnds     := path_conditions(get_body(def), p),
  				 `path     := p #) , pvs0_ccs_rec(def)(ps) )
  		   ELSE pvs0_ccs_rec(def)(ps) ENDIF
      ENDCASES 
    MEASURE paths BY <<

  pvs0_ccs(def: Def) : list[ (pvs0_tcc_valid_cc(def)) ] =
    pvs0_ccs_rec(def)(valid_paths(get_body(def)))

  pvs0_ccs_completness: LEMMA
    FORALL(def: Def, cc: (pvs0_tcc_valid_cc(def))): member(cc, pvs0_ccs(def))

END measure_termination_defs
