semi_algebraic_non_standard_form % Welcome
		: THEORY

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%| This is defining semi-algebraic |%
%| sets where the polynomials are  |%
%| over the reals with n variables |%
%| and are not required to be in   |%
%| standard form                   |%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Author:                         LW
% ***This contains all of Section 2.2 in
%     the paper***

%-----     %
  BEGIN
%     -----%

%--------------------------------------------------–-
%%Importing the definition of multivariate polynomials, 
%% operations, and evaluation.
%--------------------------------------------------–-

IMPORTING semi_algebraic

%--------------------------------------------------–-
%% Defining an atomic polynomial 
%-----------------------------------------------------


atomic_poly_ns: TYPE = [# poly:MultPoly, ineq:INEQ  #]

atom_eval_ns(atom:atomic_poly_ns)(x:list[real] | length(x) >= max_length(atom`poly)): bool = 
    atom`ineq(full_eval(atom`poly)(x),0)


%% negating an atom statement (used in complement)
negative_atom_ns(a:atomic_poly_ns): atomic_poly_ns =
    IF a`ineq = > 
        THEN (# poly := a`poly, ineq := <= #)
    ELSIF a`ineq = <=
        THEN (# poly := a`poly, ineq := > #)
    ELSIF a`ineq = <
        THEN (# poly := a`poly, ineq := >= #)
    ELSE
        (# poly := a`poly, ineq := < #)
    ENDIF

negative_atom_eval: LEMMA
    FORALL(a:atomic_poly_ns)(x:list[real] | length(x) >= max_length(a`poly)):
        atom_eval_ns(a)(x) = (NOT atom_eval_ns(negative_atom_ns(a))(x))

%-------------------------------------------------
%% intersection of a list of atomic polys
%-------------------------------------------------

% this list of atoms has truth value of the conjuction (and) of the atoms
meeting_ns: TYPE = list[atomic_poly_ns]

atom_max_ns(m:meeting_ns): RECURSIVE nat =
  IF m=null 
     THEN 0
  ELSE
     max(max_length(car(m)`poly), atom_max_ns(cdr(m)))
  ENDIF
  MEASURE length(m)

max_atom_ns: LEMMA
    FORALL(m1,m2:meeting_ns): atom_max_ns(append(m1,m2))
    = max(atom_max_ns(m1), atom_max_ns(m2))

% evaluating at a given x, returns TRUE or FALSE
meet_ns(m:meeting_ns)(x:list[real] | length(x) >= atom_max_ns(m)): RECURSIVE bool = 
    IF m = null
        THEN TRUE
    ELSE
        atom_eval_ns(car(m))(x) AND meet_ns(cdr(m))(x)
    ENDIF
    MEASURE length(m)

meet_meet_ns: LEMMA
    FORALL(m1,m2:meeting_ns, x:list[real] | length(x) >=
    max(atom_max_ns(m1),atom_max_ns(m2))):
        meet(append(m1,m2))(x) = (meet_ns(m1)(x) AND meet_ns(m2)(x))

meet_dim_ns: LEMMA
    FORALL(m:meeting_ns, x1:{xx:list[real] | length(xx) >=
    atom_max_ns(m)},x2:{xx:list[real] | length(xx) >
    length(x1)}):
    (FORALL(i:below(atom_max_ns(m))): nth(x1,i) = nth(x2,i))
        IMPLIES
        meet_ns(m)(x1) = meet_ns(m)(x2)

%------------------------------------------------
%% Union of intersections
%------------------------------------------------

% this list of conjuctive statements has truth value of the disjunction (or) of the conjunctives
joining_ns: TYPE = list[meeting_ns]

meet_max_ns(j:joining_ns): RECURSIVE nat =
  IF null?(j)
     THEN 0
  ELSE
     max(atom_max_ns(car(j)), meet_max_ns(cdr(j)))
  ENDIF
  MEASURE length(j)

max_meet_ns: LEMMA
    FORALL(j1,j2:joining_ns): meet_max_ns(append(j1,j2))
    = max(meet_max_ns(j1), meet_max_ns(j2))

meet_max_zero_ns: LEMMA
    FORALL(j:joining_ns): meet_max_ns(j) = 0 IMPLIES
    j=null OR (FORALL(i:below(length(j))): nth(j,i) = null OR FORALL(n:below(length(nth(j,i)))): max_length(nth(nth(j,i),n)`poly) = 0) 

join_ns(j:joining_ns)(x:list[real] | length(x) >= meet_max_ns(j)): RECURSIVE bool = 
    IF j = null
        THEN FALSE
    ELSE
        meet_ns(car(j))(x) OR join_ns(cdr(j))(x) 
    ENDIF
    MEASURE length(j) 

join_dim_ns: LEMMA
    FORALL(j:joining_ns, x1:{xx:list[real] | length(xx) >=
    meet_max_ns(j)},x2:{xx:list[real] | length(xx) >
    length(x1)}):
    (FORALL(i:below(meet_max_ns(j))): nth(x1,i) = nth(x2,i))
        IMPLIES
        join_ns(j)(x1) = join_ns(j)(x2)

%--------------------------------------
%% Distributing or/and
%--------------------------------------

append_to_each_ns(m:meeting_ns,L:joining_ns): RECURSIVE joining_ns = 
  IF L = null 
    THEN null 
  ELSE 
    cons(append(m,car(L)), append_to_each_ns(m,cdr(L)))
  ENDIF
  MEASURE length(L)

max_append_to_each_ns: LEMMA 
    FORALL(x:meeting_ns,L:joining_ns): cons?(L) IMPLIES
    meet_max_ns(append_to_each_ns(x,L)) = max(atom_max_ns(x),meet_max_ns(L))


append_join_ns: LEMMA
    FORALL(m:meeting_ns,L:joining_ns, x:list[real] | length(x)
    >= max(atom_max_ns(m),meet_max_ns(L))): 
        join_ns(append_to_each_ns(m,L))(x) = (meet_ns(m)(x) AND join_ns(L)(x))
  
%formula of the conjunction of two statements in DNF
cap_join_ns(j1,j2:joining_ns): RECURSIVE joining_ns =
    IF j1 = null 
        THEN null
    ELSIF j2 = null
        THEN null
    ELSE 
        append(append_to_each_ns(car(j1),j2), cap_join_ns(cdr(j1),j2))
    ENDIF
    MEASURE length(j1)


max_cap_join_ns: LEMMA
    FORALL(j1,j2:joining_ns): cons?(j1) AND cons?(j2)
    IMPLIES meet_max_ns(cap_join_ns(j1,j2)) = max(meet_max_ns(j1),meet_max_ns(j2))

%--------------------------------------------------------
%% Union and Intersections 
%--------------------------------------------------------

union_join_ns: LEMMA
    FORALL(j1,j2:joining, x:list[real] |
    length(x) >= max(meet_max_ns(j1),meet_max_ns(j2))):
        (join_ns(j1)(x) OR join_ns(j2)(x)) = join_ns(append(j1,j2))(x)

intersect_join_ns: LEMMA
    FORALL(j1,j2:joining, x:list[real] |
    length(x) >= max(meet_max_ns(j1),meet_max_ns(j2))): 
        (join_ns(j1)(x) AND join_ns(j2)(x)) = join_ns(cap_join(j1,j2))(x)

%---------------------------------------------------------
%% Negation of join
%---------------------------------------------------------

negative_atom_meet_ns(m:meeting_ns): RECURSIVE joining_ns =
    IF m=null 
        THEN null 
    ELSE 
        cons((: negative_atom_ns(car(m)) :),
	negative_atom_meet_ns(cdr(m)))
    ENDIF
    MEASURE length(m)

not_join_ns(j:joining_ns): RECURSIVE joining = 
    IF j=null
        THEN (: (: :) :)
    ELSE 
        cap_join_ns(negative_atom_meet_ns(car(j)), not_join_ns(cdr(j))) 
    ENDIF
    MEASURE length(j)

% @QED not_join_cons proved by lmwhite3 on Fri, 01 Apr 2022 16:25:30 GMT
not_join_cons_ns: LEMMA
    FORALL(j:joining_ns | FORALL(i:below(length(j))): cons?(nth(j,i))): cons?(not_join_ns(j))

% @QED not_join_null proved by lmwhite3 on Thu, 28 Apr 2022 15:29:56 GMT
not_join_null_ns: LEMMA
    FORALL(j:joining_ns | EXISTS(i:below(length(j))): null?(nth(j,i))): not_join_ns(j) = null

max_not_meet: LEMMA
    FORALL(m:meeting_ns): atom_max_ns(m) =
    meet_max_ns(negative_atom_meet_ns(m))

% @QED max_not_null proved by lmwhite3 on Fri, 01 Apr 2022 16:27:51 GMT
max_not_null_ns: LEMMA
    FORALL(j:joining_ns | FORALL(i:below(length(j))): cons?(nth(j,i))):
        meet_max_ns(j) = meet_max_ns(not_join_ns(j))

% @QED max_not proved by lmwhite3 on Mon, 25 Apr 2022 14:04:18 GMT
max_not_ns: LEMMA
    FORALL(j:joining_ns):
    IF (FORALL(i:below(length(j))): cons?(nth(j,i)))
        THEN meet_max_ns(j) = meet_max_ns(not_join_ns(j))
    ELSE
        0 = meet_max_ns(not_join_ns(j))
    ENDIF

not_meet_ns: LEMMA
    FORALL(m:meeting_ns, x:list[real] | length(x) >= atom_max_ns(m)): 
        (NOT meet_ns(m)(x)) = join_ns(negative_atom_meet_ns(m))(x)

not_join_ns: LEMMA
    FORALL(j:joining_ns, x:list[real] | length(x) >= meet_max_ns(j)): 
        (NOT join_ns(j)(x)) = join_ns(not_join_ns(j))(x)

%-------------------------------------------------
%% Semi-algebraic set 
%-------------------------------------------------

semi_alg_ns(j:joining_ns)(n:nat | n >= meet_max_ns(j)):
set[VectorN(n)] = { x:VectorN(n) | join_ns(j)(x) = TRUE }

%--------------------------------------------------
%% Properties of semi-algebraic sets
%--------------------------------------------------

% the semi-alg that gives all of R^n
%all_true: LEMMA
% FORALL(n:nat): semi_alg((: (: :) :))(n) = {x:VectorN(n) | true}

%--------------------------------------------------
%*** This is Theorem 2.3 in the Paper ***
%--------------------------------------------------

% closed under union
%sa_union: LEMMA
%    FORALL(j1,j2:joining, n:nat | n >= max(meet_max(j1),meet_max(j2))): 
%        EXISTS(j:joining): n >= meet_max(j) IMPLIES
%	union(semi_alg(j1)(n),semi_alg(j2)(n)) = semi_alg(j)(n)
 
% closed under intersection
%sa_intersection: LEMMA
%    FORALL(j1,j2:joining, n:nat | n >= max(meet_max(j1),meet_max(j2))): 
%        EXISTS(j:joining): n >= meet_max(j) IMPLIES
%	intersection(semi_alg(j1)(n),semi_alg(j2)(n)) = semi_alg(j)(n)

% closed under complement
%sa_complement: LEMMA
%    FORALL(j:joining, n:nat | n >= meet_max(j)): 
%        EXISTS(j1:joining): n >= meet_max(j1) IMPLIES
%	complement(semi_alg(j)(n)) = semi_alg(j1)(n)

% closed under set minus
%sa_difference: LEMMA
%    FORALL(j1,j2:joining, n:nat | n >= max(meet_max(j1),meet_max(j2))): 
%        EXISTS(j:joining): n >= meet_max(j) IMPLIES
%	difference(semi_alg(j1)(n),semi_alg(j2)(n)) = semi_alg(j)(n)

%~~~           The End          ~~~%
END semi_algebraic_non_standard_form
