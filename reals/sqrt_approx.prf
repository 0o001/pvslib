(sqrt_approx
 (sq_sq_aux 0
  (sq_sq_aux-1 nil 3320768920 ("" (grind) nil nil)
   ((nnreal_div_posreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (sq const-decl "nonneg_real" sq nil))
   shostak))
 (sqrt_newton_step_TCC1 0
  (sqrt_newton_step_TCC1-1 nil 3626000882
   ("" (skosimp* :preds? t)
    (("" (move-terms 1 l 1)
      (("" (rewrite "sq_sq_aux") (("" (ground) nil nil)) nil)) nil))
    nil)
   ((posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (sq_nz_pos application-judgement "posreal" sq nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (sq_sq_aux formula-decl nil sqrt_approx nil)
    (nnreal type-eq-decl nil real_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (<= const-decl "bool" reals nil)
    (sq const-decl "nonneg_real" sq nil))
   nil))
 (sqrt_newton_step_increasing 0
  (sqrt_newton_step_increasing-1 nil 3626006724
   ("" (skeep)
    (("" (case "x1<=sq(y2)")
      (("1"
        (case "sqrt_newton_step(x1, y1)<=sqrt_newton_step(x1, y2) AND 
sqrt_newton_step(x1, y2)<= sqrt_newton_step(x2, y2)")
        (("1" (flatten) (("1" (ground) nil nil)) nil)
         ("2" (hide 2)
          (("2" (split 1)
            (("1" (case "x1<=y1*y2")
              (("1" (div-by -1 "y1*y2")
                (("1" (move-terms -1 l 1)
                  (("1" (move-terms -4 l 1)
                    (("1" (mult-ineq -1 -4)
                      (("1" (simplify -1)
                        (("1" (expand "sqrt_newton_step")
                          (("1" (grind-reals) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (typepred (y1))
                (("2" (hide 2)
                  (("2" (grind-reals)
                    (("2" (both-sides-f -3 "sqrt")
                      (("1" (both-sides-f -4 "sqrt")
                        (("1" (mult-ineq -1 -2)
                          (("1" (rewrite "sqrt_sq")
                            (("1" (rewrite "sqrt_sq")
                              (("1"
                                (lemma "sq_sqrt")
                                (("1"
                                  (inst -1 "x1")
                                  (("1"
                                    (expand "sq")
                                    (("1" (ground) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (rewrite "sqrt_le") nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "sqrt_newton_step")
              (("2" (grind-reals) nil nil)) nil))
            nil))
          nil)
         ("3" (flatten) nil nil) ("4" (propax) nil nil))
        nil)
       ("2" (typepred (y2)) (("2" (ground) nil nil)) nil))
      nil))
    nil)
   ((sq const-decl "nonneg_real" sq nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (both_sides_plus_le1 formula-decl nil real_props nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_times_le_any1 formula-decl nil extra_real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (div_simp formula-decl nil real_props nil)
    (both_sides_div_pos_le1 formula-decl nil real_props nil)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nnreal type-eq-decl nil real_types nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (sq_sqrt formula-decl nil sqrt nil)
    (sqrt_pos application-judgement "posreal" sqrt nil)
    (sqrt_sq formula-decl nil sqrt nil)
    (sqrt_le formula-decl nil sqrt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sq_nz_pos application-judgement "posreal" sq nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sqrt_newton_step const-decl "{z | X <= sq(z)}" sqrt_approx nil))
   shostak))
 (sqrt_newton_interv_TCC1 0
  (sqrt_newton_interv_TCC1-1 nil 3626606845 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (sq const-decl "nonneg_real" sq nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (sq_nz_pos application-judgement "posreal" sq nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (sqrt_newton_interv_TCC2 0
  (sqrt_newton_interv_TCC2-1 nil 3626606845
   ("" (termination-tcc) nil nil) nil nil))
 (sqrt_newton_interv_increasing 0
  (sqrt_newton_interv_increasing-1 nil 3626607143
   ("" (induct "n")
    (("1" (skeep)
      (("1" (expand "sqrt_newton_interv") (("1" (propax) nil nil))
        nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand "sqrt_newton_interv" 1)
          (("2"
            (inst -1 "x1" "x2" "sqrt_newton_step(x1, y1)"
             "sqrt_newton_step(x2, y2)")
            (("2" (ground)
              (("2" (hide 2)
                (("2" (rewrite "sqrt_newton_step_increasing") nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sqrt_newton_step_increasing formula-decl nil sqrt_approx nil)
    (sqrt_newton_step const-decl "{z | X <= sq(z)}" sqrt_approx nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (sqrt_newton_interv def-decl "{z | X <= sq(z)}" sqrt_approx nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sq const-decl "nonneg_real" sq nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (sqrt_int_TCC1 0
  (sqrt_int_TCC1-1 nil 3626609815 ("" (subtype-tcc) nil nil)
   ((nnrat_exp application-judgement "nnrat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (sq const-decl "nonneg_real" sq nil))
   nil))
 (sqrt_int_TCC2 0
  (sqrt_int_TCC2-1 nil 3626609815
   ("" (skeep)
    (("" (ground)
      (("1" (typepred "sqrt_newton_interv(X, 2, n)")
        (("1" (expand "sq " 1)
          (("1" (rewrite "expt_plus" :dir rl)
            (("1" (rewrite "expt_times")
              (("1" (case-replace "2^2 = 4")
                (("1" (expand "sq")
                  (("1" (typepred (x))
                    (("1" (replaces -3 :dir rl)
                      (("1" (cancel-by 1 "4^M") nil nil)) nil))
                    nil))
                  nil)
                 ("2" (eval-formula 1) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (case "FORALL (nn:nat): sqrt_newton_interv(4,2,nn)=2")
        (("1" (inst -1 "n")
          (("1" (rewrite "expt_plus")
            (("1" (rewrite "expt_x1")
              (("1" (cancel-by 1 "2^M")
                (("1" (lemma "sqrt_newton_interv_increasing")
                  (("1" (inst -1 "X" "4" "2" "2" "n")
                    (("1" (ground) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide-all-but 1)
          (("2" (induct "nn")
            (("1" (expand "sqrt_newton_interv")
              (("1" (propax) nil nil)) nil)
             ("2" (skeep)
              (("2" (expand "sqrt_newton_interv" 1)
                (("2" (case-replace "sqrt_newton_step(4,2) = 2")
                  (("2" (expand "sqrt_newton_step")
                    (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("3" (expand "sq") (("3" (ground) nil nil)) nil))
            nil))
          nil)
         ("3" (expand "sq") (("3" (ground) nil nil)) nil))
        nil)
       ("3" (case "FORALL (nn:nat): sqrt_newton_interv(1,1,nn)=1")
        (("1" (inst -1 "n")
          (("1" (lemma "sqrt_newton_interv_increasing")
            (("1" (inst -1 "1" "X" "1" "2" "n")
              (("1" (ground) (("1" (cancel-by 1 "2^M") nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (induct "nn")
          (("1" (expand "sqrt_newton_interv") (("1" (propax) nil nil))
            nil)
           ("2" (hide-all-but 1)
            (("2" (skeep)
              (("2" (expand "sqrt_newton_interv" 1)
                (("2" (case "sqrt_newton_step(1,1)=1")
                  (("1" (replaces -1) nil nil)
                   ("2" (expand "sqrt_newton_step")
                    (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (sq_nz_pos application-judgement "posreal" sq nil)
    (expt_times formula-decl nil exponentiation nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (nonneg_rat nonempty-type-eq-decl nil rationals nil)
    (posrat nonempty-type-eq-decl nil rationals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (both_sides_times_pos_ge1 formula-decl nil real_props nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (expt_plus formula-decl nil exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (sq const-decl "nonneg_real" sq nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sqrt_newton_interv def-decl "{z | X <= sq(z)}" sqrt_approx nil)
    (sqrt_newton_step const-decl "{z | X <= sq(z)}" sqrt_approx nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (sqrt_newton_interv_increasing formula-decl nil sqrt_approx nil)
    (both_sides_times_pos_le1 formula-decl nil real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (sq_1 formula-decl nil sq nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil))
   nil))
 (sqrt_int_ub_TCC1 0
  (sqrt_int_ub_TCC1-1 nil 3626616415 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sq const-decl "nonneg_real" sq nil))
   nil))
 (sqrt_int_ub_TCC2 0
  (sqrt_int_ub_TCC2-1 nil 3626616415 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (sqrt_int_ub_TCC3 0
  (sqrt_int_ub_TCC3-1 nil 3626616415 ("" (subtype-tcc) nil nil)
   ((nnrat_exp application-judgement "nnrat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil))
   nil))
 (sqrt_int_ub_TCC4 0
  (sqrt_int_ub_TCC4-1 nil 3626616415 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil))
   nil))
 (sqrt_int_ub_TCC5 0
  (sqrt_int_ub_TCC5-1 nil 3626616415
   ("" (skeep)
    (("" (skeep)
      ((""
        (typepred
         "sqrt_int(M, Y, x, 3 + log_nat(max(1, 10 / 3 * M + n), 2)`1)")
        ((""
          (name-replace "srt"
           "sqrt_int(M, Y, x, 3 + log_nat(max(1, 10 / 3 * M + n), 2)`1)")
          (("" (ground) nil nil)) nil))
        nil))
      nil))
    nil)
   ((posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sq_nz_pos application-judgement "posreal" sq nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sq const-decl "nonneg_real" sq nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sqrt_int const-decl
     "{z | sq(z) >= x AND z <= 2 ^ (M + 1) AND z >= 2 ^ M}" sqrt_approx
     nil)
    (< const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (above nonempty-type-eq-decl nil integers nil)
    (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat
     nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posint_exp application-judgement "posint" exponentiation nil))
   nil))
 (sqrt_ub_TCC1 0
  (sqrt_ub_TCC1-1 nil 3626617109 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (sq const-decl "nonneg_real" sq nil)
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil))
   nil))
 (sqrt_ub_increasing 0
  (sqrt_ub_increasing-1 nil 3626617036
   ("" (skeep)
    (("" (case "sqrt_int_ub(x,n)<=sqrt_int_ub(y,n)")
      (("1" (expand "sqrt_ub")
        (("1" (ground)
          (("1" (lift-if 1)
            (("1" (split)
              (("1" (flatten)
                (("1" (ground)
                  (("1" (lift-if 1)
                    (("1" (split 1)
                      (("1" (flatten) (("1" (ground) nil nil)) nil)
                       ("2" (flatten) (("2" (ground) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (ground)
                  (("2" (lift-if 2)
                    (("2" (split 2)
                      (("1" (flatten)
                        (("1" (ground)
                          (("1" (flip-ineq 1)
                            (("1" (flip-ineq 1)
                              (("1"
                                (typepred "sqrt_int_ub(x, n)")
                                (("1"
                                  (typepred "sqrt_int_ub(y, n)")
                                  (("1"
                                    (name-replace
                                     "rtx"
                                     "sqrt_int_ub(x, n)")
                                    (("1"
                                      (name-replace
                                       "rty"
                                       "sqrt_int_ub(y, n)")
                                      (("1" (grind-reals) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (ground) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (expand "sqrt_int_ub")
          (("2" (lift-if 1)
            (("2" (ground)
              (("1" (lift-if 1) (("1" (ground) nil nil)) nil)
               ("2" (name-replace "Lx" "log_int(x,4)")
                (("2" (name-replace "Ly" "log_int(y,4)")
                  (("2" (case "Lx`1<Ly`1")
                    (("1"
                      (typepred
                       "sqrt_int(Lx`1, Lx`2, x, 3 + log_nat(max(1, 10/3 * Lx`1 + n), 2)`1)")
                      (("1"
                        (typepred
                         " sqrt_int(Ly`1, Ly`2, y, 3 + log_nat(max(1, 10/3 * Ly`1 + n), 2)`1)")
                        (("1" (ground)
                          (("1" (case "Lx`1+1<=Ly`1")
                            (("1" (lemma "both_sides_expt_gt1_le")
                              (("1"
                                (inst -1 "2" "Lx`1+1" "Ly`1")
                                (("1"
                                  (flatten)
                                  (("1"
                                    (hide -1)
                                    (("1" (ground) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (ground) nil nil))
                            nil))
                          nil)
                         ("2" (expand "Ly") (("2" (ground) nil nil))
                          nil))
                        nil)
                       ("2" (expand "Lx") (("2" (ground) nil nil))
                        nil))
                      nil)
                     ("2" (case "Lx`1 = Ly`1")
                      (("1" (expand "sqrt_int")
                        (("1" (replace -1 3)
                          (("1" (cancel-by 3 "2^Ly`1")
                            (("1"
                              (lemma "sqrt_newton_interv_increasing")
                              (("1"
                                (inst
                                 -1
                                 "Lx`2"
                                 "Ly`2"
                                 "2"
                                 "2"
                                 "3 + log_nat(max(1, 10/3 * Ly`1 + n), 2)`1")
                                (("1"
                                  (ground)
                                  (("1"
                                    (typepred "Lx`2")
                                    (("1"
                                      (typepred "Ly`2")
                                      (("1"
                                        (replace -3)
                                        (("1"
                                          (replace -6)
                                          (("1"
                                            (replace -8)
                                            (("1"
                                              (cancel-by -9 "4^Ly`1")
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (lemma "log_int_le")
                        (("2" (inst -1 "4" "x" "y")
                          (("2" (ground)
                            (("2" (expand "Lx")
                              (("2"
                                (expand "Ly")
                                (("2" (ground) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sqrt_int_ub const-decl "{zz | x <= sq(zz)}" sqrt_approx nil)
    (sq const-decl "nonneg_real" sq nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (integer nonempty-type-from-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (sqrt_ub const-decl "{zz | x <= sq(zz)}" sqrt_approx nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (rat_max application-judgement "{s: rat | s >= q AND s >= r}"
     real_defs nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (sqrt_newton_interv_increasing formula-decl nil sqrt_approx nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (both_sides_times_pos_le1 formula-decl nil real_props nil)
    (sqrt_newton_interv def-decl "{z | X <= sq(z)}" sqrt_approx nil)
    (y skolem-const-decl "nnreal" sqrt_approx nil)
    (x skolem-const-decl "nnreal" sqrt_approx nil)
    (nonneg_rat nonempty-type-eq-decl nil rationals nil)
    (posrat nonempty-type-eq-decl nil rationals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (log_int_le formula-decl nil log_int nil)
    (sqrt_int const-decl
     "{z | sq(z) >= x AND z <= 2 ^ (M + 1) AND z >= 2 ^ M}" sqrt_approx
     nil)
    (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat
     nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (Ly skolem-const-decl
     "[z: int, {y_1: real | y_1 < 4 AND y_1 >= 1 AND y = 4 ^ z * y_1}]"
     sqrt_approx nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (sq_nz_pos application-judgement "posreal" sq nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (both_sides_expt_gt1_le formula-decl nil exponentiation nil)
    (Lx skolem-const-decl
     "[z: int, {y: real | y < 4 AND y >= 1 AND x = 4 ^ z * y}]"
     sqrt_approx nil)
    (log_int const-decl
     "[z: int, {y: real | y < p AND y >= 1 AND x = p ^ z * y}]" log_int
     nil)
    (above nonempty-type-eq-decl nil integers nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   shostak))
 (sqrt_newton_interv_lower_TCC1 0
  (sqrt_newton_interv_lower_TCC1-1 nil 3626713257
   ("" (skeep)
    (("" (typepred (X))
      (("" (split)
        (("1" (cross-mult) nil nil) ("2" (cross-mult) nil nil)) nil))
      nil))
    nil)
   ((<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (div_mult_pos_le1 formula-decl nil real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (div_mult_pos_ge1 formula-decl nil real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil))
   nil))
 (sqrt_newton_interv_lower_TCC2 0
  (sqrt_newton_interv_lower_TCC2-1 nil 3626713257
   ("" (skeep :preds? t)
    (("" (rewrite "sq_div")
      (("" (grind-reals)
        (("" (expand "sq") (("" (ground) nil nil)) nil)) nil))
      nil))
    nil)
   ((sq_div formula-decl nil sq nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (sq const-decl "nonneg_real" sq nil)
    (sq_nz_pos application-judgement "posreal" sq nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (le_times_le_pos formula-decl nil real_props nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (times_div2 formula-decl nil real_props nil)
    (div_mult_pos_le1 formula-decl nil real_props nil)
    (div_mult_pos_le2 formula-decl nil real_props nil))
   nil))
 (sqrt_newton_interv_lower_TCC3 0
  (sqrt_newton_interv_lower_TCC3-1 nil 3626713257
   ("" (skeep :preds? t)
    (("" (rewrite "sq_div")
      (("" (typepred " sqrt_newton_interv(4 / X, 2 / Y, n)")
        (("" (expand "sq") (("" (grind-reals) nil nil)) nil)) nil))
      nil))
    nil)
   ((posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (sq_div formula-decl nil sq nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (sq const-decl "nonneg_real" sq nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sqrt_newton_interv def-decl "{z | X <= sq(z)}" sqrt_approx nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (sq_nz_pos application-judgement "posreal" sq nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (div_mult_pos_ge2 formula-decl nil real_props nil)
    (div_mult_pos_le1 formula-decl nil real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   nil))
 (sqrt_newton_interv_lower_increasing 0
  (sqrt_newton_interv_lower_increasing-1 nil 3626713806
   ("" (skeep)
    (("" (expand "sqrt_newton_interv_lower")
      (("" (cross-mult)
        (("" (lemma "sqrt_newton_interv_increasing")
          (("" (inst -1 "4/x2" "4/x1" "2/y2" "2/y1" "n")
            (("" (ground)
              (("1" (cross-mult) nil nil) ("2" (cross-mult) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sqrt_newton_interv_lower const-decl "{z | X >= sq(z)}" sqrt_approx
     nil)
    (sqrt_newton_interv_increasing formula-decl nil sqrt_approx nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (div_mult_pos_le2 formula-decl nil real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (times_div2 formula-decl nil real_props nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (sq const-decl "nonneg_real" sq nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sqrt_newton_interv def-decl "{z | X <= sq(z)}" sqrt_approx nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (div_mult_pos_le1 formula-decl nil real_props nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil))
   shostak))
 (sqrt_int_lower_TCC1 0
  (sqrt_int_lower_TCC1-1 nil 3626715471 ("" (subtype-tcc) nil nil)
   ((nnrat_exp application-judgement "nnrat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (sq const-decl "nonneg_real" sq nil))
   nil))
 (sqrt_int_lower_TCC2 0
  (sqrt_int_lower_TCC2-1 nil 3626715471
   ("" (skeep)
    (("" (ground)
      (("1" (typepred "sqrt_newton_interv_lower(X, 1, n)")
        (("1" (expand "sq " 1)
          (("1" (rewrite "expt_plus" :dir rl)
            (("1" (rewrite "expt_times")
              (("1" (case-replace "2^2 = 4")
                (("1" (expand "sq")
                  (("1" (typepred (x))
                    (("1" (replaces -3 :dir rl)
                      (("1" (cancel-by 1 "4^M") nil nil)) nil))
                    nil))
                  nil)
                 ("2" (eval-formula 1) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (case "sqrt_newton_interv_lower(4,2,n) = 2")
        (("1" (rewrite "expt_plus")
          (("1" (rewrite "expt_x1")
            (("1" (cancel-by 1 "2^M")
              (("1" (lemma "sqrt_newton_interv_lower_increasing")
                (("1" (inst -1 "X" "4" "1" "2" "n")
                  (("1" (ground) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide-all-but 1)
          (("2" (expand "sqrt_newton_interv_lower")
            (("2"
              (case "FORALL (nn:nat): sqrt_newton_interv(1,1,nn)=1")
              (("1" (inst -1 "n") (("1" (ground) nil nil)) nil)
               ("2" (induct "nn")
                (("1" (expand "sqrt_newton_interv")
                  (("1" (propax) nil nil)) nil)
                 ("2" (hide-all-but 1)
                  (("2" (skeep)
                    (("2" (expand "sqrt_newton_interv" 1)
                      (("2" (case "sqrt_newton_step(1,1)=1")
                        (("1" (replaces -1) nil nil)
                         ("2" (expand "sqrt_newton_step")
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (expand "sq") (("3" (ground) nil nil)) nil))
        nil)
       ("3" (case "sqrt_newton_interv_lower(1,1,n) = 1")
        (("1" (lemma "sqrt_newton_interv_lower_increasing")
          (("1" (inst -1 "1" "X" "1" "1" "n")
            (("1" (ground) (("1" (cancel-by 1 "2^M") nil nil)) nil))
            nil))
          nil)
         ("2" (expand "sqrt_newton_interv_lower")
          (("2" (case "FORALL (nn:nat): sqrt_newton_interv(4,2,nn)=2")
            (("1" (inst -1 "n") (("1" (ground) nil nil)) nil)
             ("2" (hide-all-but 1)
              (("2" (induct "nn")
                (("1" (expand "sqrt_newton_interv")
                  (("1" (propax) nil nil)) nil)
                 ("2" (skeep)
                  (("2" (expand "sqrt_newton_interv" 1)
                    (("2" (case-replace "sqrt_newton_step(4,2) = 2")
                      (("2" (expand "sqrt_newton_step")
                        (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("3" (expand "sq") (("3" (ground) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (sq_nz_pos application-judgement "posreal" sq nil)
    (expt_times formula-decl nil exponentiation nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (nonneg_rat nonempty-type-eq-decl nil rationals nil)
    (posrat nonempty-type-eq-decl nil rationals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (both_sides_times_pos_le1 formula-decl nil real_props nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (^ const-decl "real" exponentiation nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (expt_plus formula-decl nil exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (sq const-decl "nonneg_real" sq nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sqrt_newton_interv_lower const-decl "{z | X >= sq(z)}" sqrt_approx
     nil)
    (sqrt_newton_interv def-decl "{z | X <= sq(z)}" sqrt_approx nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (sqrt_newton_step const-decl "{z | X <= sq(z)}" sqrt_approx nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (sqrt_newton_interv_lower_increasing formula-decl nil sqrt_approx
     nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (both_sides_times_pos_ge1 formula-decl nil real_props nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil))
   nil))
 (sqrt_int_lb_TCC1 0
  (sqrt_int_lb_TCC1-1 nil 3626717160 ("" (subtype-tcc) nil nil)
   ((sq const-decl "nonneg_real" sq nil)) nil))
 (sqrt_int_lb_TCC2 0
  (sqrt_int_lb_TCC2-1 nil 3626717160
   ("" (skeep)
    (("" (skeep)
      ((""
        (typepred
         " sqrt_int_lower(M, Y, x, 3 + log_nat(max(1, 10 / 3 * M + n), 2)`1)")
        (("" (ground) nil nil)) nil))
      nil))
    nil)
   ((rat_max application-judgement "{s: rat | s >= q AND s >= r}"
     real_defs nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sq_nz_pos application-judgement "posreal" sq nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sq const-decl "nonneg_real" sq nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sqrt_int_lower const-decl
     "{z | sq(z) <= x AND z <= 2 ^ (M + 1) AND z >= 2 ^ M}" sqrt_approx
     nil)
    (< const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (above nonempty-type-eq-decl nil integers nil)
    (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat
     nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posint_exp application-judgement "posint" exponentiation nil))
   nil))
 (sqrt_lb_TCC1 0
  (sqrt_lb_TCC1-1 nil 3626438073 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (sq const-decl "nonneg_real" sq nil)
    (nonneg_ceiling_is_nat application-judgement "nat" floor_ceil nil))
   nil))
 (sqrt_lb_increasing 0
  (sqrt_lb_increasing-1 nil 3626717544
   ("" (skeep)
    (("" (case "sqrt_int_lb(x,n)<=sqrt_int_lb(y,n)")
      (("1" (expand "sqrt_lb")
        (("1" (ground)
          (("1" (lift-if 1)
            (("1" (split)
              (("1" (flatten)
                (("1" (ground)
                  (("1" (lift-if 1)
                    (("1" (split 1)
                      (("1" (flatten) (("1" (ground) nil nil)) nil)
                       ("2" (flatten)
                        (("2" (ground)
                          (("2" (flip-ineq 1)
                            (("2" (flip-ineq 1)
                              (("2"
                                (typepred "sqrt_int_lb(x, n)")
                                (("2"
                                  (typepred "sqrt_int_lb(y, n)")
                                  (("2"
                                    (name-replace
                                     "rtx"
                                     "sqrt_int_lb(x, n)")
                                    (("2"
                                      (name-replace
                                       "rty"
                                       "sqrt_int_lb(y, n)")
                                      (("2" (grind-reals) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (ground)
                  (("2" (lift-if 2)
                    (("2" (split 2)
                      (("1" (flatten) (("1" (ground) nil nil)) nil)
                       ("2" (flatten) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (expand "sqrt_int_lb")
          (("2" (lift-if 1)
            (("2" (ground)
              (("1" (lift-if 1) (("1" (ground) nil nil)) nil)
               ("2" (name-replace "Lx" "log_int(x,4)")
                (("2" (name-replace "Ly" "log_int(y,4)")
                  (("2" (case "Lx`1<Ly`1")
                    (("1"
                      (typepred
                       "sqrt_int_lower(Lx`1, Lx`2, x, 3 + log_nat(max(1, 10/3 * Lx`1 + n), 2)`1)")
                      (("1"
                        (typepred
                         " sqrt_int_lower(Ly`1, Ly`2, y, 3 + log_nat(max(1, 10/3 * Ly`1 + n), 2)`1)")
                        (("1" (ground)
                          (("1" (case "Lx`1+1<=Ly`1")
                            (("1" (lemma "both_sides_expt_gt1_le")
                              (("1"
                                (inst -1 "2" "Lx`1+1" "Ly`1")
                                (("1"
                                  (flatten)
                                  (("1"
                                    (hide -1)
                                    (("1" (ground) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (ground) nil nil))
                            nil))
                          nil)
                         ("2" (expand "Ly") (("2" (ground) nil nil))
                          nil))
                        nil)
                       ("2" (expand "Lx") (("2" (ground) nil nil))
                        nil))
                      nil)
                     ("2" (case "Lx`1 = Ly`1")
                      (("1" (expand "sqrt_int_lower")
                        (("1" (replace -1 3)
                          (("1" (cancel-by 3 "2^Ly`1")
                            (("1"
                              (lemma
                               "sqrt_newton_interv_lower_increasing")
                              (("1"
                                (inst
                                 -1
                                 "Lx`2"
                                 "Ly`2"
                                 "1"
                                 "1"
                                 "3 + log_nat(max(1, 10/3 * Ly`1 + n), 2)`1")
                                (("1"
                                  (ground)
                                  (("1"
                                    (typepred "Lx`2")
                                    (("1"
                                      (typepred "Ly`2")
                                      (("1"
                                        (replace -3)
                                        (("1"
                                          (replace -6)
                                          (("1"
                                            (replace -8)
                                            (("1"
                                              (cancel-by -9 "4^Ly`1")
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (lemma "log_int_le")
                        (("2" (inst -1 "4" "x" "y")
                          (("2" (ground)
                            (("2" (expand "Lx")
                              (("2"
                                (expand "Ly")
                                (("2" (ground) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sqrt_int_lb const-decl "{zz | x >= sq(zz)}" sqrt_approx nil)
    (sq const-decl "nonneg_real" sq nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonneg_ceiling_is_nat application-judgement "nat" floor_ceil nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ceiling const-decl "{i | x <= i & i < x + 1}" floor_ceil nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (integer nonempty-type-from-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (sqrt_lb const-decl "{zz | x >= sq(zz)}" sqrt_approx nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (rat_max application-judgement "{s: rat | s >= q AND s >= r}"
     real_defs nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (sqrt_newton_interv_lower_increasing formula-decl nil sqrt_approx
     nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (both_sides_times_pos_le1 formula-decl nil real_props nil)
    (sqrt_newton_interv_lower const-decl "{z | X >= sq(z)}" sqrt_approx
     nil)
    (y skolem-const-decl "nnreal" sqrt_approx nil)
    (x skolem-const-decl "nnreal" sqrt_approx nil)
    (nonneg_rat nonempty-type-eq-decl nil rationals nil)
    (posrat nonempty-type-eq-decl nil rationals nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (log_int_le formula-decl nil log_int nil)
    (sqrt_int_lower const-decl
     "{z | sq(z) <= x AND z <= 2 ^ (M + 1) AND z >= 2 ^ M}" sqrt_approx
     nil)
    (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat
     nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (Ly skolem-const-decl
     "[z: int, {y_1: real | y_1 < 4 AND y_1 >= 1 AND y = 4 ^ z * y_1}]"
     sqrt_approx nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (sq_nz_pos application-judgement "posreal" sq nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (both_sides_expt_gt1_le formula-decl nil exponentiation nil)
    (Lx skolem-const-decl
     "[z: int, {y: real | y < 4 AND y >= 1 AND x = 4 ^ z * y}]"
     sqrt_approx nil)
    (log_int const-decl
     "[z: int, {y: real | y < p AND y >= 1 AND x = p ^ z * y}]" log_int
     nil)
    (above nonempty-type-eq-decl nil integers nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   shostak))
 (sqrt_bounds 0
  (sqrt_bounds-1 nil 3626438092
   ("" (skeep)
    (("" (ground)
      (("1" (typepred "sqrt_lb(x,n)")
        (("1" (flip-ineq 1)
          (("1" (mult-ineq -1 -1)
            (("1" (lemma "sq_sqrt")
              (("1" (inst -1 "x")
                (("1" (split -1)
                  (("1" (expand "sq") (("1" (ground) nil nil)) nil)
                   ("2" (ground) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred "sqrt_ub(x,n)")
        (("2" (flip-ineq 1)
          (("2" (mult-ineq -1 -1)
            (("2" (lemma "sq_sqrt")
              (("2" (inst -1 "x")
                (("2" (split)
                  (("1" (expand "sq") (("1" (ground) nil nil)) nil)
                   ("2" (ground) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (> const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sq_sqrt formula-decl nil sqrt nil)
    (gt_times_gt_any1 formula-decl nil extra_real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nnreal type-eq-decl nil real_types nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (sq const-decl "nonneg_real" sq nil)
    (sqrt_lb const-decl "{zz | x >= sq(zz)}" sqrt_approx nil)
    (<= const-decl "bool" reals nil)
    (sqrt_ub const-decl "{zz | x <= sq(zz)}" sqrt_approx nil))
   shostak)))

