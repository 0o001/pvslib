(ln_derivative_lam
 (IMP_derivatives_lam_TCC1 0
  (IMP_derivatives_lam_TCC1-1 nil 3828021036
   ("" (lemma "deriv_domain") (("" (propax) nil nil)) nil)
   ((deriv_domain formula-decl nil ln_derivative_lam nil)) nil
   (IMP_derivatives_lam assuming
    "analysis@derivatives_lam[T].derivatives_lam"
    "deriv_domain: ASSUMPTION deriv_domain_def[T].deriv_domain?")))
 (IMP_derivatives_lam_TCC2 0
  (IMP_derivatives_lam_TCC2-1 nil 3828021036
   ("" (lemma "not_one_element") (("" (propax) nil nil)) nil)
   ((not_one_element formula-decl nil ln_derivative_lam nil)) nil
   (IMP_derivatives_lam assuming
    "analysis@derivatives_lam[T].derivatives_lam"
    "not_one_element: ASSUMPTION deriv_domain_def[T].not_one_element?")))
 (IMP_chain_rule_TCC1 0
  (IMP_chain_rule_TCC1-1 nil 3828021036
   ("" (lemma "deriv_domain_posreal") (("" (propax) nil nil)) nil)
   ((deriv_domain_posreal formula-decl nil deriv_domain analysis)) nil
   (IMP_chain_rule assuming
    "analysis@chain_rule[T, posreal].chain_rule"
    "deriv_domain2: ASSUMPTION deriv_domain_def[T2].deriv_domain?")))
 (IMP_chain_rule_TCC2 0
  (IMP_chain_rule_TCC2-1 nil 3828021036
   ("" (lemma "not_one_element_posreal") (("" (propax) nil nil)) nil)
   ((not_one_element_posreal formula-decl nil deriv_domain analysis))
   nil
   (IMP_chain_rule assuming
    "analysis@chain_rule[T, posreal].chain_rule"
    "not_one_element2: ASSUMPTION deriv_domain_def[T2].not_one_element?")))
 (derivable_ln_lam 0
  (derivable_ln_lam-1 nil 3828009602
   ("" (skeep :preds? t)
    (("" (lemma "composition_derivable_fun")
      (("" (inst -1 "p" "ln")
        (("" (assert)
          (("" (split -1)
            (("1" (expand "o") (("1" (propax) nil nil)) nil)
             ("2" (hide (-1 2))
              (("2" (lemma "ln_derivable") (("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T formal-subtype-decl nil ln_derivative_lam nil)
    (T_pred const-decl "[real -> boolean]" ln_derivative_lam nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (composition_derivable_fun formula-decl nil chain_rule analysis)
    (ln_derivable formula-decl nil ln_exp nil)
    (O const-decl "T3" function_props nil)
    (ln const-decl "real" ln_exp nil)
    (derivable? const-decl "bool" derivatives analysis)
    (pos_fun type-eq-decl nil ln_derivative_lam nil))
   shostak))
 (derivable_ln_lam_point 0
  (derivable_ln_lam_point-1 nil 3828010215
   ("" (skeep :preds? t)
    (("" (lemma "comp_derivable_point")
      (("" (inst -1 "pp" "ln" "x")
        (("" (assert)
          (("" (lemma "ln_derivable")
            (("" (flatten)
              (("" (expand "derivable?" -1)
                (("" (inst -1 "pp(x)") nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T formal-subtype-decl nil ln_derivative_lam nil)
    (T_pred const-decl "[real -> boolean]" ln_derivative_lam nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (comp_derivable_point formula-decl nil chain_rule analysis)
    (derivable? const-decl "bool" derivatives analysis)
    (ln_derivable formula-decl nil ln_exp nil)
    (ln const-decl "real" ln_exp nil)
    (pos_fun type-eq-decl nil ln_derivative_lam nil))
   shostak))
 (deriv_ln_lam_TCC1 0
  (deriv_ln_lam_TCC1-1 nil 3828010662
   ("" (skeep :preds? t)
    (("" (lemma "derivable_ln_lam") (("" (insteep) nil nil)) nil)) nil)
   ((derivable_ln_lam formula-decl nil ln_derivative_lam nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T_pred const-decl "[real -> boolean]" ln_derivative_lam nil)
    (T formal-subtype-decl nil ln_derivative_lam nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (pos_fun type-eq-decl nil ln_derivative_lam nil)
    (derivable? const-decl "bool" derivatives analysis))
   nil
   (deriv_ln_lam subtype
    "LAMBDA (t): ln_exp.ln(ln_derivative_lam.p(ln_derivative_lam.t))"
    "deriv_fun[T]")))
 (deriv_ln_lam 0
  (deriv_ln_lam-1 nil 3828010669
   ("" (skeep :preds? t)
    (("" (lemma "ln_derivable")
      (("" (flatten)
        (("" (lemma "chain_rule")
          (("" (inst -1 "p" "ln")
            (("" (replaces -3)
              (("" (beta)
                (("" (expand "*") (("" (propax) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ln_derivable formula-decl nil ln_exp nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T formal-subtype-decl nil ln_derivative_lam nil)
    (T_pred const-decl "[real -> boolean]" ln_derivative_lam nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (chain_rule formula-decl nil chain_rule analysis)
    (TRUE const-decl "bool" booleans nil)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (ln const-decl "real" ln_exp nil)
    (pos_fun type-eq-decl nil ln_derivative_lam nil)
    (derivable? const-decl "bool" derivatives analysis))
   shostak)))

