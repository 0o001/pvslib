(cert_cpr_latZone
 (x_0 0
  (x_0-1 nil 3685314647
   (""
    (then (skeep) (expand "x" :assert? none) (try-simp-ite)
     (then (lemma "Sdiv_aerr")
      (let ((new-label (freshname "l")))
        (then (label new-label -1)
         (branch
          (with-tccs
           (inst new-label
            "aebound_sub((59 * r_Y0), aebound_mul(59, 0, r_Y0, e_Y0), (60 * r_Y1), aebound_mul(60, 0, r_Y1, e_Y1))"
            "0" "((59 * r_Y0) - (60 * r_Y1))" "131072"
            "Fsub(Fmul(RtoS(59), Y0), Fmul(RtoS(60), Y1))"
            "RtoS(131072)"))
          ((branch (split -1)
            ((then (aerr-assert) (fail))
             (then (lemma "Ssub_aerr")
              (let ((new-label (freshname "l")))
                (then (label new-label -1)
                 (branch
                  (with-tccs
                   (inst new-label "aebound_mul(59, 0, r_Y0, e_Y0)"
                    "aebound_mul(60, 0, r_Y1, e_Y1)" "(59 * r_Y0)"
                    "(60 * r_Y1)" "Fmul(RtoS(59), Y0)"
                    "Fmul(RtoS(60), Y1)"))
                  ((branch (split -1)
                    ((then (aerr-assert) (fail))
                     (then (lemma "Smul_aerr")
                      (let ((new-label (freshname "l")))
                        (then (label new-label -1)
                         (branch
                          (with-tccs
                           (inst new-label "0" "e_Y0" "59" "r_Y0"
                            "RtoS(59)" "Y0"))
                          ((branch (split -1)
                            ((then (aerr-assert) (fail))
                             (eval-formulas +) (propax)
                             (assert-condition)))
                           (assert-condition))))))
                     (then (lemma "Smul_aerr")
                      (let ((new-label (freshname "l")))
                        (then (label new-label -1)
                         (branch
                          (with-tccs
                           (inst new-label "0" "e_Y1" "60" "r_Y1"
                            "RtoS(60)" "Y1"))
                          ((branch (split -1)
                            ((then (aerr-assert) (fail))
                             (eval-formulas +) (propax)
                             (assert-condition)))
                           (assert-condition))))))
                     (assert-condition)))
                   (assert-condition))))))
             (eval-formulas +) (assert-condition)))
           (assert-condition)))))))
    nil)
   ((real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (Sdiv_aerr formula-decl nil aerr754sp_div "float/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (int nonempty-type-eq-decl nil integers nil)
    (float type-eq-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (above nonempty-type-eq-decl nil integers nil)
    (Format type-eq-decl nil float "float/")
    (Fcanonic? const-decl "bool" float "float/")
    (single_precision_format const-decl "Format" ieee754sp "float/")
    (unb_single type-eq-decl nil ieee754sp "float/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (StoR const-decl "real" ieee754sp "float/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (div_pre2 const-decl "bool" cr_div "float/")
    (FtoR const-decl "real" float "float/")
    (/= const-decl "boolean" notequal nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (aebound_sub const-decl "nonneg_real" aerr754sp_sub "float/")
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (aebound_mul const-decl "nonneg_real" aerr754sp_mul "float/")
    (Fbounded? const-decl "bool" float "float/")
    (closest_single? const-decl "bool" ieee754sp "float/")
    (Fsub const-decl
     "{f: unb_single | closest_single?(FtoR(f1) - FtoR(f2))(f)}"
     ieee754sp_sub "float/")
    (Fmul const-decl
     "{f: unb_single | closest_single?(FtoR(f1) * FtoR(f2))(f)}"
     ieee754sp_mul "float/")
    (RtoS const-decl "{f: unb_single | closest_single?(x1)(f)}"
     ieee754sp "float/")
    (Ssub_aerr formula-decl nil aerr754sp_sub "float/")
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_plus_even_is_even application-judgement "even_int" integers
     nil)
    (Smul_aerr formula-decl nil aerr754sp_mul "float/")
    (x const-decl "unb_single" cpr_latZone nil))
   shostak))
 (j_0 0
  (j_0-1 nil 3685314647
   (""
    (then (skeep) (expand "j" :assert? none) (try-simp-ite)
     (then (lemma "Sfloor_aerr")
      (let ((new-label (freshname "l")))
        (then (label new-label -1)
         (branch
          (with-tccs
           (inst new-label
            "aebound_add((((59 * r_Y0) - (60 * r_Y1)) / 131072), aebound_div(((59 * r_Y0) - (60 * r_Y1)), aebound_sub((59 * r_Y0), aebound_mul(59, 0, r_Y0, e_Y0), (60 * r_Y1), aebound_mul(60, 0, r_Y1, e_Y1)), 131072, 0), 0.5, 0)"
            "((((59 * r_Y0) - (60 * r_Y1)) / 131072) + 0.5)"
            "Fadd(x(Y0, Y1), RtoS(0.5))"))
          ((branch (split -1)
            ((then (aerr-assert) (fail))
             (then (lemma "Sadd_aerr")
              (let ((new-label (freshname "l")))
                (then (label new-label -1)
                 (branch
                  (with-tccs
                   (inst new-label
                    "aebound_div(((59 * r_Y0) - (60 * r_Y1)), aebound_sub((59 * r_Y0), aebound_mul(59, 0, r_Y0, e_Y0), (60 * r_Y1), aebound_mul(60, 0, r_Y1, e_Y1)), 131072, 0)"
                    "0" "(((59 * r_Y0) - (60 * r_Y1)) / 131072)" "0.5"
                    "x(Y0, Y1)" "RtoS(0.5)"))
                  ((branch (split -1)
                    ((then (aerr-assert) (fail))
                     (then
                      (branch-lemmas ("x_0")
                       (then
                        (let ((new-label (freshname "l")))
                          (then (label new-label -1)
                           (branch
                            (with-tccs
                             (inst new-label "e_Y0" "e_Y1" "r_Y0"
                              "r_Y1" "Y0" "Y1"))
                            ((branch (split -1)
                              ((then (aerr-assert) (fail)) (propax)
                               (propax) (assert-condition)))
                             (assert-condition))))))))
                     (eval-formulas +) (assert-condition)))
                   (assert-condition))))))
             (assert-condition)))
           (assert-condition)))))))
    nil)
   ((real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (Sfloor_aerr formula-decl nil aerr754sp_flr "float/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_plus_even_is_even application-judgement "even_int" integers
     nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (RtoS const-decl "{f: unb_single | closest_single?(x1)(f)}"
     ieee754sp "float/")
    (x const-decl "unb_single" cpr_latZone nil)
    (Fadd const-decl
     "{f: unb_single | closest_single?(FtoR(f1) + FtoR(f2))(f)}"
     ieee754sp_add "float/")
    (FtoR const-decl "real" float "float/")
    (closest_single? const-decl "bool" ieee754sp "float/")
    (Fbounded? const-decl "bool" float "float/")
    (unb_single type-eq-decl nil ieee754sp "float/")
    (single_precision_format const-decl "Format" ieee754sp "float/")
    (Fcanonic? const-decl "bool" float "float/")
    (Format type-eq-decl nil float "float/")
    (above nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float "float/")
    (int nonempty-type-eq-decl nil integers nil)
    (aebound_mul const-decl "nonneg_real" aerr754sp_mul "float/")
    (aebound_sub const-decl "nonneg_real" aerr754sp_sub "float/")
    (aebound_div const-decl "nonneg_real" aerr754sp_div "float/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (aebound_add const-decl "nonneg_real" aerr754sp_add "float/")
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (Sadd_aerr formula-decl nil aerr754sp_add "float/")
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (x_0 formula-decl nil cert_cpr_latZone nil)
    (j const-decl "unb_single" cpr_latZone nil))
   shostak)))

