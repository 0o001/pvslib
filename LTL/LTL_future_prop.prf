(LTL_future_prop
 (until_equiv 0
  (until_equiv-1 nil 3857858904
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1)
          (("" (replace -2) (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (finally_equiv 0
  (finally_equiv-1 nil 3857858948
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (finally_bd_equiv 0
  (finally_bd_equiv-1 nil 3857859017
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (globally_equiv 0
  (globally_equiv-1 nil 3857859032
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (globally_bd_equiv 0
  (globally_bd_equiv-1 nil 3857859038
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (release_equiv 0
  (release_equiv-1 nil 3857859083
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1)
          (("" (replace -2) (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (next_equiv 0
  (next_equiv-1 nil 3857859051
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (previous_equiv 0
  (previous_equiv-1 nil 3857859054
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (zeta_equiv 0
  (zeta_equiv-1 nil 3857859057
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (historically_equiv 0
  (historically_equiv-1 nil 3857859064
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (historically_bd_equiv 0
  (historically_bd_equiv-1 nil 3857859068
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (once_equiv 0
  (once_equiv-1 nil 3857859072
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (once_bd_equiv 0
  (once_bd_equiv-1 nil 3857859076
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (triggered_equiv 0
  (triggered_equiv-1 nil 3857859212
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1)
          (("" (replace -2) (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (finally_until 0
  (finally_until-1 nil 3857860010
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (expand "CNST")
                (("" (expand "semantic_rel" 1 3)
                  (("" (expand "cnst") (("" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (atom? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (CNST const-decl "(atom?)" LTL_semantics nil)
    (TRUE const-decl "bool" booleans nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (cnst const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (globally_dual 0
  (globally_dual-1 nil 3857860024
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (expand "semantic_rel" 1 2)
          (("" (decompose-equality)
            (("" (decompose-equality)
              (("" (iff)
                (("" (split)
                  (("1" (flatten)
                    (("1" (skeep)
                      (("1" (insteep)
                        (("1" (assert)
                          (("1" (expand "semantic_rel")
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (skeep)
                      (("2" (insteep)
                        (("2" (assert)
                          (("2" (expand "semantic_rel" 1)
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (NOT_LTL adt-constructor-decl "[LTL -> (not?)]" LTL_adt nil)
    (not? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (globally_bd_dual 0
  (globally_bd_dual-1 nil 3857860038
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (expand "semantic_rel" 1 2)
                (("" (split)
                  (("1" (flatten)
                    (("1" (skeep)
                      (("1" (insteep)
                        (("1" (assert)
                          (("1" (expand "semantic_rel" -3)
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (skeep)
                      (("2" (insteep)
                        (("2" (assert)
                          (("2" (expand "semantic_rel" 1)
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (LowerBound type-decl nil IntervalsNatural nil)
    (UpperBound type-decl nil IntervalsNatural nil)
    (IntNat type-eq-decl nil IntervalsNatural nil)
    (|##| const-decl "bool" IntervalsNatural nil)
    (shiftIntNat const-decl "IntNat" IntervalsNatural nil)
    (propIntNatLB? const-decl "bool" IntervalsNatural nil)
    (LTL type-decl nil LTL_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finally_bd? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (FINALLY_BD adt-constructor-decl
     "[[LTL, (propIntNatLB?)] -> (finally_bd?)]" LTL_adt nil)
    (not? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (NOT_LTL adt-constructor-decl "[LTL -> (not?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (finally_dual 0
  (finally_dual-1 nil 3858098886
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "semantic_rel" -2)
                    (("1" (skeep)
                      (("1" (insteep)
                        (("1" (assert)
                          (("1" (expand "semantic_rel" -3)
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel" 1)
                    (("2" (skeep)
                      (("2" (insteep)
                        (("2" (expand "semantic_rel" 1)
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (globally? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (GLOBALLY adt-constructor-decl "[LTL -> (globally?)]" LTL_adt nil)
    (not? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (NOT_LTL adt-constructor-decl "[LTL -> (not?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (finally_bd_dual 0
  (finally_bd_dual-1 nil 3858098961
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "semantic_rel" -2)
                    (("1" (skeep)
                      (("1" (insteep)
                        (("1" (assert)
                          (("1" (expand "semantic_rel" -3)
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel" 1)
                    (("2" (skeep)
                      (("2" (insteep)
                        (("2" (expand "semantic_rel" 1)
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LowerBound type-decl nil IntervalsNatural nil)
    (UpperBound type-decl nil IntervalsNatural nil)
    (IntNat type-eq-decl nil IntervalsNatural nil)
    (|##| const-decl "bool" IntervalsNatural nil)
    (shiftIntNat const-decl "IntNat" IntervalsNatural nil)
    (propIntNatLB? const-decl "bool" IntervalsNatural nil)
    (LTL type-decl nil LTL_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (globally_bd? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (GLOBALLY_BD adt-constructor-decl
     "[[LTL, (propIntNatLB?)] -> (globally_bd?)]" LTL_adt nil)
    (not? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (NOT_LTL adt-constructor-decl "[LTL -> (not?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (release_dual 0
  (release_dual-1 nil 3858083245
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "semantic_rel" -2)
                    (("1" (split)
                      (("1" (skeep)
                        (("1" (skeep)
                          (("1" (expand "semantic_rel" -5)
                            (("1" (inst -3 "t_0!1")
                              (("1" (assert) nil nil)
                               ("2"
                                (inst -4 "t_0")
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand "semantic_rel" -4)
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (skeep)
                        (("2" (expand "semantic_rel" -3)
                          (("2" (inst -1 "t_0")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel" 1)
                    (("2"
                      (inst 2
                       "min(LAMBDA(i: nat)-> bool : i >=x!2 AND semantic_rel(f1)(x!1)(i))")
                      (("1" (assert)
                        (("1" (split)
                          (("1" (assert) nil nil)
                           ("2" (skeep)
                            (("2" (inst 2 "t_1")
                              (("2"
                                (expand "semantic_rel" 2 1)
                                (("2"
                                  (assert)
                                  (("2"
                                    (typepred "t_1")
                                    (("2"
                                      (skeep 2)
                                      (("2"
                                        (typepred "t_2")
                                        (("2"
                                          (expand "semantic_rel" 2)
                                          (("2"
                                            (hide +)
                                            (("2"
                                              (typepred
                                               "  min(LAMBDA (i: nat) -> bool: i >= x!2 AND semantic_rel(f1)(x!1)(i))")
                                              (("1"
                                                (inst -3 "t_2")
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil)
                                               ("2"
                                                (expand "nonempty?")
                                                (("2"
                                                  (expand "empty?")
                                                  (("2"
                                                    (inst -1 "t_2")
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (expand
                                                         "member")
                                                        (("2"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (skeep)
                        (("2" (inst 2 "t_1")
                          (("2" (assert)
                            (("2" (expand "semantic_rel" 2 1)
                              (("2"
                                (skeep)
                                (("2"
                                  (expand "semantic_rel" 2)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (expand "nonempty?")
                                      (("2"
                                        (expand "empty?")
                                        (("2"
                                          (inst -1 "t_2")
                                          (("2"
                                            (expand "member")
                                            (("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil) (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (until? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (UNTIL adt-constructor-decl "[[LTL, LTL] -> (until?)]" LTL_adt nil)
    (not? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (NOT_LTL adt-constructor-decl "[LTL -> (not?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil) nil nil nil
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
         min_nat nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil nil
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (strong_release_dual 0
  (strong_release_dual-1 nil 3858093696
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "semantic_rel" -2)
                    (("1" (skeep)
                      (("1" (split)
                        (("1" (skeep)
                          (("1" (inst -3 "t_0")
                            (("1" (assert)
                              (("1"
                                (expand "semantic_rel" -3)
                                (("1" (propax) nil nil))
                                nil))
                              nil)
                             ("2" (inst -5 "t_0!1")
                              (("1"
                                (assert)
                                (("1"
                                  (expand "semantic_rel" -2)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (inst -1 "t_0")
                          (("2" (assert)
                            (("2" (expand "semantic_rel" -1)
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel" 1)
                    (("2" (flatten)
                      (("2" (skeep)
                        (("2" (expand "semantic_rel" 2)
                          (("2"
                            (inst 2
                             "min(LAMBDA(i: nat)-> bool : i >=x!2 AND semantic_rel(f1)(x!1)(i))")
                            (("1" (assert)
                              (("1"
                                (split)
                                (("1" (assert) nil nil)
                                 ("2"
                                  (skeep)
                                  (("2"
                                    (typepred "t_1!1")
                                    (("2"
                                      (inst 2 "t_1!1")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (expand "semantic_rel" 2 1)
                                          (("2"
                                            (skeep)
                                            (("2"
                                              (expand "semantic_rel" 2)
                                              (("2"
                                                (typepred "t_1!2")
                                                (("2"
                                                  (typepred
                                                   " min(LAMBDA (i: nat) -> bool: i >= x!2 AND semantic_rel(f1)(x!1)(i))")
                                                  (("1"
                                                    (inst -3 "t_1!2")
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (expand
                                                     "nonempty?")
                                                    (("2"
                                                      (expand "empty?")
                                                      (("2"
                                                        (inst -1 "t_1")
                                                        (("2"
                                                          (expand
                                                           "member")
                                                          (("2"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "nonempty?")
                              (("2"
                                (expand "empty?")
                                (("2"
                                  (inst -1 "t_1")
                                  (("2"
                                    (expand "member")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil) (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (weak_until? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (WEAK_UNTIL adt-constructor-decl "[[LTL, LTL] -> (weak_until?)]"
     LTL_adt nil)
    (not? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (NOT_LTL adt-constructor-decl "[LTL -> (not?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
         min_nat nil)
    nil nil nil (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil) nil nil
    (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (until_dual 0
  (until_dual-1 nil 3858200361
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "semantic_rel" -2)
                    (("1" (split)
                      (("1" (skeep)
                        (("1" (skeep)
                          (("1" (expand "semantic_rel" -2)
                            (("1" (inst -5 "t_0")
                              (("1" (assert) nil nil)
                               ("2"
                                (inst -2 "t_0!1")
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand "semantic_rel" -2)
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (skeep)
                        (("2" (inst -1 "t_0")
                          (("2" (assert)
                            (("2" (expand "semantic_rel" -1)
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel" 1)
                    (("2" (flatten)
                      (("2" (skeep)
                        (("2"
                          (inst 3
                           "min(LAMBDA(i:nat) -> bool : i>=x!2 AND semantic_rel(f2)(x!1)(i))")
                          (("1" (assert)
                            (("1" (split)
                              (("1" (assert) nil nil)
                               ("2"
                                (assert)
                                (("2"
                                  (expand "semantic_rel" 3)
                                  (("2"
                                    (skeep)
                                    (("2"
                                      (typepred "t_1!1")
                                      (("2"
                                        (inst 2 "t_1!1")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (expand "semantic_rel" 2 1)
                                            (("2"
                                              (skeep)
                                              (("2"
                                                (expand
                                                 "semantic_rel"
                                                 2)
                                                (("2"
                                                  (typepred "t_1!2")
                                                  (("2"
                                                    (typepred
                                                     "min(LAMBDA (i: nat) -> bool: i >= x!2 AND semantic_rel(f2)(x!1)(i))")
                                                    (("1"
                                                      (inst -3 "t_1!2")
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (expand
                                                       "nonempty?")
                                                      (("2"
                                                        (expand
                                                         "empty?")
                                                        (("2"
                                                          (inst
                                                           -1
                                                           "t_1")
                                                          (("2"
                                                            (expand
                                                             "member")
                                                            (("2"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "nonempty?")
                            (("2" (expand "empty?")
                              (("2"
                                (expand "semantic_rel" 2)
                                (("2"
                                  (inst -1 "t_1")
                                  (("2"
                                    (expand "member")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (release? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (RELEASE adt-constructor-decl "[[LTL, LTL] -> (release?)]" LTL_adt
     nil)
    (not? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (NOT_LTL adt-constructor-decl "[LTL -> (not?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil) nil nil nil
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
         min_nat nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (weak_until_dual 0
  (weak_until_dual-1 nil 3858200726
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "semantic_rel" -2)
                    (("1" (split)
                      (("1" (skeep)
                        (("1" (skeep)
                          (("1" (expand "semantic_rel" -5)
                            (("1" (inst -3 "t_0!1")
                              (("1" (assert) nil nil)
                               ("2"
                                (inst -4 "t_0")
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand "semantic_rel" -4)
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (skeep)
                        (("2" (expand "semantic_rel" -3)
                          (("2" (inst -1 "t_0")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel" 1)
                    (("2" (skeep)
                      (("2"
                        (inst 2
                         "min(LAMBDA(i: nat)-> bool : i >=x!2 AND semantic_rel(f2)(x!1)(i))")
                        (("1" (assert)
                          (("1" (assert)
                            (("1" (skeep)
                              (("1"
                                (typepred "t_1!1")
                                (("1"
                                  (inst 1 "t_1!1")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand "semantic_rel" 1 1)
                                      (("1"
                                        (skeep)
                                        (("1"
                                          (expand "semantic_rel" 1)
                                          (("1"
                                            (typepred "t_1!2")
                                            (("1"
                                              (typepred
                                               " min(LAMBDA (i: nat) -> bool: i >= x!2 AND semantic_rel(f2)(x!1)(i))")
                                              (("1"
                                                (inst -3 "t_1!2")
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil)
                                               ("2"
                                                (expand "nonempty?")
                                                (("2"
                                                  (expand "empty?")
                                                  (("2"
                                                    (inst -1 "t_1!2")
                                                    (("2"
                                                      (expand "member")
                                                      (("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "nonempty?")
                          (("2" (expand "empty?")
                            (("2" (inst 1 "t_1")
                              (("2"
                                (assert)
                                (("2"
                                  (expand "semantic_rel" 1 1)
                                  (("2"
                                    (skeep)
                                    (("2"
                                      (expand "semantic_rel" 1)
                                      (("2"
                                        (inst -1 "t_2")
                                        (("2"
                                          (expand "member")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (strong_release? adt-recognizer-decl "[LTL -> boolean]" LTL_adt
     nil)
    (STRONG_RELEASE adt-constructor-decl
     "[[LTL, LTL] -> (strong_release?)]" LTL_adt nil)
    (not? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (NOT_LTL adt-constructor-decl "[LTL -> (not?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
         min_nat nil)
    nil nil nil (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (finally_idempotent 0
  (finally_idempotent-1 nil 3857860174
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (expand "semantic_rel" 1 2)
              (("" (iff)
                (("" (split)
                  (("1" (flatten)
                    (("1" (skeep)
                      (("1" (insteep)
                        (("1" (assert)
                          (("1" (inst 1 "t_0") (("1" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (skeep)
                      (("2" (skeep)
                        (("2" (inst 1 "t_1") (("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil)
    (finally? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (FINALLY adt-constructor-decl "[LTL -> (finally?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (globally_idempotent 0
  (globally_idempotent-1 nil 3857860190
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (skeep)
                    (("1" (expand "semantic_rel" 1)
                      (("1" (skeep)
                        (("1" (inst -1 "t_1") (("1" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (skeep)
                    (("2" (expand "semantic_rel" -1)
                      (("2" (insteep)
                        (("2" (assert)
                          (("2" (inst -1 "t_0")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil)
    (globally? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (GLOBALLY adt-constructor-decl "[LTL -> (globally?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (historically_idempotent 0
  (historically_idempotent-1 nil 3857859920
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (expand "semantic_rel" 1 2)
          (("" (decompose-equality)
            (("" (decompose-equality)
              (("" (iff)
                (("" (split)
                  (("1" (flatten)
                    (("1" (skeep)
                      (("1" (skeep)
                        (("1" (inst -1 "t_1") (("1" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (skeep)
                      (("2" (insteep)
                        (("2" (assert)
                          (("2" (inst -1 "t_0")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (LTL type-decl nil LTL_adt nil) (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (until_idempotent 0
  (until_idempotent-1 nil 3857859889
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (skeep)
                    (("1" (insteep)
                      (("1" (assert)
                        (("1" (split)
                          (("1" (expand "semantic_rel" 1)
                            (("1" (inst 1 "t_0")
                              (("1" (assert) nil nil)) nil))
                            nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (skeep)
                    (("2" (expand "semantic_rel" -2)
                      (("2" (skeep)
                        (("2" (inst 1 "t_2")
                          (("2" (assert)
                            (("2" (skeep)
                              (("2"
                                (typepred "t_1")
                                (("2"
                                  (inst -5 "t_1")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (inst -5 "t_1")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (until? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (UNTIL adt-constructor-decl "[[LTL, LTL] -> (until?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (until_weak_until 0
  (until_weak_until-1 nil 3857859866
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "semantic_rel" 1)
                    (("1" (split)
                      (("1" (skeep)
                        (("1" (insteep) (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (flatten) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel" -)
                    (("2" (split)
                      (("1" (propax) nil nil)
                       ("2" (skeep)
                        (("2" (inst 1 "t_0")
                          (("2" (assert)
                            (("2" (skeep)
                              (("2"
                                (inst -1 "t_1")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (finally? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (FINALLY adt-constructor-decl "[LTL -> (finally?)]" LTL_adt nil)
    (weak_until? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (WEAK_UNTIL adt-constructor-decl "[[LTL, LTL] -> (weak_until?)]"
     LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (release_weak_until 0
  (release_weak_until-1 nil 3858090982
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (split)
                    (("1" (skeep)
                      (("1" (skeep)
                        (("1" (case "t_0=x!2")
                          (("1" (replace -1)
                            (("1" (inst -4 "x!2")
                              (("1"
                                (assert)
                                (("1"
                                  (inst 1 "x!2")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand "semantic_rel" 1)
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (inst 2 "t_0-1")
                                (("1" (assert) nil nil)
                                 ("2"
                                  (reveal -1)
                                  (("2"
                                    (inst -1 "t_1")
                                    (("1" (assert) nil nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (inst 2 "t_0")
                            (("2" (assert)
                              (("2"
                                (expand "semantic_rel" 2 1)
                                (("2"
                                  (inst -3 "t_0")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (reveal -1)
                                      (("2"
                                        (skeep)
                                        (("2"
                                          (inst -1 "t_1!1")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split)
                    (("1" (skeep -1)
                      (("1" (expand "semantic_rel" -2)
                        (("1" (case "t_0=x!2")
                          (("1" (replace -1)
                            (("1" (assert)
                              (("1"
                                (flatten)
                                (("1"
                                  (inst 1 "x!2")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (skeep)
                                      (("1"
                                        (inst -5 "t_1")
                                        (("1" (assert) nil nil)
                                         ("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (inst 2 "t_0")
                              (("2"
                                (assert)
                                (("2"
                                  (skeep 2)
                                  (("2"
                                    (inst -4 "t_1")
                                    (("1" (assert) nil nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil) (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (and? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (AND_LTL adt-constructor-decl "[[LTL, LTL] -> (and?)]" LTL_adt nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil) nil nil
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil (= const-decl "[T, T -> boolean]" equalities nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil nil
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (strong_release_until 0
  (strong_release_until-1 nil 3858244609
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (skeep)
                    (("1" (expand "semantic_rel" 1 1)
                      (("1" (inst -3 "t_0")
                        (("1" (assert)
                          (("1" (insteep)
                            (("1" (assert)
                              (("1"
                                (reveal -1)
                                (("1"
                                  (skeep)
                                  (("1"
                                    (insteep)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (skeep)
                    (("2" (expand "semantic_rel" -2)
                      (("2" (flatten)
                        (("2" (insteep)
                          (("2" (assert)
                            (("2" (skeep)
                              (("2"
                                (insteep)
                                (("1" (assert) nil nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil) (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (and? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (AND_LTL adt-constructor-decl "[[LTL, LTL] -> (and?)]" LTL_adt nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (globally_release 0
  (globally_release-1 nil 3858085979
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten) nil nil)
                 ("2" (flatten)
                  (("2" (split)
                    (("1" (skeep -1)
                      (("1" (expand "CNST")
                        (("1" (expand "semantic_rel" -2)
                          (("1" (expand "cnst")
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (atom? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (CNST const-decl "(atom?)" LTL_semantics nil)
    (FALSE const-decl "bool" booleans nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (cnst const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (weak_until_until 0
  (weak_until_until-1 nil 3858099023
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (split)
                    (("1" (skeep)
                      (("1" (insteep)
                        (("1" (assert)
                          (("1" (expand "semantic_rel" 1 1)
                            (("1" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (inst 1 "x!2")
                      (("2" (assert)
                        (("2" (expand "semantic_rel" 1 1)
                          (("2" (flatten)
                            (("2" (expand "semantic_rel" 2)
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (skeep -1)
                    (("2" (insteep)
                      (("2" (assert)
                        (("2" (expand "semantic_rel" -2)
                          (("2" (split -2)
                            (("1" (split 1)
                              (("1" (propax) nil nil)
                               ("2" (propax) nil nil))
                              nil)
                             ("2" (skeep)
                              (("2"
                                (insteep)
                                (("1" (assert) nil nil)
                                 ("2"
                                  (expand "semantic_rel" -1)
                                  (("2"
                                    (inst -1 "t_1")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (or? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (OR_LTL adt-constructor-decl "[[LTL, LTL] -> (or?)]" LTL_adt nil)
    (globally? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (GLOBALLY adt-constructor-decl "[LTL -> (globally?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (t_0 skolem-const-decl "nat" LTL_future_prop nil)
    (t_1 skolem-const-decl "nat" LTL_future_prop nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (weak_until_until_globally 0
  (weak_until_until_globally-1 nil 3858099381
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (expand "semantic_rel" 1 4)
                (("" (expand "semantic_rel" 1 6)
                  (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (until? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (UNTIL adt-constructor-decl "[[LTL, LTL] -> (until?)]" LTL_adt nil)
    (globally? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (GLOBALLY adt-constructor-decl "[LTL -> (globally?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (release_strong_release_globally 0
  (release_strong_release_globally-1 nil 3858288438
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (expand "semantic_rel" 1 4)
          (("" (expand "semantic_rel" 1 6) (("" (propax) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (weak_until_expansion 0
  (weak_until_expansion-1 nil 3858340267
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (split)
                    (("1" (skeep)
                      (("1" (case "t_0=x!2")
                        (("1" (replace -1) (("1" (propax) nil nil))
                          nil)
                         ("2" (expand "semantic_rel" 3)
                          (("2" (inst -3 "x!2")
                            (("1" (assert)
                              (("1"
                                (reveal -1)
                                (("1"
                                  (expand "semantic_rel" 3)
                                  (("1"
                                    (expand "semantic_rel" 3)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (skeep)
                                        (("1"
                                          (inst 3 "t_0")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (skeep)
                                              (("1"
                                                (inst -1 "t_1!1")
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "semantic_rel" 2)
                      (("2" (inst -1 "x!2")
                        (("2" (assert)
                          (("2" (expand "semantic_rel" 2)
                            (("2" (expand "semantic_rel" 2)
                              (("2"
                                (reveal -1)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (skeep 3)
                                    (("2"
                                      (insteep -1)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split)
                    (("1" (inst 1 "x!2") (("1" (assert) nil nil)) nil)
                     ("2" (expand "semantic_rel" -1)
                      (("2" (flatten)
                        (("2" (expand "semantic_rel" -2)
                          (("2" (expand "semantic_rel" -2)
                            (("2" (split)
                              (("1"
                                (skeep -1)
                                (("1"
                                  (insteep)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (skeep 1)
                                      (("1"
                                        (insteep)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (skeep)
                                (("2"
                                  (inst -1 "t_1")
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (and? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (AND_LTL adt-constructor-decl "[[LTL, LTL] -> (and?)]" LTL_adt nil)
    (next? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (NEXT adt-constructor-decl "[LTL -> (next?)]" LTL_adt nil)
    (weak_until? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (WEAK_UNTIL adt-constructor-decl "[[LTL, LTL] -> (weak_until?)]"
     LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (x!2 skolem-const-decl "nat" LTL_future_prop nil)
    (t_0 skolem-const-decl "nat" LTL_future_prop nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (weak_until_release 0
  (weak_until_release-1 nil 3858093273
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (split)
                    (("1" (skeep -1)
                      (("1" (inst 1 "t_0")
                        (("1" (assert)
                          (("1" (skeep)
                            (("1" (expand "semantic_rel" 1)
                              (("1"
                                (flatten)
                                (("1"
                                  (inst -3 "t_1")
                                  (("1" (assert) nil nil)
                                   ("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skeep)
                      (("2" (inst -1 "t_1")
                        (("2" (expand "semantic_rel" 2)
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split)
                    (("1" (postpone) nil nil)
                     ("2" (skeep)
                      (("2"
                        (inst -1
                         "min((LAMBDA(i:nat) -> bool: i >= x!2 AND semantic_rel(f2)(x!1)(i)))")
                        (("1" (assert)
                          (("1" (split)
                            (("1" (postpone) nil nil)
                             ("2" (postpone) nil nil))
                            nil))
                          nil)
                         ("2" (postpone) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil) (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (or? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (OR_LTL adt-constructor-decl "[[LTL, LTL] -> (or?)]" LTL_adt nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (next_negation 0
  (next_negation-1 nil 3857860111
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (expand "semantic_rel") (("" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil)
    (next? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (NEXT adt-constructor-decl "[LTL -> (next?)]" LTL_adt nil)
    (not? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (NOT_LTL adt-constructor-decl "[LTL -> (not?)]" LTL_adt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (until_next 0
  (until_next-1 nil 3857859786
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (skeep)
                    (("1" (expand "semantic_rel" 2)
                      (("1" (split)
                        (("1" (inst -3 "x!2")
                          (("1" (assert) nil nil)
                           ("2" (case "t_0=x!2")
                            (("1" (assert) nil nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (expand "semantic_rel" 1)
                          (("2" (expand "semantic_rel" 1)
                            (("2" (insteep)
                              (("2"
                                (assert)
                                (("2"
                                  (skeep)
                                  (("2"
                                    (insteep)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel" -1 2)
                    (("2" (expand "semantic_rel" -1 3)
                      (("2" (expand "semantic_rel" -1 3)
                        (("2" (split)
                          (("1" (inst 1 "x!2") (("1" (assert) nil nil))
                            nil)
                           ("2" (flatten)
                            (("2" (skeep)
                              (("2"
                                (insteep)
                                (("2"
                                  (assert)
                                  (("2"
                                    (skeep)
                                    (("2"
                                      (insteep)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (and? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (AND_LTL adt-constructor-decl "[[LTL, LTL] -> (and?)]" LTL_adt nil)
    (next? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (NEXT adt-constructor-decl "[LTL -> (next?)]" LTL_adt nil)
    (until? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (UNTIL adt-constructor-decl "[[LTL, LTL] -> (until?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (release_next 0
  (release_next-1 nil 3858201303
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (split)
                    (("1" (split)
                      (("1" (skeep)
                        (("1" (inst -3 "x!2")
                          (("1" (assert) nil nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil)
                       ("2" (expand "semantic_rel" 1)
                        (("2" (flatten)
                          (("2" (expand "semantic_rel" 2)
                            (("2" (expand "semantic_rel" 2)
                              (("2"
                                (flatten)
                                (("2"
                                  (skeep -1)
                                  (("2"
                                    (case "t_0=x!2")
                                    (("1"
                                      (replace -1)
                                      (("1" (propax) nil nil))
                                      nil)
                                     ("2"
                                      (inst 3 "t_0")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (skeep)
                                          (("2"
                                            (inst -4 "t_1")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (split)
                      (("1" (inst -1 "x!2") (("1" (assert) nil nil))
                        nil)
                       ("2" (expand "semantic_rel" 1)
                        (("2" (flatten)
                          (("2" (expand "semantic_rel" 2)
                            (("2" (expand "semantic_rel" 2)
                              (("2"
                                (flatten)
                                (("2"
                                  (skeep)
                                  (("2"
                                    (inst -2 "t_1")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel" -2)
                    (("2" (split)
                      (("1" (inst 1 "x!2")
                        (("1" (assert)
                          (("1" (skeep) (("1" (assert) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (expand "semantic_rel" -1)
                        (("2" (expand "semantic_rel" -1)
                          (("2" (split)
                            (("1" (skeep -1)
                              (("1"
                                (inst 1 "t_0")
                                (("1"
                                  (assert)
                                  (("1"
                                    (skeep)
                                    (("1"
                                      (inst -3 "t_1")
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (skeep)
                              (("2"
                                (case "t_1=x!2")
                                (("1"
                                  (replace -1)
                                  (("1" (propax) nil nil))
                                  nil)
                                 ("2"
                                  (inst -1 "t_1")
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil) (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (or? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (OR_LTL adt-constructor-decl "[[LTL, LTL] -> (or?)]" LTL_adt nil)
    (next? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (NEXT adt-constructor-decl "[LTL -> (next?)]" LTL_adt nil)
    (release? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (RELEASE adt-constructor-decl "[[LTL, LTL] -> (release?)]" LTL_adt
     nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (x!2 skolem-const-decl "nat" LTL_future_prop nil)
    (t_0 skolem-const-decl "nat" LTL_future_prop nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (globally_next 0
  (globally_next-1 nil 3857859671
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (split)
                    (("1" (inst -1 "x!2") (("1" (assert) nil nil)) nil)
                     ("2" (expand "semantic_rel" 1)
                      (("2" (expand "semantic_rel" 1)
                        (("2" (skeep)
                          (("2" (insteep) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel" -2)
                    (("2" (expand "semantic_rel" -2)
                      (("2" (skeep)
                        (("2" (insteep) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (next? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (NEXT adt-constructor-decl "[LTL -> (next?)]" LTL_adt nil)
    (globally? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (GLOBALLY adt-constructor-decl "[LTL -> (globally?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (finally_next 0
  (finally_next-1 nil 3857859650
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (skeep)
                    (("1" (expand "semantic_rel" 2)
                      (("1" (expand "semantic_rel" 2)
                        (("1" (case "t_0=x!2")
                          (("1" (replace -1) (("1" (propax) nil nil))
                            nil)
                           ("2" (insteep) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split)
                    (("1" (inst 1 "x!2") (("1" (assert) nil nil)) nil)
                     ("2" (expand "semantic_rel" -)
                      (("2" (expand "semantic_rel" -)
                        (("2" (skeep)
                          (("2" (insteep) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (next? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (NEXT adt-constructor-decl "[LTL -> (next?)]" LTL_adt nil)
    (finally? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (FINALLY adt-constructor-decl "[LTL -> (finally?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (next_or_distributive 0
  (next_or_distributive-1 nil 3857859612
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (expand "semantic_rel") (("" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (next_and_distributive 0
  (next_and_distributive-1 nil 3857859582
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (expand "semantic_rel") (("" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (next_until_distributive 0
  (next_until_distributive-1 nil 3857859474
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "semantic_rel")
                    (("1" (skeep)
                      (("1" (inst 1 "t_0 - 1")
                        (("1" (assert)
                          (("1" (skeep)
                            (("1" (inst -3 "t_1 + 1")
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (typepred "x!2") (("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel")
                    (("2" (skeep)
                      (("2" (inst 1 "1 + t_0")
                        (("2" (assert)
                          (("2" (skeep)
                            (("2" (inst -3 "t_1 -1")
                              (("1" (assert) nil nil)
                               ("2"
                                (typepred "x!2")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (LTL type-decl nil LTL_adt nil)
    (until? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (UNTIL adt-constructor-decl "[[LTL, LTL] -> (until?)]" LTL_adt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (next? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (NEXT adt-constructor-decl "[LTL -> (next?)]" LTL_adt nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil) nil nil
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (finally_or_distributive 0
  (finally_or_distributive-1 nil 3857859445
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (expand "semantic_rel")
          (("" (decompose-equality)
            (("" (decompose-equality)
              (("" (iff)
                (("" (split)
                  (("1" (flatten)
                    (("1" (skeep)
                      (("1" (insteep)
                        (("1" (insteep)
                          (("1" (split)
                            (("1" (assert) nil nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split)
                      (("1" (skeep)
                        (("1" (insteep) (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (skeep)
                        (("2" (insteep) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (LTL type-decl nil LTL_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (finally_bd_or_distributive 0
  (finally_bd_or_distributive-1 nil 3857859418
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "semantic_rel")
                    (("1" (skeep)
                      (("1" (insteep)
                        (("1" (insteep)
                          (("1" (assert)
                            (("1" (split)
                              (("1" (propax) nil nil)
                               ("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel")
                    (("2" (split)
                      (("1" (skeep)
                        (("1" (insteep) (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (skeep)
                        (("2" (insteep) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LowerBound type-decl nil IntervalsNatural nil)
    (UpperBound type-decl nil IntervalsNatural nil)
    (IntNat type-eq-decl nil IntervalsNatural nil)
    (|##| const-decl "bool" IntervalsNatural nil)
    (shiftIntNat const-decl "IntNat" IntervalsNatural nil)
    (propIntNatLB? const-decl "bool" IntervalsNatural nil)
    (LTL type-decl nil LTL_adt nil)
    (or? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (OR_LTL adt-constructor-decl "[[LTL, LTL] -> (or?)]" LTL_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (finally_bd? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (FINALLY_BD adt-constructor-decl
     "[[LTL, (propIntNatLB?)] -> (finally_bd?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (globally_and_distributive 0
  (globally_and_distributive-1 nil 3857859379
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "semantic_rel")
                    (("1" (split)
                      (("1" (skeep)
                        (("1" (insteep) (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (skeep)
                        (("2" (insteep) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel")
                    (("2" (skeep)
                      (("2" (insteep)
                        (("2" (insteep) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil)
    (and? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (AND_LTL adt-constructor-decl "[[LTL, LTL] -> (and?)]" LTL_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (globally? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (GLOBALLY adt-constructor-decl "[LTL -> (globally?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (globally_bd_and_distributive 0
  (globally_bd_and_distributive-1 nil 3857859336
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "semantic_rel")
                    (("1" (split)
                      (("1" (skeep)
                        (("1" (insteep) (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (skeep)
                        (("2" (insteep) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel")
                    (("2" (skeep)
                      (("2" (insteep)
                        (("2" (insteep) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (LowerBound type-decl nil IntervalsNatural nil)
    (UpperBound type-decl nil IntervalsNatural nil)
    (IntNat type-eq-decl nil IntervalsNatural nil)
    (|##| const-decl "bool" IntervalsNatural nil)
    (shiftIntNat const-decl "IntNat" IntervalsNatural nil)
    (propIntNatLB? const-decl "bool" IntervalsNatural nil)
    (LTL type-decl nil LTL_adt nil)
    (and? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (AND_LTL adt-constructor-decl "[[LTL, LTL] -> (and?)]" LTL_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (globally_bd? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (GLOBALLY_BD adt-constructor-decl
     "[[LTL, (propIntNatLB?)] -> (globally_bd?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (until_or_distributive 0
  (until_or_distributive-1 nil 3857859306
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "semantic_rel" +)
                    (("1" (skeep)
                      (("1" (insteep)
                        (("1" (insteep)
                          (("1" (assert)
                            (("1" (split)
                              (("1"
                                (assert)
                                (("1"
                                  (expand "semantic_rel" -2)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil)
                               ("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel" -1)
                    (("2" (split)
                      (("1" (skeep)
                        (("1" (insteep)
                          (("1" (assert)
                            (("1" (assert)
                              (("1"
                                (expand "semantic_rel" 1 1)
                                (("1" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (skeep)
                        (("2" (insteep)
                          (("2" (assert)
                            (("2" (expand "semantic_rel" 1 1)
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil)
    (or? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (OR_LTL adt-constructor-decl "[[LTL, LTL] -> (or?)]" LTL_adt nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (until? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (UNTIL adt-constructor-decl "[[LTL, LTL] -> (until?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (until_and_distributive 0
  (until_and_distributive-1 nil 3857859244
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "semantic_rel" +)
                    (("1" (expand "semantic_rel" -1 2)
                      (("1" (split)
                        (("1" (skeep)
                          (("1" (insteep)
                            (("1" (assert)
                              (("1"
                                (skeep)
                                (("1"
                                  (insteep)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skeep)
                          (("2" (insteep)
                            (("2" (assert)
                              (("2"
                                (skeep)
                                (("2"
                                  (insteep)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel" -)
                    (("2" (expand "semantic_rel" 1 2)
                      (("2" (skeep)
                        (("2" (skeep)
                          (("2" (case "t_0<=t_0!1")
                            (("1" (assert)
                              (("1"
                                (inst 1 "t_0")
                                (("1"
                                  (assert)
                                  (("1"
                                    (skeep)
                                    (("1"
                                      (insteep)
                                      (("1"
                                        (insteep)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (inst 2 "t_0!1")
                              (("2"
                                (assert)
                                (("2"
                                  (skeep)
                                  (("2"
                                    (insteep)
                                    (("2"
                                      (insteep)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (and? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (AND_LTL adt-constructor-decl "[[LTL, LTL] -> (and?)]" LTL_adt nil)
    (until? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (UNTIL adt-constructor-decl "[[LTL, LTL] -> (until?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_future_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak)))

