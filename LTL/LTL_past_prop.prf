(LTL_past_prop
 (previous_equiv 0
  (previous_equiv-1 nil 3857856633
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (zeta_equiv 0
  (zeta_equiv-1 nil 3857856649
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" +)
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("1" (decompose-equality)
              (("1" (iff)
                (("1" (split)
                  (("1" (flatten)
                    (("1" (split)
                      (("1" (assert) nil nil)
                       ("2" (flatten)
                        (("2" (assert)
                          (("2" (inst -2 "x!1")
                            (("2" (replace -2) (("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split)
                      (("1" (assert) nil nil)
                       ("2" (flatten)
                        (("2" (assert)
                          (("2" (inst -2 "x!1")
                            (("2" (replace -2) (("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skeep) (("2" (assert) nil nil)) nil))
              nil)
             ("2" (skeep) (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (LTL type-decl nil LTL_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (historically_equiv 0
  (historically_equiv-1 nil 3857856921
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (historically_bd_equiv 0
  (historically_bd_equiv-1 nil 3857856982
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (once_equiv 0
  (once_equiv-1 nil 3857857066
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (once_bd_equiv 0
  (once_bd_equiv-1 nil 3857857012
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (since_equiv 0
  (since_equiv-1 nil 3857857106
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1)
          (("" (replace -2) (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (triggered_equiv 0
  (triggered_equiv-1 nil 3857857132
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel" 1)
        (("" (replace -1)
          (("" (replace -2) (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (once_since 0
  (once_since-1 nil 3857858732
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (skeep)
                    (("1" (inst?)
                      (("1" (split)
                        (("1" (typepred "t_0") (("1" (propax) nil nil))
                          nil)
                         ("2" (propax) nil nil)
                         ("3" (skeep)
                          (("3" (expand "CNST")
                            (("3" (expand "semantic_rel" 1)
                              (("3"
                                (expand "cnst")
                                (("3" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (skeep)
                    (("2" (inst?) (("2" (inst 1 "t_0") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (cnst const-decl "bool" LTL_semantics nil)
    (x!2 skolem-const-decl "nat" LTL_past_prop nil)
    (t_0 skolem-const-decl "nat" LTL_past_prop nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (TRUE const-decl "bool" booleans nil)
    (CNST const-decl "(atom?)" LTL_semantics nil)
    (atom? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (> const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (historically_dual 0
  (historically_dual-1 nil 3857857272
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (expand "semantic_rel" 1 2)
          (("" (decompose-equality)
            (("" (decompose-equality)
              (("" (iff)
                (("" (split)
                  (("1" (flatten)
                    (("1" (skeep)
                      (("1" (inst -1 "t_0")
                        (("1" (split)
                          (("1" (expand "semantic_rel" -2)
                            (("1" (propax) nil nil)) nil)
                           ("2" (typepred "t_0")
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (skeep)
                      (("2" (inst 1 "t_0")
                        (("2" (expand "semantic_rel" 1)
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (LTL type-decl nil LTL_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (not? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (NOT_LTL adt-constructor-decl "[LTL -> (not?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (historically_bd_dual 0
  (historically_bd_dual-1 nil 3857857348
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("1" (decompose-equality)
            (("1" (iff)
              (("1" (split)
                (("1" (flatten)
                  (("1" (split)
                    (("1" (expand "semantic_rel" -2)
                      (("1" (flatten)
                        (("1" (assert)
                          (("1" (skeep)
                            (("1" (insteep)
                              (("1"
                                (assert)
                                (("1"
                                  (expand "semantic_rel" -5)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (expand "semantic_rel" -2)
                        (("2" (assert)
                          (("2" (skeep)
                            (("2" (insteep)
                              (("2"
                                (assert)
                                (("2"
                                  (expand "semantic_rel" -3)
                                  (("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "semantic_rel" 1 1)
                  (("2" (flatten)
                    (("2" (split)
                      (("1" (split)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (skeep)
                              (("1"
                                (insteep)
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand "semantic_rel" 2)
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten) nil nil))
                        nil)
                       ("2" (flatten)
                        (("2" (assert)
                          (("2" (skeep)
                            (("2" (insteep)
                              (("2"
                                (assert)
                                (("2"
                                  (expand "semantic_rel" 2)
                                  (("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (typepred "interval")
                (("2" (expand "propIntNatLB?") (("2" (assert) nil nil))
                  nil))
                nil))
              nil)
             ("3" (skeep)
              (("3" (skeep)
                (("3" (typepred "interval")
                  (("3" (expand "propIntNatLB?")
                    (("3" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (typepred "interval")
              (("2" (expand "propIntNatLB?") (("2" (assert) nil nil))
                nil))
              nil))
            nil)
           ("3" (skeep)
            (("3" (skeep)
              (("3" (typepred "interval")
                (("3" (expand "propIntNatLB?") (("3" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (NOT_LTL adt-constructor-decl "[LTL -> (not?)]" LTL_adt nil)
    (not? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (ONCE_BD adt-constructor-decl
     "[[LTL, (propIntNatLB?)] -> (once_bd?)]" LTL_adt nil)
    (once_bd? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (LTL type-decl nil LTL_adt nil)
    (value adt-accessor-decl "[(lowerBound?) -> nat]" IntervalsNatural
     nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (UpperBound type-decl nil IntervalsNatural nil)
    (upperBound? adt-recognizer-decl "[UpperBound -> boolean]"
     IntervalsNatural nil)
    (LowerBound type-decl nil IntervalsNatural nil)
    (IntNat type-eq-decl nil IntervalsNatural nil)
    (propIntNatLB? const-decl "bool" IntervalsNatural nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (value adt-accessor-decl "[(upperBound?) -> nat]" IntervalsNatural
     nil)
    (lowerBound? adt-recognizer-decl "[LowerBound -> boolean]"
     IntervalsNatural nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (since_dual 0
  (since_dual-1 nil 3857857493
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (expand "semantic_rel" 1 3)
              (("" (iff)
                (("" (split)
                  (("1" (flatten)
                    (("1" (skeep)
                      (("1" (inst -4 "t_0")
                        (("1" (split)
                          (("1" (skeep)
                            (("1" (insteep)
                              (("1"
                                (assert)
                                (("1"
                                  (expand "semantic_rel" -2)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "semantic_rel" -1)
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (skeep)
                      (("2" (expand "semantic_rel" 1)
                        (("2" (inst 2 "t_0")
                          (("2" (assert)
                            (("2" (skeep)
                              (("2"
                                (insteep)
                                (("2"
                                  (assert)
                                  (("2"
                                    (expand "semantic_rel" 1)
                                    (("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv const-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (LTL type-decl nil LTL_adt nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (triggered? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (TRIGGERED adt-constructor-decl "[[LTL, LTL] -> (triggered?)]"
     LTL_adt nil)
    (not? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (NOT_LTL adt-constructor-decl "[LTL -> (not?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (once_idempotent 0
  (once_idempotent-1 nil 3857857849
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (skeep)
                    (("1" (insteep)
                      (("1" (expand "semantic_rel" 1)
                        (("1" (inst 1 "t_0") nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (skeep)
                    (("2" (expand "semantic_rel" -1)
                      (("2" (skeep) (("2" (inst 1 "t_1") nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (ONCE adt-constructor-decl "[LTL -> (once?)]" LTL_adt nil)
    (once? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (LTL type-decl nil LTL_adt nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (historically_idempotent 0
  (historically_idempotent-1 nil 3857857883
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (expand "semantic_rel" 1 2)
          (("" (decompose-equality)
            (("" (decompose-equality)
              (("" (iff)
                (("" (split)
                  (("1" (flatten)
                    (("1" (skeep)
                      (("1" (skeep)
                        (("1" (inst -1 "t_1") (("1" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (skeep)
                      (("2" (insteep)
                        (("2" (assert)
                          (("2" (inst -1 "t_0")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (LTL type-decl nil LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (since_idempotent 0
  (since_idempotent-1 nil 3857857909
   ("" (skeep)
    (("" (expand equiv)
      (("" (decompose-equality)
        (("" (decompose-equality)
          (("" (iff)
            (("" (split)
              (("1" (flatten)
                (("1" (expand semantic_rel)
                  (("1" (skeep)
                    (("1" (inst 1 "t_0")
                      (("1" (assert)
                        (("1" (skeep)
                          (("1" (expand "semantic_rel" 1)
                            (("1" (inst 1 "t_0")
                              (("1"
                                (assert)
                                (("1"
                                  (skeep)
                                  (("1"
                                    (inst -3 "t_2")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (expand semantic_rel)
                  (("2" (skeep)
                    (("2" (expand semantic_rel -3)
                      (("2" (case "t_0<x!2")
                        (("1" (inst -4 "x!2") (("1" (assert) nil nil))
                          nil)
                         ("2" (inst 2 "t_0") (("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((LTL type-decl nil LTL_adt nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (since? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (SINCE adt-constructor-decl "[[LTL, LTL] -> (since?)]" LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (since_previous 0
  (since_previous-1 nil 3857857943
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (expand "semantic_rel" 1 4)
                (("" (expand "semantic_rel" 1 5)
                  (("" (expand "semantic_rel" 1 5)
                    (("" (split)
                      (("1" (flatten)
                        (("1" (skeep)
                          (("1" (split)
                            (("1" (case "t_0=x!2")
                              (("1"
                                (replace -1)
                                (("1" (propax) nil nil))
                                nil)
                               ("2"
                                (inst -3 "x!2")
                                (("2" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (replace -1)
                              (("2"
                                (hide -4)
                                (("2"
                                  (typepred "t_0")
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (assert)
                              (("3"
                                (insteep)
                                (("3"
                                  (assert)
                                  (("3"
                                    (skeep)
                                    (("3"
                                      (insteep)
                                      (("3" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split)
                          (("1" (inst 1 "x!2") (("1" (assert) nil nil))
                            nil)
                           ("2" (flatten)
                            (("2" (split)
                              (("1" (propax) nil nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (skeep)
                                  (("2"
                                    (insteep)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (skeep)
                                        (("2"
                                          (insteep)
                                          (("1" (assert) nil nil)
                                           ("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil) nil nil
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (SINCE adt-constructor-decl "[[LTL, LTL] -> (since?)]" LTL_adt nil)
    (since? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (PREVIOUS adt-constructor-decl "[LTL -> (previous?)]" LTL_adt nil)
    (previous? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (AND_LTL adt-constructor-decl "[[LTL, LTL] -> (and?)]" LTL_adt nil)
    (and? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (LTL type-decl nil LTL_adt nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (triggered_zeta 0
  (triggered_zeta-1 nil 3857857987
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (split)
                    (("1" (inst -1 "x!2") (("1" (assert) nil nil)) nil)
                     ("2" (expand "semantic_rel" +)
                      (("2" (expand "semantic_rel" 1 2)
                        (("2" (flatten)
                          (("2" (split)
                            (("1" (propax) nil nil)
                             ("2" (flatten)
                              (("2"
                                (expand "semantic_rel" 2)
                                (("2"
                                  (skeep)
                                  (("2"
                                    (insteep -1)
                                    (("2"
                                      (split)
                                      (("1"
                                        (skeep)
                                        (("1"
                                          (insteep)
                                          (("1" (assert) nil nil)
                                           ("2" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (skeep)
                    (("2" (expand "semantic_rel" -2)
                      (("2" (expand "semantic_rel" -2 2)
                        (("2" (split)
                          (("1" (inst 2 "x!2") (("1" (assert) nil nil))
                            nil)
                           ("2" (replace -1)
                            (("2" (typepred "t_0")
                              (("2" (assert) nil nil)) nil))
                            nil)
                           ("3" (flatten)
                            (("3" (expand "semantic_rel" -1)
                              (("3"
                                (insteep -1)
                                (("1"
                                  (assert)
                                  (("1"
                                    (skeep)
                                    (("1"
                                      (insteep)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil nil nil (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (TRIGGERED adt-constructor-decl "[[LTL, LTL] -> (triggered?)]"
     LTL_adt nil)
    (triggered? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (ZETA adt-constructor-decl "[LTL -> (zeta?)]" LTL_adt nil)
    (zeta? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (OR_LTL adt-constructor-decl "[[LTL, LTL] -> (or?)]" LTL_adt nil)
    (or? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (historically_zeta 0
  (historically_zeta-1 nil 3857858011
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (split)
                    (("1" (inst -1 "x!2") (("1" (assert) nil nil)) nil)
                     ("2" (expand "semantic_rel" 1)
                      (("2" (expand "semantic_rel" 1)
                        (("2" (split)
                          (("1" (propax) nil nil)
                           ("2" (flatten)
                            (("2" (assert)
                              (("2"
                                (skeep)
                                (("2"
                                  (insteep)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (skeep)
                    (("2" (expand "semantic_rel" -2)
                      (("2" (expand "semantic_rel" -2)
                        (("2" (assert)
                          (("2" (insteep) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (HISTORICALLY adt-constructor-decl "[LTL -> (historically?)]"
     LTL_adt nil)
    (historically? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (ZETA adt-constructor-decl "[LTL -> (zeta?)]" LTL_adt nil)
    (zeta? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil) (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (zeta_or_distributive 0
  (zeta_or_distributive-1 nil 3857858042
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (expand "semantic_rel")
          (("" (decompose-equality)
            (("1" (decompose-equality)
              (("1" (iff)
                (("1" (split)
                  (("1" (flatten)
                    (("1" (split)
                      (("1" (assert) nil nil)
                       ("2" (flatten)
                        (("2" (assert)
                          (("2" (split)
                            (("1" (propax) nil nil)
                             ("2" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split)
                      (("1" (assert) nil nil)
                       ("2" (flatten) (("2" (assert) nil nil)) nil)
                       ("3" (assert) nil nil)
                       ("4" (flatten) (("4" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skeep) (("2" (assert) nil nil)) nil)
               ("3" (skeep) (("3" (assert) nil nil)) nil)
               ("4" (skeep) (("4" (assert) nil nil)) nil))
              nil)
             ("2" (skeep) (("2" (assert) nil nil)) nil)
             ("3" (skeep) (("3" (assert) nil nil)) nil)
             ("4" (skeep) (("4" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil
    (LTL type-decl nil LTL_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (TRUE const-decl "bool" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (previous_or_distributive 0
  (previous_or_distributive-1 nil 3857858074
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (expand "semantic_rel")
          (("" (decompose-equality)
            (("1" (decompose-equality)
              (("1" (iff)
                (("1" (split)
                  (("1" (flatten)
                    (("1" (split)
                      (("1" (propax) nil nil)
                       ("2" (flatten)
                        (("2" (assert)
                          (("2" (split)
                            (("1" (propax) nil nil)
                             ("2" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split)
                      (("1" (propax) nil nil)
                       ("2" (flatten) (("2" (assert) nil nil)) nil)
                       ("3" (propax) nil nil)
                       ("4" (flatten) (("4" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skeep) (("2" (assert) nil nil)) nil)
               ("3" (skeep) (("3" (assert) nil nil)) nil)
               ("4" (skeep) (("4" (assert) nil nil)) nil))
              nil)
             ("2" (skeep) (("2" (assert) nil nil)) nil)
             ("3" (skeep) (("3" (assert) nil nil)) nil)
             ("4" (skeep) (("4" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil
    (LTL type-decl nil LTL_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (FALSE const-decl "bool" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (previous_and_distributive 0
  (previous_and_distributive-1 nil 3857858103
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("1" (decompose-equality)
            (("1" (expand "semantic_rel")
              (("1" (iff)
                (("1" (split)
                  (("1" (flatten)
                    (("1" (split)
                      (("1" (propax) nil nil)
                       ("2" (flatten) (("2" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split)
                      (("1" (propax) nil nil)
                       ("2" (flatten) (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep)
              (("2" (typepred "t") (("2" (assert) nil nil)) nil)) nil))
            nil)
           ("2" (skeep)
            (("2" (typepred "t") (("2" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (PREVIOUS adt-constructor-decl "[LTL -> (previous?)]" LTL_adt nil)
    (previous? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (AND_LTL adt-constructor-decl "[[LTL, LTL] -> (and?)]" LTL_adt nil)
    (and? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (LTL type-decl nil LTL_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (zeta_and_distributive 0
  (zeta_and_distributive-1 nil 3857858140
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("1" (decompose-equality)
            (("1" (expand "semantic_rel")
              (("1" (iff)
                (("1" (split)
                  (("1" (flatten)
                    (("1" (split)
                      (("1" (assert) nil nil)
                       ("2" (flatten) (("2" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split)
                      (("1" (assert) nil nil)
                       ("2" (flatten) (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep) (("2" (assert) nil nil)) nil))
            nil)
           ("2" (skeep) (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (ZETA adt-constructor-decl "[LTL -> (zeta?)]" LTL_adt nil)
    (zeta? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (AND_LTL adt-constructor-decl "[[LTL, LTL] -> (and?)]" LTL_adt nil)
    (and? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (LTL type-decl nil LTL_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (once_or_distributive 0
  (once_or_distributive-1 nil 3857858168
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (expand "semantic_rel")
          (("" (decompose-equality)
            (("" (decompose-equality)
              (("" (iff)
                (("" (split)
                  (("1" (flatten)
                    (("1" (skeep)
                      (("1" (insteep)
                        (("1" (insteep)
                          (("1" (split)
                            (("1" (propax) nil nil)
                             ("2" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split)
                      (("1" (skeep)
                        (("1" (insteep) (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (skeep)
                        (("2" (insteep) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (LTL type-decl nil LTL_adt nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (once_bd_or_distributive 0
  (once_bd_or_distributive-1 nil 3857858196
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("1" (decompose-equality)
            (("1" (iff)
              (("1" (split)
                (("1" (flatten)
                  (("1" (expand "semantic_rel" +)
                    (("1" (split)
                      (("1" (flatten)
                        (("1" (assert)
                          (("1" (skeep)
                            (("1" (insteep)
                              (("1"
                                (assert)
                                (("1"
                                  (expand "semantic_rel" -4)
                                  (("1"
                                    (insteep)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (assert)
                          (("2" (skeep)
                            (("2" (insteep)
                              (("2"
                                (insteep)
                                (("2"
                                  (expand "semantic_rel" -2)
                                  (("2"
                                    (split)
                                    (("1" (assert) nil nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel")
                    (("2"
                      (case "upperBound?(interval`ub
)")
                      (("1" (assert)
                        (("1" (split)
                          (("1" (skeep)
                            (("1" (insteep) (("1" (assert) nil nil))
                              nil))
                            nil)
                           ("2" (skeep)
                            (("2" (insteep) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert)
                        (("2" (split)
                          (("1" (skeep)
                            (("1" (insteep) (("1" (assert) nil nil))
                              nil))
                            nil)
                           ("2" (skeep)
                            (("2" (insteep) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "interval")
              (("2" (expand "propIntNatLB?")
                (("2" (assert)
                  (("2" (flatten) (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil)
             ("3" (skeep)
              (("3" (skeep)
                (("3" (typepred "interval")
                  (("3" (expand "propIntNatLB?")
                    (("3" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (typepred "interval")
              (("2" (expand "propIntNatLB?") (("2" (assert) nil nil))
                nil))
              nil))
            nil)
           ("3" (skeep)
            (("3" (skeep)
              (("3" (typepred "interval")
                (("3" (expand "propIntNatLB?") (("3" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (ONCE_BD adt-constructor-decl
     "[[LTL, (propIntNatLB?)] -> (once_bd?)]" LTL_adt nil)
    (once_bd? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (OR_LTL adt-constructor-decl "[[LTL, LTL] -> (or?)]" LTL_adt nil)
    (or? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (LTL type-decl nil LTL_adt nil)
    (value adt-accessor-decl "[(lowerBound?) -> nat]" IntervalsNatural
     nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (UpperBound type-decl nil IntervalsNatural nil)
    (upperBound? adt-recognizer-decl "[UpperBound -> boolean]"
     IntervalsNatural nil)
    (LowerBound type-decl nil IntervalsNatural nil)
    (IntNat type-eq-decl nil IntervalsNatural nil)
    (propIntNatLB? const-decl "bool" IntervalsNatural nil) nil
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (value adt-accessor-decl "[(upperBound?) -> nat]" IntervalsNatural
     nil)
    (lowerBound? adt-recognizer-decl "[LowerBound -> boolean]"
     IntervalsNatural nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (historically_and_distributive 0
  (historically_and_distributive-1 nil 3857858225
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "semantic_rel")
                    (("1" (split)
                      (("1" (skeep)
                        (("1" (insteep) (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (skeep)
                        (("2" (insteep) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel")
                    (("2" (skeep)
                      (("2" (insteep)
                        (("2" (insteep) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (HISTORICALLY adt-constructor-decl "[LTL -> (historically?)]"
     LTL_adt nil)
    (historically? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (AND_LTL adt-constructor-decl "[[LTL, LTL] -> (and?)]" LTL_adt nil)
    (and? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (LTL type-decl nil LTL_adt nil) (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (historically_bd_and_distributive 0
  (historically_bd_and_distributive-1 nil 3857858294
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("1" (decompose-equality)
            (("1" (expand "semantic_rel")
              (("1" (iff)
                (("1" (split)
                  (("1" (flatten)
                    (("1" (case "upperBound?(interval`ub)")
                      (("1" (assert)
                        (("1" (split)
                          (("1" (skeep)
                            (("1" (insteep) (("1" (assert) nil nil))
                              nil))
                            nil)
                           ("2" (skeep)
                            (("2" (insteep) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert)
                        (("2" (split)
                          (("1" (skeep)
                            (("1" (insteep) (("1" (assert) nil nil))
                              nil))
                            nil)
                           ("2" (skeep)
                            (("2" (insteep) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (case "upperBound?(interval`ub)")
                      (("1" (assert)
                        (("1" (skeep)
                          (("1" (insteep)
                            (("1" (insteep) (("1" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert)
                        (("2" (skeep)
                          (("2" (insteep)
                            (("2" (insteep) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "interval")
              (("2" (expand "propIntNatLB?")
                (("2" (flatten) (("2" (assert) nil nil)) nil)) nil))
              nil)
             ("3" (skeep)
              (("3" (skeep)
                (("3" (typepred "interval")
                  (("3" (expand "propIntNatLB?")
                    (("3" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (typepred "interval")
              (("2" (expand "propIntNatLB?") (("2" (assert) nil nil))
                nil))
              nil))
            nil)
           ("3" (skeep)
            (("3" (skeep)
              (("3" (typepred "interval")
                (("3" (expand "propIntNatLB?") (("3" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (HISTORICALLY_BD adt-constructor-decl
     "[[LTL, (propIntNatLB?)] -> (historically_bd?)]" LTL_adt nil)
    (historically_bd? adt-recognizer-decl "[LTL -> boolean]" LTL_adt
     nil)
    (AND_LTL adt-constructor-decl "[[LTL, LTL] -> (and?)]" LTL_adt nil)
    (and? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (LTL type-decl nil LTL_adt nil)
    (value adt-accessor-decl "[(lowerBound?) -> nat]" IntervalsNatural
     nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (UpperBound type-decl nil IntervalsNatural nil)
    (upperBound? adt-recognizer-decl "[UpperBound -> boolean]"
     IntervalsNatural nil)
    (LowerBound type-decl nil IntervalsNatural nil)
    (IntNat type-eq-decl nil IntervalsNatural nil)
    (propIntNatLB? const-decl "bool" IntervalsNatural nil) nil
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (value adt-accessor-decl "[(upperBound?) -> nat]" IntervalsNatural
     nil)
    (lowerBound? adt-recognizer-decl "[LowerBound -> boolean]"
     IntervalsNatural nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (since_or_distributive 0
  (since_or_distributive-1 nil 3857858389
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "semantic_rel" +)
                    (("1" (expand "semantic_rel" -1 1)
                      (("1" (skeep)
                        (("1" (insteep)
                          (("1" (insteep)
                            (("1" (split)
                              (("1" (assert) nil nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel" -)
                    (("2" (split)
                      (("1" (skeep)
                        (("1" (insteep)
                          (("1" (assert)
                            (("1" (expand "semantic_rel" 1 1)
                              (("1" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (skeep)
                        (("2" (insteep)
                          (("2" (expand "semantic_rel" 1 1)
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (SINCE adt-constructor-decl "[[LTL, LTL] -> (since?)]" LTL_adt nil)
    (since? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (OR_LTL adt-constructor-decl "[[LTL, LTL] -> (or?)]" LTL_adt nil)
    (or? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (LTL type-decl nil LTL_adt nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak))
 (since_and_distributive 0
  (since_and_distributive-1 nil 3857858357
   ("" (skeep)
    (("" (expand "equiv")
      (("" (expand "semantic_rel")
        (("" (decompose-equality)
          (("" (decompose-equality)
            (("" (iff)
              (("" (split)
                (("1" (flatten)
                  (("1" (expand "semantic_rel" +)
                    (("1" (expand "semantic_rel" -1 2)
                      (("1" (skeep)
                        (("1" (split)
                          (("1" (insteep)
                            (("1" (assert)
                              (("1"
                                (skeep)
                                (("1"
                                  (insteep)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (insteep)
                            (("2" (assert)
                              (("2"
                                (skeep)
                                (("2"
                                  (insteep)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "semantic_rel" -)
                    (("2" (expand "semantic_rel" 1 2)
                      (("2" (skeep)
                        (("2" (skeep)
                          (("2" (case "t_0<=t_0!1")
                            (("1" (inst 1 "t_0!1")
                              (("1"
                                (assert)
                                (("1"
                                  (skeep)
                                  (("1"
                                    (insteep)
                                    (("1"
                                      (insteep)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (inst 2 "t_0")
                              (("2"
                                (assert)
                                (("2"
                                  (skeep)
                                  (("2"
                                    (insteep)
                                    (("2"
                                      (insteep)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semantic_rel def-decl "bool" LTL_semantics nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (State formal-nonempty-type-decl nil LTL_past_prop nil)
    (SINCE adt-constructor-decl "[[LTL, LTL] -> (since?)]" LTL_adt nil)
    (since? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (AND_LTL adt-constructor-decl "[[LTL, LTL] -> (and?)]" LTL_adt nil)
    (and? adt-recognizer-decl "[LTL -> boolean]" LTL_adt nil)
    (> const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (LTL type-decl nil LTL_adt nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Trace type-eq-decl nil LTL_semantics nil)
    (equiv const-decl "bool" LTL_semantics nil))
   shostak)))

