(test (new_pi_bnds 0
       (new_pi_bnds-1 nil 3394257208
        ("" (era-numerical "pi" :precision 62) (("" (assert) nil nil))
         nil)
        ((< const-decl "bool" reals nil)
         (expt def-decl "real" exponentiation nil)
         (posnat_expt application-judgement "posnat" exponentiation
          nil)
         (nml_1 skolem-const-decl "(pi?)" test nil)
         (pi const-decl "posreal" atan "trig_fnd/")
         (posrat_plus_nnrat_is_posrat application-judgement "posrat"
          rationals nil)
         (+ const-decl "[numfield, numfield -> numfield]" number_fields
            nil)
         (nonzero_real nonempty-type-eq-decl nil reals nil)
         (times_div_cancel2 formula-decl nil extra_real_props nil)
         (posrat_times_posrat_is_posrat application-judgement "posrat"
          rationals nil)
         (Eval_real def-decl "Maybe[real]" cauchy_expr_Eval nil)
         (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
         (* const-decl "[numfield, numfield -> numfield]" number_fields
            nil)
         (- const-decl "[numfield, numfield -> numfield]" number_fields
            nil)
         (^ const-decl "real" exponentiation nil)
         (OR const-decl "[bool, bool -> bool]" booleans nil)
         (posreal nonempty-type-eq-decl nil real_types nil)
         (> const-decl "bool" reals nil)
         (nonneg_real nonempty-type-eq-decl nil real_types nil)
         (both_sides_div_pos_lt1 formula-decl nil real_props nil)
         (rat_minus_rat_is_rat application-judgement "rat" rationals
          nil)
         (real_lt_is_strict_total_order name-judgement
          "(strict_total_order?[real])" real_props nil)
         (real_minus_real_is_real application-judgement "real" reals
          nil)
         (real_plus_real_is_real application-judgement "real" reals
          nil)
         (posint_exp application-judgement "posint" exponentiation nil)
         (real_times_real_is_real application-judgement "real" reals
          nil)
         (pi_bound name-judgement
          "{r: posreal | pi_lb < r AND r < pi_ub}" atan_approx
          "trig_fnd/")
         (numerical_soundness formula-decl nil cauchy_numerical nil)
         (bool nonempty-type-eq-decl nil booleans nil)
         (bijective? const-decl "bool" functions nil)
         (id const-decl "(bijective?[T, T])" identity nil)
         (TRUE const-decl "bool" booleans nil)
         (/ const-decl "[numfield, nznum -> numfield]" number_fields
            nil)
         (nznum nonempty-type-eq-decl nil number_fields nil)
         (/= const-decl "boolean" notequal nil)
         (numfield nonempty-type-eq-decl nil number_fields nil)
         (Some adt-constructor-decl "[T -> (some?)]" Maybe
          "structures/")
         (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
          "structures/")
         (null adt-constructor-decl "(null?)" list_adt nil)
         (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
         (numerical const-decl "Output" cauchy_numerical nil)
         (Output type-eq-decl nil cauchy_numerical nil)
         (rat nonempty-type-eq-decl nil rationals nil)
         (AND const-decl "[bool, bool -> bool]" booleans nil)
         (every adt-def-decl "boolean" list_adt nil)
         (PRED type-eq-decl nil defined_types nil)
         (list type-decl nil list_adt nil)
         (nat nonempty-type-eq-decl nil naturalnumbers nil)
         (>= const-decl "bool" reals nil)
         (int nonempty-type-eq-decl nil integers nil)
         (integer_pred const-decl "[rational -> boolean]" integers nil)
         (rational nonempty-type-from-decl nil rationals nil)
         (rational_pred const-decl "[real -> boolean]" rationals nil)
         (Maybe type-decl nil Maybe "structures/")
         (real nonempty-type-from-decl nil reals nil)
         (real_pred const-decl "[number_field -> boolean]" reals nil)
         (number_field nonempty-type-from-decl nil number_fields nil)
         (number_field_pred const-decl "[number -> boolean]"
          number_fields nil)
         (number nonempty-type-decl nil numbers nil)
         (posrat_div_posrat_is_posrat application-judgement "posrat"
          rationals nil)
         (CauchyExpr type-decl nil CauchyExpr_adt nil)
         (boolean nonempty-type-decl nil booleans nil)
         (= const-decl "[T, T -> boolean]" equalities nil)
         (pi? adt-recognizer-decl "[CauchyExpr -> boolean]"
          CauchyExpr_adt nil)
         (PI adt-constructor-decl "(pi?)" CauchyExpr_adt nil))
        shostak))
      (new_ln2_bnds 0
       (new_ln2_bnds-1 nil 3394261090
        ("" (beta)
         (("" (era-numerical "ln(2)" :precision 62)
           (("" (assert) nil nil)) nil))
         nil)
        ((r2E const-decl "CauchyExpr" cauchy_expr_Eval nil)
         (rat nonempty-type-eq-decl nil rationals nil)
         (rational_pred const-decl "[real -> boolean]" rationals nil)
         (real nonempty-type-from-decl nil reals nil)
         (real_pred const-decl "[number_field -> boolean]" reals nil)
         (number_field nonempty-type-from-decl nil number_fields nil)
         (number_field_pred const-decl "[number -> boolean]"
          number_fields nil)
         (number nonempty-type-decl nil numbers nil)
         (LN adt-constructor-decl "[CauchyExpr -> (ln?)]"
          CauchyExpr_adt nil)
         (ln? adt-recognizer-decl "[CauchyExpr -> boolean]"
          CauchyExpr_adt nil)
         (= const-decl "[T, T -> boolean]" equalities nil)
         (boolean nonempty-type-decl nil booleans nil)
         (CauchyExpr type-decl nil CauchyExpr_adt nil)
         (posrat_div_posrat_is_posrat application-judgement "posrat"
          rationals nil)
         (Maybe type-decl nil Maybe "structures/")
         (rational nonempty-type-from-decl nil rationals nil)
         (integer_pred const-decl "[rational -> boolean]" integers nil)
         (int nonempty-type-eq-decl nil integers nil)
         (>= const-decl "bool" reals nil)
         (nat nonempty-type-eq-decl nil naturalnumbers nil)
         (list type-decl nil list_adt nil)
         (PRED type-eq-decl nil defined_types nil)
         (every adt-def-decl "boolean" list_adt nil)
         (AND const-decl "[bool, bool -> bool]" booleans nil)
         (Output type-eq-decl nil cauchy_numerical nil)
         (numerical const-decl "Output" cauchy_numerical nil)
         (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
         (null adt-constructor-decl "(null?)" list_adt nil)
         (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
          "structures/")
         (Some adt-constructor-decl "[T -> (some?)]" Maybe
          "structures/")
         (numfield nonempty-type-eq-decl nil number_fields nil)
         (/= const-decl "boolean" notequal nil)
         (nznum nonempty-type-eq-decl nil number_fields nil)
         (/ const-decl "[numfield, nznum -> numfield]" number_fields
            nil)
         (bool nonempty-type-eq-decl nil booleans nil)
         (bijective? const-decl "bool" functions nil)
         (id const-decl "(bijective?[T, T])" identity nil)
         (TRUE const-decl "bool" booleans nil)
         (numerical_soundness formula-decl nil cauchy_numerical nil)
         (real_times_real_is_real application-judgement "real" reals
          nil)
         (posint_exp application-judgement "posint" exponentiation nil)
         (real_plus_real_is_real application-judgement "real" reals
          nil)
         (real_minus_real_is_real application-judgement "real" reals
          nil)
         (real_lt_is_strict_total_order name-judgement
          "(strict_total_order?[real])" real_props nil)
         (rat_minus_rat_is_rat application-judgement "rat" rationals
          nil)
         (both_sides_div_pos_lt1 formula-decl nil real_props nil)
         (nonneg_real nonempty-type-eq-decl nil real_types nil)
         (> const-decl "bool" reals nil)
         (posreal nonempty-type-eq-decl nil real_types nil)
         (OR const-decl "[bool, bool -> bool]" booleans nil)
         (^ const-decl "real" exponentiation nil)
         (- const-decl "[numfield, numfield -> numfield]" number_fields
            nil)
         (* const-decl "[numfield, numfield -> numfield]" number_fields
            nil)
         (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
         (Eval_real def-decl "Maybe[real]" cauchy_expr_Eval nil)
         (posrat_times_posrat_is_posrat application-judgement "posrat"
          rationals nil)
         (times_div_cancel2 formula-decl nil extra_real_props nil)
         (nonzero_real nonempty-type-eq-decl nil reals nil)
         (+ const-decl "[numfield, numfield -> numfield]" number_fields
            nil)
         (posrat_plus_nnrat_is_posrat application-judgement "posrat"
          rationals nil)
         (ln const-decl "real" ln_exp "lnexp_fnd/")
         (nml_2 skolem-const-decl "(ln?)" test nil)
         (real_le_is_total_order name-judgement "(total_order?[real])"
          real_props nil)
         (posnat_expt application-judgement "posnat" exponentiation
          nil)
         (expt def-decl "real" exponentiation nil)
         (< const-decl "bool" reals nil))
        shostak))
      (new_e_bnds 0
       (new_e_bnds-1 nil 3394258369
        ("" (era-numerical "exp(1)" :precision 60)
         (("" (assert) nil nil)) nil)
        ((< const-decl "bool" reals nil)
         (expt def-decl "real" exponentiation nil)
         (posnat_expt application-judgement "posnat" exponentiation
          nil)
         (exp_1 formula-decl nil ln_exp "lnexp_fnd/")
         (nml_3 skolem-const-decl "(exp?)" test nil)
         (exp const-decl "{py | x = ln(py)}" ln_exp "lnexp_fnd/")
         (ln const-decl "real" ln_exp "lnexp_fnd/")
         (posrat_plus_nnrat_is_posrat application-judgement "posrat"
          rationals nil)
         (+ const-decl "[numfield, numfield -> numfield]" number_fields
            nil)
         (nonzero_real nonempty-type-eq-decl nil reals nil)
         (times_div_cancel2 formula-decl nil extra_real_props nil)
         (posrat_times_posrat_is_posrat application-judgement "posrat"
          rationals nil)
         (Eval_real def-decl "Maybe[real]" cauchy_expr_Eval nil)
         (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
         (* const-decl "[numfield, numfield -> numfield]" number_fields
            nil)
         (- const-decl "[numfield, numfield -> numfield]" number_fields
            nil)
         (^ const-decl "real" exponentiation nil)
         (OR const-decl "[bool, bool -> bool]" booleans nil)
         (posreal nonempty-type-eq-decl nil real_types nil)
         (> const-decl "bool" reals nil)
         (nonneg_real nonempty-type-eq-decl nil real_types nil)
         (both_sides_div_pos_lt1 formula-decl nil real_props nil)
         (rat_minus_rat_is_rat application-judgement "rat" rationals
          nil)
         (real_lt_is_strict_total_order name-judgement
          "(strict_total_order?[real])" real_props nil)
         (real_minus_real_is_real application-judgement "real" reals
          nil)
         (real_plus_real_is_real application-judgement "real" reals
          nil)
         (posint_exp application-judgement "posint" exponentiation nil)
         (real_times_real_is_real application-judgement "real" reals
          nil)
         (numerical_soundness formula-decl nil cauchy_numerical nil)
         (TRUE const-decl "bool" booleans nil)
         (id const-decl "(bijective?[T, T])" identity nil)
         (bijective? const-decl "bool" functions nil)
         (bool nonempty-type-eq-decl nil booleans nil)
         (/ const-decl "[numfield, nznum -> numfield]" number_fields
            nil)
         (nznum nonempty-type-eq-decl nil number_fields nil)
         (/= const-decl "boolean" notequal nil)
         (numfield nonempty-type-eq-decl nil number_fields nil)
         (Some adt-constructor-decl "[T -> (some?)]" Maybe
          "structures/")
         (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
          "structures/")
         (null adt-constructor-decl "(null?)" list_adt nil)
         (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
         (numerical const-decl "Output" cauchy_numerical nil)
         (Output type-eq-decl nil cauchy_numerical nil)
         (AND const-decl "[bool, bool -> bool]" booleans nil)
         (every adt-def-decl "boolean" list_adt nil)
         (PRED type-eq-decl nil defined_types nil)
         (list type-decl nil list_adt nil)
         (nat nonempty-type-eq-decl nil naturalnumbers nil)
         (>= const-decl "bool" reals nil)
         (int nonempty-type-eq-decl nil integers nil)
         (integer_pred const-decl "[rational -> boolean]" integers nil)
         (rational nonempty-type-from-decl nil rationals nil)
         (Maybe type-decl nil Maybe "structures/")
         (posrat_div_posrat_is_posrat application-judgement "posrat"
          rationals nil)
         (CauchyExpr type-decl nil CauchyExpr_adt nil)
         (boolean nonempty-type-decl nil booleans nil)
         (= const-decl "[T, T -> boolean]" equalities nil)
         (exp? adt-recognizer-decl "[CauchyExpr -> boolean]"
          CauchyExpr_adt nil)
         (EXP adt-constructor-decl "[CauchyExpr -> (exp?)]"
          CauchyExpr_adt nil)
         (number nonempty-type-decl nil numbers nil)
         (number_field_pred const-decl "[number -> boolean]"
          number_fields nil)
         (number_field nonempty-type-from-decl nil number_fields nil)
         (real_pred const-decl "[number_field -> boolean]" reals nil)
         (real nonempty-type-from-decl nil reals nil)
         (rational_pred const-decl "[real -> boolean]" rationals nil)
         (rat nonempty-type-eq-decl nil rationals nil)
         (r2E const-decl "CauchyExpr" cauchy_expr_Eval nil))
        shostak))
      (new_sqrt2_bnds 0
       (new_sqrt2_bnds-1 nil 3394259998
        ("" (era-numerical "sqrt(2)" :precision 60)
         (("" (assert) nil nil)) nil)
        ((< const-decl "bool" reals nil)
         (expt def-decl "real" exponentiation nil)
         (posnat_expt application-judgement "posnat" exponentiation
          nil)
         (nml_4 skolem-const-decl "(sqrt?)" test nil)
         (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt
               "reals/")
         (nnreal type-eq-decl nil real_types nil)
         (sqrt_pos application-judgement "posreal" sqrt "reals/")
         (posrat_plus_nnrat_is_posrat application-judgement "posrat"
          rationals nil)
         (+ const-decl "[numfield, numfield -> numfield]" number_fields
            nil)
         (nonzero_real nonempty-type-eq-decl nil reals nil)
         (times_div_cancel2 formula-decl nil extra_real_props nil)
         (posrat_times_posrat_is_posrat application-judgement "posrat"
          rationals nil)
         (Eval_real def-decl "Maybe[real]" cauchy_expr_Eval nil)
         (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
         (* const-decl "[numfield, numfield -> numfield]" number_fields
            nil)
         (- const-decl "[numfield, numfield -> numfield]" number_fields
            nil)
         (^ const-decl "real" exponentiation nil)
         (OR const-decl "[bool, bool -> bool]" booleans nil)
         (posreal nonempty-type-eq-decl nil real_types nil)
         (> const-decl "bool" reals nil)
         (nonneg_real nonempty-type-eq-decl nil real_types nil)
         (both_sides_div_pos_lt1 formula-decl nil real_props nil)
         (rat_minus_rat_is_rat application-judgement "rat" rationals
          nil)
         (real_lt_is_strict_total_order name-judgement
          "(strict_total_order?[real])" real_props nil)
         (real_minus_real_is_real application-judgement "real" reals
          nil)
         (real_plus_real_is_real application-judgement "real" reals
          nil)
         (posint_exp application-judgement "posint" exponentiation nil)
         (real_times_real_is_real application-judgement "real" reals
          nil)
         (numerical_soundness formula-decl nil cauchy_numerical nil)
         (TRUE const-decl "bool" booleans nil)
         (id const-decl "(bijective?[T, T])" identity nil)
         (bijective? const-decl "bool" functions nil)
         (bool nonempty-type-eq-decl nil booleans nil)
         (/ const-decl "[numfield, nznum -> numfield]" number_fields
            nil)
         (nznum nonempty-type-eq-decl nil number_fields nil)
         (/= const-decl "boolean" notequal nil)
         (numfield nonempty-type-eq-decl nil number_fields nil)
         (Some adt-constructor-decl "[T -> (some?)]" Maybe
          "structures/")
         (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
          "structures/")
         (null adt-constructor-decl "(null?)" list_adt nil)
         (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
         (numerical const-decl "Output" cauchy_numerical nil)
         (Output type-eq-decl nil cauchy_numerical nil)
         (AND const-decl "[bool, bool -> bool]" booleans nil)
         (every adt-def-decl "boolean" list_adt nil)
         (PRED type-eq-decl nil defined_types nil)
         (list type-decl nil list_adt nil)
         (nat nonempty-type-eq-decl nil naturalnumbers nil)
         (>= const-decl "bool" reals nil)
         (int nonempty-type-eq-decl nil integers nil)
         (integer_pred const-decl "[rational -> boolean]" integers nil)
         (rational nonempty-type-from-decl nil rationals nil)
         (Maybe type-decl nil Maybe "structures/")
         (posrat_div_posrat_is_posrat application-judgement "posrat"
          rationals nil)
         (CauchyExpr type-decl nil CauchyExpr_adt nil)
         (boolean nonempty-type-decl nil booleans nil)
         (= const-decl "[T, T -> boolean]" equalities nil)
         (sqrt? adt-recognizer-decl "[CauchyExpr -> boolean]"
          CauchyExpr_adt nil)
         (SQRT adt-constructor-decl "[CauchyExpr -> (sqrt?)]"
          CauchyExpr_adt nil)
         (number nonempty-type-decl nil numbers nil)
         (number_field_pred const-decl "[number -> boolean]"
          number_fields nil)
         (number_field nonempty-type-from-decl nil number_fields nil)
         (real_pred const-decl "[number_field -> boolean]" reals nil)
         (real nonempty-type-from-decl nil reals nil)
         (rational_pred const-decl "[real -> boolean]" rationals nil)
         (rat nonempty-type-eq-decl nil rationals nil)
         (r2E const-decl "CauchyExpr" cauchy_expr_Eval nil))
        shostak)))

