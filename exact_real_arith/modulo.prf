(modulo
 (cauchy_mod_TCC1 0
  (cauchy_mod_TCC1-1 nil 3674987581 ("" (subtype-tcc) nil nil)
   ((cauchy_nzreal nonempty-type-eq-decl nil cauchy nil)
    (cauchy_nzreal? const-decl "bool" cauchy nil)
    (cauchy_real nonempty-type-eq-decl nil cauchy nil)
    (cauchy_real? const-decl "bool" cauchy nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cauchy_prop const-decl "bool" cauchy nil)
    (cauchy_noninteger? const-decl "bool" floor nil)
    (divides const-decl "bool" divides nil)
    (cauchy_mul const-decl "cauchy_real" mul nil)
    (cauchy_nz_inv const-decl "cauchy_nzreal" inv nil)
    (round const-decl "int" prelude_aux nil)
    (minimum_inv_impl const-decl "nat" inv nil)
    (^ const-decl "real" exponentiation nil)
    (cauchy_div const-decl "cauchy_real" div nil)
    (cauchy_inv const-decl "cauchy_nzreal" inv nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_plus_even_is_even application-judgement "even_int" integers
     nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (posnat_expt application-judgement "posnat" exponentiation nil))
   nil))
 (mod_lemma_TCC1 0
  (mod_lemma_TCC1-1 nil 3674987581
   ("" (skeep)
    (("" (hide -1)
      (("" (typepred "b")
        (("" (expand "cauchy_nzreal?") (("" (inst 1 "b") nil nil))
          nil))
        nil))
      nil))
    nil)
   ((cauchy_nzreal? const-decl "bool" cauchy nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil))
   nil))
 (mod_lemma 0
  (mod_lemma-1 nil 3674989306
   ("" (skeep)
    (("" (lemma "rem_floor")
      (("" (inst -1 "b" "a")
        (("" (both-sides "-" "b * floor(a/b)" -1)
          (("" (assert)
            (("" (replace -1 :dir rl)
              (("" (expand "cauchy_mod")
                (("" (lemma "sub_lemma")
                  ((""
                    (inst -1 "cx"
                     "cauchy_mul(cy, cauchy_floor(cauchy_div(cx, cy)))"
                     "a" "b * floor(a / b)")
                    (("" (split)
                      (("1" (propax) nil nil) ("2" (propax) nil nil)
                       ("3" (hide (-1 2))
                        (("3" (lemma "mul_lemma")
                          (("3"
                            (inst -1 "cy"
                             "cauchy_floor(cauchy_div(cx, cy))" "b"
                             "floor(a / b)")
                            (("3" (split)
                              (("1" (propax) nil nil)
                               ("2" (propax) nil nil)
                               ("3"
                                (hide 2)
                                (("3"
                                  (lemma "floor_lemma")
                                  (("3"
                                    (inst
                                     -1
                                     "cauchy_div(cx, cy)"
                                     "a / b")
                                    (("3"
                                      (split)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (hide 2)
                                        (("2"
                                          (lemma "div_lemma")
                                          (("2"
                                            (inst -1 "cx" "cy" "b" "a")
                                            (("2"
                                              (split)
                                              (("1" (propax) nil nil)
                                               ("2" (propax) nil nil)
                                               ("3" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((rem_floor formula-decl nil modulo_arithmetic nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (integer nonempty-type-from-decl nil integers nil)
    (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}"
         modulo_arithmetic nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (divides const-decl "bool" divides nil)
    (sub_lemma formula-decl nil sub nil)
    (mul_lemma formula-decl nil mul nil)
    (floor_lemma formula-decl nil floor nil)
    (div_lemma formula-decl nil div nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (cauchy_real? const-decl "bool" cauchy nil)
    (cauchy_real nonempty-type-eq-decl nil cauchy nil)
    (cauchy_mul const-decl "cauchy_real" mul nil)
    (cauchy_noninteger? const-decl "bool" floor nil)
    (cauchy_noninteger nonempty-type-eq-decl nil floor nil)
    (cauchy_int const-decl "cauchy_real" int nil)
    (cauchy_floor const-decl
     "{cx: cauchy_real | EXISTS i: cx = cauchy_int(i)}" floor nil)
    (cauchy_nzreal? const-decl "bool" cauchy nil)
    (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil)
    (cauchy_div const-decl "cauchy_real" div nil)
    (cauchy_mod const-decl "cauchy_real" modulo nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   shostak)))

