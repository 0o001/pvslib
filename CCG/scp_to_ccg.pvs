scp_to_ccg[Val,Expr,Condition: TYPE, 
    (IMPORTING cc_def[Val,Expr,Condition]) CCs:set[CallingContext],
               semantic_rel:PRED[[Expr,Val,Val]],eval_conds:PRED[[Condition,Val]]] : THEORY
BEGIN

  ASSUMING 
    IMPORTING scp[Val,Expr,Condition,[nat->(CCs)]]

    scp_termination : ASSUMPTION 
      scp_termination?(semantic_rel,eval_conds)

    sem_rel_finite: ASSUMPTION 
      FORALL(e:Expr,val1:Val): is_finite[Val]({val2:Val| EXISTS (cc:(CCs)) : 
        eval_conds(cc`conds,val1) AND semantic_rel(cc`actuals,val1,val2)})
  ENDASSUMING

  Seq_cc: TYPE = [nat->(CCs)]

  R(val1,val2:Val) : bool = 
    EXISTS (cc:(CCs)) : eval_conds(cc`conds,val1) AND semantic_rel(cc`actuals,val1,val2)

  omega_is_wf: LEMMA well_founded?[Val](R);

  omega_is_finite: LEMMA FORALL (x: Val): is_finite[Val]({y: Val | R(y, x)});

  IMPORTING orders@omega[Val,R],
            ccg[Val,Expr,Condition,nat,LAMBDA(n,m:nat):n < m,1,semantic_rel,eval_conds]

  Graph_cc : TYPE = {dg:digraph | subset?(vert(dg),CCs) AND
    (FORALL (e:(edges(dg))): LET (cc1,cc2) = e IN
      EXISTS (val1,val2:Val) :eval_conds(cc1`conds, val1) AND semantic_rel(cc1`actuals, val1,val2) AND
                              eval_conds(cc2`conds, val2))}

  scp_implies_ccg_termination : CONJECTURE % MM
    FORALL (dg:Graph_cc):
      EXISTS (fms:FunMeasures) : ccg_termination?(make_ccg(dg,fms))

END scp_to_ccg

