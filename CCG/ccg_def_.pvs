%********************************************************************************%
% Calling Context Graphs                                                         %
%                                                                                %
%   Authors:                                                                     %
%                                                                                %
%       Andréia Borges Avelar -- Universidade de Brasília - Brasil               %
%       Mauricio Ayala-Rincon -- Universidade de Brasília - Brasil               %
%                 César Muñoz -- NASA Langley Research Center - US               %
%                                                                                %
%********************************************************************************%

ccg_def_[Val,Expr,Condition: TYPE,
    MT: TYPE, lt : (well_founded?[MT]), N: posnat,
    % Importings needed to work with uninterpreted digraphs
    ConcreteDigraph: TYPE,
    (IMPORTING cc_def[Val,Expr,Condition]) 
    vert:  [ConcreteDigraph-> [CallingContext -> bool]],
    edges: [ConcreteDigraph -> [CallingContext,CallingContext -> bool]],
    size:  [ConcreteDigraph -> nat],
    make:  [ v:(is_finite[CallingContext]),
             {e: (is_finite[[CallingContext,CallingContext]]) | 
	         FORALL(x,y:CallingContext): 
    	          e(x,y) IMPLIES v(x) AND v(y) } -> ConcreteDigraph] ]: THEORY 
BEGIN
  ASSUMING
    % This theory only makes sense if the parametric type ConcreteDigraph is a 
    % correct interpretation for (uninterpreted) digraphs. That is checked using 
    % the predicate defined in digraphs_abs.
    IMPORTING digraphs@digraphs_abs[CallingContext,ConcreteDigraph,vert,edges,size,make]
    concretedigraph_implements_abstractdigraph: ASSUMPTION
      digraphs_abs.correct_implementation
  ENDASSUMING
% ------------------------------------------------------------------------------- %

 FunMeasure: TYPE = [Val -> MT]

 FunMeasures: TYPE = [below(N) -> FunMeasure]

 le(mt1,mt2:MT) : bool = mt1=mt2 OR lt(mt1,mt2)

 gt(mt1,mt2:MT) : bool = lt(mt2,mt1)

 ge(mt1,mt2:MT) : bool = le(mt2,mt1)

 IMPORTING digraphs@circuits_[CallingContext,ConcreteDigraph,vert,edges,size,make],
           structures@seq_extras[below[N]]
 
 CCG: TYPE = [# dg: ConcreteDigraph, ms: FunMeasures #]

 make_ccg(d:ConcreteDigraph,m:FunMeasures) : CCG = (# dg := d, ms := m #)

END ccg_def_
