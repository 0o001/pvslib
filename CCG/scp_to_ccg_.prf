(scp_to_ccg_
 (IMP_digraphs__TCC1 0
  (IMP_digraphs__TCC1-1 nil 3657022360
   ("" (use "concretedigraph_implements_abstractdigraph") nil nil)
   ((concretedigraph_implements_abstractdigraph formula-decl nil
     scp_to_ccg_ nil))
   nil))
 (omega_is_wf 0
  (omega_is_wf-1 nil 3652804647
   ("" (use "scp_termination")
    (("" (expand "scp_termination?")
      (("" (use "no_infinite_descending_sequence")
        (("" (assert)
          (("" (hide 2)
            (("" (expand "empty?")
              (("" (skolem 1 "vals")
                (("" (expand "member")
                  (("" (expand "descending?")
                    (("" (expand "R")
                      ((""
                        (name "ccs_seq"
                              "LAMBDA(n: nat): epsilon({cc: (CCs) |
                                                                         eval_conds
                                                                                   (cc`conds, vals(n))
                                                                          AND
                                                                          semantic_rel(cc`actuals, vals(n),
                                                                                            vals(1 + n))})")
                        (("1" (inst -3 "ccs_seq" "vals")
                          (("1" (expand "infinite_seq_ccs")
                            (("1" (skeep)
                              (("1"
                                (replaces -1 :dir rl)
                                (("1"
                                  (assert)
                                  (("1"
                                    (inst -1 "i")
                                    (("1"
                                      (use "epsilon_ax[(CCs)]")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (split -1)
                                          (("1" (propax) nil nil)
                                           ("2" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (inst -1 "0")
                          (("2" (skeep -1)
                            (("2" (inst 1 "cc") nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((scp_termination? const-decl "bool" scp nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (Seq_val type-eq-decl nil cc_def nil)
    (epsilon_ax formula-decl nil epsilons nil)
    (infinite_seq_ccs const-decl "bool" scp nil)
    (TRUE const-decl "bool" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Expr formal-type-decl nil scp_to_ccg_ nil)
    (Condition formal-type-decl nil scp_to_ccg_ nil)
    (CallingContext type-eq-decl nil cc_def nil)
    (set type-eq-decl nil sets nil)
    (CCs formal-const-decl "set[CallingContext]" scp_to_ccg_ nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (epsilon const-decl "T" epsilons nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (eval_conds formal-const-decl "PRED[[Condition, Val]]" scp_to_ccg_
     nil)
    (sequence type-eq-decl nil sequences nil)
    (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]"
     scp_to_ccg_ nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (descending? const-decl "bool" monotone_sequences "orders/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (R const-decl "bool" scp_to_ccg_ nil)
    (Val formal-type-decl nil scp_to_ccg_ nil)
    (no_infinite_descending_sequence formula-decl nil well_foundedness
     "orders/")
    (scp_termination formula-decl nil scp_to_ccg_ nil))
   nil))
 (omega_is_finite 0
  (omega_is_finite-1 nil 3652804995
   ("" (use "sem_rel_finite")
    (("" (expand "R") (("" (propax) nil nil)) nil)) nil)
   ((R const-decl "bool" scp_to_ccg_ nil)
    (sem_rel_finite formula-decl nil scp_to_ccg_ nil))
   shostak))
 (IMP_omega_TCC1 0
  (IMP_omega_TCC1-1 nil 3652804627 ("" (use "omega_is_wf") nil nil)
   ((omega_is_wf formula-decl nil scp_to_ccg_ nil)) nil))
 (IMP_omega_TCC2 0
  (IMP_omega_TCC2-1 nil 3652804627 ("" (use "omega_is_finite") nil nil)
   ((omega_is_finite formula-decl nil scp_to_ccg_ nil)) nil))
 (IMP_ccg__TCC1 0
  (IMP_ccg__TCC1-1 nil 3657022360 ("" (use "wf_nat") nil nil)
   ((wf_nat formula-decl nil naturalnumbers nil)) nil))
 (scp_implies_ccg_termination 0
  (scp_implies_ccg_termination-1 nil 3652804854
   ("" (skeep)
    (("" (inst 1 "LAMBDA(i:below(1)): Omega")
      (("1" (expand "ccg_termination?")
        (("1" (skeep :preds? t :but (("c" "circuit")))
          (("1"
            (inst 1
             "(# length := length(circuit), seq := LAMBDA(i: below(length(circuit))): 0 #)")
            (("1" (expand "gt_mc?")
              (("1" (split 1)
                (("1" (expand "gte_mc?")
                  (("1" (skeep)
                    (("1" (expand "finseq_appl")
                      (("1" (expand "gt")
                        (("1" (skeep)
                          (("1" (expand "ge")
                            (("1" (expand "le")
                              (("1"
                                (flatten)
                                (("1"
                                  (expand "make_ccg")
                                  (("1"
                                    (use "omega_increasing")
                                    (("1"
                                      (expand "R")
                                      (("1"
                                        (hide-all-but (-1 -2 1))
                                        (("1"
                                          (inst 1 "circuit(i_1)")
                                          (("1"
                                            (assert)
                                            (("1" (grind) nil nil))
                                            nil)
                                           ("2"
                                            (expand "finseq_appl")
                                            (("2"
                                              (typepred "dg")
                                              (("2"
                                                (typepred "circuit")
                                                (("2"
                                                  (expand "subset?")
                                                  (("2"
                                                    (expand "member")
                                                    (("2"
                                                      (inst?)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "finseq_appl")
                  (("2" (expand "gt")
                    (("2" (inst 1 "0")
                      (("1" (skeep)
                        (("1" (expand "make_ccg")
                          (("1" (expand "ge")
                            (("1" (expand "le")
                              (("1"
                                (use "omega_increasing")
                                (("1" (assert) nil nil)
                                 ("2"
                                  (expand "R")
                                  (("2"
                                    (hide-all-but (-1 -2 1))
                                    (("2"
                                      (inst 1 "circuit(0)")
                                      (("1" (grind) nil nil)
                                       ("2"
                                        (expand "finseq_appl")
                                        (("2"
                                          (typepred "dg")
                                          (("2"
                                            (expand "subset?")
                                            (("2"
                                              (assert)
                                              (("2"
                                                (expand "member")
                                                (("2"
                                                  (typepred "circuit")
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil)
       ("2" (skeep) (("2" (use "omega_is_wf") nil nil)) nil))
      nil))
    nil)
   ((R const-decl "bool" scp_to_ccg_ nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (Val formal-type-decl nil scp_to_ccg_ nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Expr formal-type-decl nil scp_to_ccg_ nil)
    (Condition formal-type-decl nil scp_to_ccg_ nil)
    (ConcreteDigraph formal-type-decl nil scp_to_ccg_ nil)
    (CallingContext type-eq-decl nil cc_def nil)
    (vert formal-const-decl
     "[ConcreteDigraph -> [CallingContext -> bool]]" scp_to_ccg_ nil)
    (edges formal-const-decl
     "[ConcreteDigraph -> [CallingContext, CallingContext -> bool]]"
     scp_to_ccg_ nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (make formal-const-decl "[v: (is_finite[CallingContext]),
 {e: (is_finite[[CallingContext, CallingContext]]) |
          FORALL (x, y: CallingContext): e(x, y) IMPLIES v(x) AND v(y)} ->
   ConcreteDigraph]" scp_to_ccg_ nil)
    (FunMeasure type-eq-decl nil ccg_def_ nil)
    (FunMeasures type-eq-decl nil ccg_def_ nil)
    (Omega const-decl "nat" omega "orders/")
    (gt_mc? const-decl "bool" ccg_ nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (val2 skolem-const-decl "Val" scp_to_ccg_ nil)
    (val1 skolem-const-decl "Val" scp_to_ccg_ nil)
    (gte_mc? const-decl "bool" ccg_ nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (le const-decl "bool" ccg_def_ nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i_1 skolem-const-decl "below(length(circuit) - 1)" scp_to_ccg_
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (verts_in? const-decl "bool" walks_ "digraphs/")
    (edge? const-decl "bool" digraphs_ "digraphs/")
    (walk? const-decl "bool" walks_ "digraphs/")
    (pre_circuit? const-decl "bool" circuits_ "digraphs/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (val2 skolem-const-decl "Val" scp_to_ccg_ nil)
    (val1 skolem-const-decl "Val" scp_to_ccg_ nil)
    (omega_increasing formula-decl nil omega "orders/")
    (ge const-decl "bool" ccg_def_ nil) (gt const-decl "bool" ccg_ nil)
    (measures_combination type-eq-decl nil ccg_ nil)
    (eval_conds formal-const-decl "PRED[[Condition, Val]]" scp_to_ccg_
     nil)
    (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]"
     scp_to_ccg_ nil)
    (PRED type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (/= const-decl "boolean" notequal nil)
    (not_empty_seq type-eq-decl nil seq_extras "structures/")
    (first const-decl "T" seq_extras "structures/")
    (> const-decl "bool" reals nil)
    (prewalk type-eq-decl nil walks_ "digraphs/")
    (circuit? const-decl "bool" circuits_ "digraphs/")
    (CCG type-eq-decl nil ccg_def_ nil)
    (make_ccg const-decl "CCG" ccg_def_ nil)
    (subset? const-decl "bool" sets nil)
    (CCs formal-const-decl "set[CallingContext]" scp_to_ccg_ nil)
    (Graph_cc type-eq-decl nil scp_to_ccg_ nil)
    (dg skolem-const-decl "Graph_cc" scp_to_ccg_ nil)
    (circuit skolem-const-decl "{c:
   prewalk
       [CallingContext[Val, Expr, Condition], ConcreteDigraph, vert, edges,
        make] |
         circuit?(dg(make_ccg(dg, LAMBDA (i: below(1)): Omega)), c)}"
     scp_to_ccg_ nil)
    (last const-decl "T" seq_extras "structures/")
    (ccg_termination? const-decl "bool" ccg_ nil)
    (omega_is_wf formula-decl nil scp_to_ccg_ nil))
   nil)))

