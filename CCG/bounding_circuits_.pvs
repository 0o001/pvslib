bounding_circuits_[T: TYPE, N: posnat,
    % Importings needed to work with parametric digraphs
    ConcreteDigraph: TYPE,
    vert:  [ConcreteDigraph-> [T -> bool]],
    edges: [ConcreteDigraph -> [T,T -> bool]],
    size:  [ConcreteDigraph-> nat],
    make:  [ v:(is_finite[T]),
             {e: (is_finite[[T,T]]) | 
	         FORALL(x,y:T): 
    	          e(x,y) IMPLIES v(x) AND v(y) } -> ConcreteDigraph],
    % Importings needed to work with parametric weighted digraphs
    wdg: TYPE,
    dg: [wdg -> ConcreteDigraph],
    (IMPORTING measures[N])   
    get_wgt: [W: wdg, (edges(dg(W))) -> measures[N].Measure_Matrix],
    WeightsMap    : TYPE,
    weighted_edge?: [WeightsMap->[[T,T]->bool]], 
    get_weight    : [map0:WeightsMap,(weighted_edge?(map0))->measures[N].Measure_Matrix],
    weight_map?   : [ConcreteDigraph->[WeightsMap-> bool ]],
    make_wdg: [cd:ConcreteDigraph,map2:(weight_map?(cd))->wdg] 
 ]: THEORY 
BEGIN
  ASSUMING
    % This theory only makes sense if the parametric type ConcreteDigraph is a 
    % correct interpretation for (uninterpreted) digraphs. That is checked using 
    % the predicate defined in digraphs_abs.
    IMPORTING digraphs@digraphs_abs[T,ConcreteDigraph,vert,edges,size,make]
    concretedigraph_implements_abstractdigraph: ASSUMPTION
      digraphs_abs.correct_implementation

    IMPORTING digraphs@weighted_digraphs_abs[T, measures[N].Measure_Matrix,
                                        measures[N].*, measures[N].id,
					ConcreteDigraph,vert,edges,size,make,
					wdg,dg,get_wgt,WeightsMap,weighted_edge?,
					get_weight,weight_map?,make_wdg]
    concretewd_implements_abstractwd: ASSUMPTION
      weighted_digraphs_abs.correct_implementation
  ENDASSUMING

   IMPORTING matrix_wdg_[T, N,
		         ConcreteDigraph,vert,edges,size,make,
			 wdg,dg,get_wgt,WeightsMap,weighted_edge?,
			 get_weight,weight_map?,make_wdg]

  G: VAR wdg

  % LWalk(G:wdg) : TYPE = {L: list[vert(dg(G))] | EXISTS (w: Walk(dg(G))): list2finseq(L) = w}
  
  VertList(G:wdg) : TYPE =
    {L : list[vert(dg(G))] |
      FORALL (v: vert(dg(G))):
        EXISTS (i:below(length(L))):
	  nth(L, i) = v AND
	  FORALL(j:below(length(L))): nth(L, j) = nth(L, i) IMPLIES j=i } 

  Cycles_at(G:wdg, v:vert(dg(G))): TYPE = {L : list[Walk(dg(G))] | FORALL (walk: Walk(dg(G))): member(walk, L) IFF cycle_at?(dg(G), walk, v)} 

%  LCycles_at(G:wdg, v:vert(dg(G))): TYPE = {L : list[LWalk(G)] | FORALL (walk: Walk(dg(G))): 
%                                            member(finseq2list(walk), L) IFF cycle_at?(dg(G), walk, v)} 
 
  Vert_Cycles(G:wdg): TYPE = [# vert: vert(dg(G)), 
   		      	      cycles: Cycles_at(G, vert) #]

%  LVert_Cycles(G:wdg): TYPE = [# vert: vert(dg(G)), 
%   		      	      lcycles: LCycles_at(G, vert) #]

  vclist(G:wdg, VL:VertList(G))(L:list[Vert_Cycles(G)]): bool =
    length(L) = length(VL) AND 
    FORALL (n:below(length(L))): nth(VL, n) = nth(L, n)`vert

  VC_List(G:wdg, VL:VertList(G)): TYPE =
    (vclist(G,VL))
 
%  LVC_List(G:wdg, VL:VertList(G)): TYPE = {L : list[LVert_Cycles(G)] | length(L) = length(VL) AND 
%   FORALL (n:below(length(L))): nth(VL, n) = nth(L, n)`vert  }        
  
  is_less_MM_list(M: Measure_Matrix, LM: list[Measure_Matrix]): 
    RECURSIVE {b: bool | b IMPLIES EXISTS (MM:Measure_Matrix): member(MM, LM) AND MM<=M}  =
    IF null?(LM) THEN FALSE 
    ELSIF car(LM) <= M THEN TRUE
    ELSE is_less_MM_list(M, cdr(LM))
    ENDIF
    MEASURE length(LM)
 
  minimalize_iter( LM:list[Measure_Matrix], ret:list[Measure_Matrix]): 
    RECURSIVE {L: list[Measure_Matrix] | ( FORALL ((M: Measure_Matrix | member(M, LM) OR member(M, ret))): EXISTS (MM:Measure_Matrix): member(MM, L) AND MM<=M) AND (FORALL (m:Measure_Matrix): member(m, L) IMPLIES (member(m, ret) OR member(m, LM)))  } = 
    IF null?(LM) THEN ret
    ELSE LET fr = car(LM) IN 
      IF is_less_MM_list(fr, ret) THEN minimalize_iter(cdr(LM), ret)
      ELSE minimalize_iter(cdr(LM), cons(fr, ret))
      ENDIF
    ENDIF
    MEASURE length(LM)

  minimalize( LM:list[Measure_Matrix] ): { L: list[Measure_Matrix] |
     (FORALL ((M: Measure_Matrix | member(M, LM))):
        EXISTS (MM:Measure_Matrix): member(MM, L) AND MM<=M) AND
     (FORALL(m:Measure_Matrix): member(m, L) IMPLIES member(m, LM)) } = 
   minimalize_iter(minimalize_iter(LM, null[Measure_Matrix]), null[Measure_Matrix]) 

  list_prod_pre(l1, l2: list[Measure_Matrix]): RECURSIVE
   { L : list[Measure_Matrix] | FORALL (m1, m2: Measure_Matrix): 
     member(m1, l1) AND member(m2, l2) IMPLIES 
     member(m1*m2, L) } = 
   IF null?(l1) THEN null[Measure_Matrix] 
   ELSE append(map(LAMBDA (M:Measure_Matrix): car(l1)*M)(l2), list_prod_pre(cdr(l1), l2))
   ENDIF
   MEASURE length(l1)

  list_prod(l1, l2: list[Measure_Matrix]): 
   { L : list[Measure_Matrix] | FORALL (m1, m2: Measure_Matrix): 
     member(m1, l1) AND member(m2, l2) IMPLIES 
     EXISTS (M: Measure_Matrix): member(M, L) AND M<=m1*m2 } =
   minimalize(list_prod_pre(l1, l2))
  

 decomp_weight(G:wdg, cd: walk_decomp(dg(G))): RECURSIVE Measure_Matrix = 
   IF length(cd) = 1 THEN wgt_walk(G, nth(cd, 0)`c) 
   ELSE wgt_walk(G, nth(cd, 0)`c)*
        wgt_walk(G, gen_seq2(dg(G), nth(cd,0)`v, nth(cd,1)`v))*
        decomp_weight(G, cdr(cd))
   ENDIF
   MEASURE length(cd)

 decomp_weight_def: 
  LEMMA 
  FORALL (G: wdg, cd: walk_decomp(dg(G))): 
   decomp_weight(G, cd) = wgt_walk(G, decomp_to_walk(dg(G), cd))

 walk_bounding(G,(walk:Walk(dg(G))),bs:[vert(dg(G))->list[Measure_Matrix]]):
 RECURSIVE list[Measure_Matrix] = 
   LET meas_list = cons(id, bs(walk(0))) IN
   IF length(walk) = 1 THEN meas_list
   ELSE list_prod(
          map(LAMBDA (m1: Measure_Matrix): m1 * wgt_walk(G, walk^(0,1)))(meas_list), 
          walk_bounding(G, walk^(1, length(walk)-1), bs))
   ENDIF
 MEASURE length(walk)

  % lwalk_bounding(G:wdg, lwalk: LWalk(G) , 
  %  bs: [vert(dg(G))->list[Measure_Matrix]]): RECURSIVE 
  %  list[Measure_Matrix] = 
  %  LET meas_list = cons(id, bs(car(lwalk))) IN
  %  IF length(lwalk) = 1 THEN meas_list
  %  ELSE list_prod( map( LAMBDA (m1: Measure_Matrix): m1 * wgt(G)(car(lwalk),car(cdr(lwalk))))(meas_list), 
  %                 lwalk_bounding(G, cdr(lwalk), bs))
  %  ENDIF
  %  MEASURE length(lwalk)  

  % lwalk_bounding_eq:
  %  LEMMA 
  %  FORALL (G: wdg, lwalk:LWalk(G), walk:Walk(dg(G)), bs: [vert(dg(G))->list[Measure_Matrix]]):
  %  list2finseq(lwalk) = walk IMPLIES
  %  walk_bounding(G, walk, bs) = lwalk_bounding(G, lwalk, bs)   

  walk_bounding_def: 
  LEMMA 
  FORALL (G:wdg, n:nat, walk: Walk(dg(G)), 
   bs: [vert(dg(G))->list[Measure_Matrix]]):
   (FORALL (v2:vert(dg(G))): 
        FORALL (cc: prewalk | (circuit_at?(dg(G), cc, v2) AND length(cc)<= n)): 
        EXISTS (M2:Measure_Matrix): member(M2, bs(v2)) AND M2<=wgt_walk(G, cc)) IMPLIES
    (FORALL ((cd : walk_decomp(dg(G)) | FORALL (j:below(length(cd))): nth(cd, j)`c`length<=n)): 
     drop_circuits(dg(G), cd) = walk IMPLIES 
     EXISTS (M: Measure_Matrix): member(M, walk_bounding(G, walk, bs) ) AND M<= decomp_weight(G, cd))


  walk_bounding_has_walk_wgt: LEMMA 
    FORALL (G:wdg, walk: Walk(dg(G)),bs: [vert(dg(G))->list[Measure_Matrix]]): 
     EXISTS (M: Measure_Matrix):
       member(M, walk_bounding(G, walk, bs)) AND M<=wgt_walk(G, walk)


 
 walk_list_bounding(G,(wlist:list[Walk(dg(G))]),bs:[vert(dg(G))->list[Measure_Matrix]]):
   RECURSIVE list[Measure_Matrix] = 
    IF null?(wlist) THEN null[Measure_Matrix] 
    ELSE append(walk_bounding(G, car(wlist), bs), walk_list_bounding(G, cdr(wlist), bs))
    ENDIF
    MEASURE length(wlist) 

 % lwalk_list_bounding(G:wdg, lwlist: list[LWalk(G)], bs: [vert(dg(G))->list[Measure_Matrix]]):
 %   RECURSIVE list[Measure_Matrix] = 
 %    IF null?(lwlist) THEN null[Measure_Matrix] 
 %    ELSE append(lwalk_bounding(G, car(lwlist), bs), lwalk_list_bounding(G, cdr(lwlist), bs))
 %    ENDIF
 %    MEASURE length(lwlist) 

 % lwalk_list_bounding_eq: 
 %   LEMMA 
 %   FORALL (G:wdg, lwlist: list[LWalk(G)], wlist: list[Walk(dg(G))], bs: [vert(dg(G))->list[Measure_Matrix]]):
 %   map(list2finseq)(lwlist) = wlist IMPLIES
 %  walk_list_bounding(G, wlist, bs) = lwalk_list_bounding(G, lwlist, bs)

 walk_list_bounding_def: 
   LEMMA 
   FORALL (G:wdg, n:nat, wlist: list[Walk(dg(G))], bs: [vert(dg(G))->list[Measure_Matrix]]):
   (FORALL (v2:vert(dg(G))):
    FORALL (cc: prewalk | (circuit_at?(dg(G), cc, v2) AND length(cc)<= n)): 
    EXISTS (M2:Measure_Matrix): member(M2, bs(v2)) AND M2<=wgt_walk(G, cc)) 
   IMPLIES
   (FORALL (walk:Walk(dg(G)), (cd:walk_decomp(dg(G)) | FORALL (j:below(length(cd))): nth(cd, j)`c`length<=n)):
    member(walk, wlist) AND drop_circuits(dg(G), cd) = walk 
     IMPLIES
    EXISTS (M: Measure_Matrix): 
       member(M, walk_list_bounding(G, wlist, bs)) 
       AND M<= decomp_weight(G, cd))

 walk_list_bounding_has_walk_wgt:
  LEMMA 
    FORALL (G:wdg, wlist: list[Walk(dg(G))], 
   bs: [vert(dg(G))->list[Measure_Matrix]], walk:Walk(dg(G))):
    member(walk, wlist) IMPLIES
    (EXISTS (M: Measure_Matrix): member(M, walk_list_bounding(G, wlist, bs)) AND M<=wgt_walk(G, walk)) 

 bound_circuits_at(G:wdg, vc:Vert_Cycles(G), bs:[vert(dg(G))->list[Measure_Matrix]]): 
   list[Measure_Matrix] = minimalize(walk_list_bounding(G, vc`cycles, bs))

 % lbound_circuits_at(G:wdg, lvc:LVert_Cycles(G), bs:[vert(dg(G))->list[Measure_Matrix]]): 
 %   list[Measure_Matrix] = minimalize(lwalk_list_bounding(G, lvc`lcycles, bs))

 % lbound_circuits_at_eq:
 %  LEMMA 
 %  FORALL (G:wdg, lvc:LVert_Cycles(G), vc: Vert_Cycles(G), bs:[vert(dg(G))->list[Measure_Matrix]]):
 %   lvc`vert = vc`vert AND
 %   map(list2finseq)(lvc`lcycles) = vc`cycles IMPLIES
 %   bound_circuits_at(G, vc, bs) = lbound_circuits_at(G, lvc, bs)

 bound_circuits_at_def: 
   LEMMA 
   FORALL (G:wdg, n:nat, vc:Vert_Cycles(G), bs:[vert(dg(G))->list[Measure_Matrix]]):
    (FORALL (v2:vert(dg(G))):
    FORALL (cc: prewalk | (circuit_at?(dg(G), cc, v2) AND length(cc)<= n)): 
    EXISTS (M2:Measure_Matrix): member(M2, bs(v2)) AND M2<=wgt_walk(G, cc)) 
   IMPLIES 
   (FORALL (circ: prewalk):
      ((circuit_at?(dg(G), circ, vc`vert) AND length(circ)<=n+1) OR cycle_at?(dg(G), circ, vc`vert))
      IMPLIES 
      (EXISTS (M: Measure_Matrix): member(M, bound_circuits_at(G, vc, bs)) AND M<=wgt_walk(G, circ)))

 mm_list_bool(mm_list: list[Measure_Matrix]): bool = every(positive?)(mm_list)
 
 index_of_vert(G: wdg, v:vert(dg(G)), (VL:list[vert(dg(G))]| EXISTS (i:below(length(VL))): nth(VL, i) = v AND FORALL(j:below(length(VL))): nth(VL, j) = nth(VL, i) IMPLIES j=i)): 
  RECURSIVE {i : below(length(VL)) | nth(VL, i) = v AND FORALL (j:below(length(VL))):              
             nth(VL, j) = v IMPLIES i=j}  =
  IF car(VL) = v THEN 0 
  ELSE 1+index_of_vert(G, v, cdr(VL))
  ENDIF
  MEASURE length(VL)

 bound_circuits_list(
   G,
   (vl    : VertList(G)),
   vc_list: VC_List(G, vl),
   bs     : [vert(dg(G))->list[Measure_Matrix]]) : list[list[Measure_Matrix]] =
     map(LAMBDA (vc: Vert_Cycles(G)): bound_circuits_at(G, vc, bs))(vc_list)

 % lbound_circuits_list(G:wdg, vl: VertList(G), lvc_list: LVC_List(G, vl), bs: [vert(dg(G))-> list[Measure_Matrix]]): 
 %   list[list[Measure_Matrix]] = map(LAMBDA (lvc: LVert_Cycles(G)): lbound_circuits_at(G, lvc, bs))(lvc_list)

 bound_circuits_list_def: 
  LEMMA 
  FORALL (G:wdg, n:nat, v:vert(dg(G)), vl: VertList(G), vc_list: VC_List(G, vl), bs:[vert(dg(G))->list[Measure_Matrix]]):
    (FORALL (v2:vert(dg(G))):
    FORALL (cc: prewalk | (circuit_at?(dg(G), cc, v2) AND length(cc)<= n)): 
    EXISTS (M2:Measure_Matrix): member(M2, bs(v2)) AND M2<=wgt_walk(G, cc)) 
   IMPLIES 
   (FORALL (circ: prewalk):
      ((circuit_at?(dg(G), circ, v) AND length(circ)<=n+1) OR cycle_at?(dg(G), circ, v))
      IMPLIES 
      (EXISTS (M: Measure_Matrix): member(M, nth(bound_circuits_list(G, vl, vc_list, bs), index_of_vert(G, v, vl))) AND M<=wgt_walk(G, circ)))

 MM_list_bool(mm_list: list[list[Measure_Matrix]]): bool = every(LAMBDA(b:bool): b)( map(mm_list_bool)(mm_list))

bound_circuits_iter(G:wdg, vl: VertList(G), vc_list: VC_List(G, vl), bs: [vert(dg(G))-> list[Measure_Matrix]], i:nat):
  RECURSIVE [vert(dg(G))-> list[Measure_Matrix]] = 
  IF i=0 THEN bs 
  ELSE LET bcl = bound_circuits_list(G, vl, vc_list, bs), 
           nbs(v:vert(dg(G))) = nth(bcl, index_of_vert(G, v, vl)) IN
   bound_circuits_iter(G, vl, vc_list, nbs, i-1)
  ENDIF 
  MEASURE i

 bound_circuits_iter_def: 
  LEMMA 
  FORALL (G:wdg, n:nat, v:vert(dg(G)), vl: VertList(G), vc_list: VC_List(G, vl), bs:[vert(dg(G))->list[Measure_Matrix]], i:posnat):
    (FORALL (v2:vert(dg(G))):
    FORALL (cc: prewalk | (circuit_at?(dg(G), cc, v2) AND length(cc)<= n)): 
    EXISTS (M2:Measure_Matrix): member(M2, bs(v2)) AND M2<=wgt_walk(G, cc)) 
   IMPLIES 
   (FORALL (circ: prewalk):
      ((circuit_at?(dg(G), circ, v) AND length(circ)<=n+i) OR cycle_at?(dg(G), circ, v))
      IMPLIES 
      (EXISTS (M: Measure_Matrix): member(M, bound_circuits_iter(G, vl, vc_list, bs, i)(v) ) AND M<=wgt_walk(G, circ))) 
         
 bound_circuits_iter_stable:
   LEMMA 
    FORALL (G:wdg, vl: VertList(G), vc_list: VC_List(G, vl), bs:[vert(dg(G))->list[Measure_Matrix]], i:posnat):
    map(bs)(vl) = bound_circuits_list(G, vl, vc_list, bs) IMPLIES
    bs = bound_circuits_iter(G, vl, vc_list, bs, i) 

  bound_circuits(G:wdg, vl:VertList(G), vc_list:VC_List(G, vl))(bs:BoundingSets(G)):
    BoundingSets(G) = 
    IF NOT bs`2 
       THEN (CircBound(G), FALSE, bs`3)
    ELSE LET bound_circ_list = bound_circuits_list(G, vl, vc_list, bs`3) IN
      IF NOT MM_list_bool(bound_circ_list) 
         THEN (CircBound(G), FALSE, bs`3)
      ELSIF map(bs`3)(vl) = bound_circ_list THEN 
          (CircBound(G), TRUE, bs`3)
      ELSE LET nbs(v:vert(dg(G))) = nth(bound_circ_list, index_of_vert(G, v, vl)) IN
          (min(bs`1+1, CircBound(G)), TRUE, nbs)  
      ENDIF
    ENDIF

  % lbound_circuits(G:wdg, vl:VertList(G), vc_list: LVC_List(G, vl), (n:nat | n = CircBound(G)))(bs:BoundingSets(G)):
  %   BoundingSets(G) = 
  %   IF NOT bs`2 
  %      THEN (n, FALSE, bs`3)
  %   ELSE LET bound_circ_list = lbound_circuits_list(G, vl, vc_list, bs`3) IN
  %     IF NOT MM_list_bool(bound_circ_list) 
  %        THEN (n, FALSE, bs`3)
  %     ELSIF map(bs`3)(vl) = bound_circ_list THEN 
  %         (n, TRUE, bs`3)
  %     ELSE (min(bs`1+1, n), TRUE, bound_circ_list)  
  %     ENDIF
  %   ENDIF
 
  bs0(G:wdg)(v:vert(dg(G))): list[Measure_Matrix] = null[Measure_Matrix] 

  start_bounding_list(G:wdg, vl: VertList(G), vc_list: VC_List(G, vl)): 
   list[list[Measure_Matrix]] = bound_circuits_list(G, vl, vc_list, bs0(G))

  start_bounding(G:wdg, vl: VertList(G), vc_list: VC_List(G, vl)): 
   BoundingSets(G) = 
    LET bc1 = start_bounding_list(G, vl, vc_list), 
    	nbs(v:vert(dg(G))) = nth(bc1, index_of_vert(G, v, vl)) IN
     (1, MM_list_bool(bc1), nbs)

  bounding_from_graph_lists(G,(vl:VertList(G)),vc_list:VC_List(G, vl)):bool =
    bounding_steps_iter( G,
     			 start_bounding(G, vl, vc_list),
			 bound_circuits(G, vl, vc_list) )

  bounding_from_gl_termination: 
   LEMMA 
   FORALL (G:wdg, vl:VertList(G), vc_list:VC_List(G, vl)):
   bounding_from_graph_lists(G, vl, vc_list) 
   IMPLIES
   mwg_termination?(G)

  END bounding_circuits_
 
