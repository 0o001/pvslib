;-*-lisp-*-

(defparameter *varbpts* nil) ;; (lb,ub) per variable
(defparameter *varipts* nil) ;; (b1,b2) per variable, where bi=TRUE means non-strict inequality

(load "collect-monomials.lisp")

(defun check-name (name)
  (let* ((name (if (stringp name) (intern name) name))
	 (pc-name (pc-parse name 'expr)))
    (resolve pc-name 'expr nil)))

(defun get-hash-keys (hash)
  (loop for k being the hash-key of hash
	collect k))

(defun get-pvs-expr (expr)
  (if (stringp expr)
      (pc-typecheck (pc-parse expr 'expr))
    (ee-pvs-obj (car (eval-ext-expr expr)))))

(defun get-string-expr (expr)
  (if (stringp expr) expr
     (format nil "~a" (get-pvs-expr expr))))

(defun enlistme (l)
  (if (listp l) l (list l)))

(defun iffequiv (a b)
  (equal (null a) (null b)))

(defun is-neq-relation (expr)
  (let ((rel (car (is-relation expr))))
    (when (not (equal rel '=)) rel)))

(defun neg-relation (rel)
  (cond ((equal rel '<)  '>=)
	((equal rel '<=) '>)
	((equal rel '>)  '<=)
	((equal rel '>=) '<)))

(defun variable-id (expr)
  (if (name-expr? expr) (id expr)
    (format nil "~a" expr)))

(defun is-variable-expr (expr &optional vars)
  (and (or (name-expr? expr)
	   (fieldappl? expr))
       (or (null vars)
	   (member (variable-id expr) vars :test #'string=))))

(defun is-function-expr (expr name)
  (and (application? expr)
       (name-expr? (operator expr))
       (string= (id (operator expr)) name)))

(defun number-from-expr (expr)
  (cond ((number-expr? expr) (number expr))
	((decimal? expr)
	 (/ (number (args1 expr)) (number (args2 expr))))
	((is-prefix-operator expr '-)
	 (let ((num (number-from-expr (args1 expr))))
	   (when num (- num))))
	((and (infix-application? expr)
	      (name-expr? (operator expr)))
	  (let* ((op  (car (member (id (operator expr)) '(+ - * /))))
		 (num1 (and op (number-from-expr (args1 expr))))
		 (num2 (and op num1 (number-from-expr (args2 expr)))))
	    (when num2 (cond ((equal op '+) (+ num1 num2))
			     ((equal op '-) (- num1 num2))
			     ((equal op '*) (* num1 num2))
			     ((equal op '/) (/ num1 num2))))))))

(defun is-number-type (type)
  (or (and (type-name? type)
           (equal type *number*))
      (and (subtype? type)
	   (is-number-type (supertype type)))))

(defun is-number-expr (expr)
  (is-number-type (type expr)))

;; Get intervals for each variable in vars in relational formulas fms.
;; If vars is null get all variables. Return variable list
(defun get-intervars (fms &optional vars)
  (setq *varbpts* (make-hash-table :test #'equal))
  (setq *varipts* (make-hash-table :test #'equal))
  (loop for fm in fms
	do  (let* ((rel     (is-neq-relation fm))
		   (islb    (or (equal rel '>=) (equal rel '>)))
		   (isincl  (or (equal rel '>=) (equal rel '<=))))
	      (and rel (not (equal rel '=))
		   (cond ((is-variable-expr (args1 fm) vars)
			  (let ((num (number-from-expr (args2 fm))))
			    (when num
			      (insert-interval (variable-id (args1 fm)) num islb isincl))))
			 ((is-variable-expr (args2 fm) vars)
			  (let ((num (number-from-expr (args1 fm))))
			    (when num
			      (insert-interval (variable-id (args2 fm)) num (not islb) isincl))))
			 ((and (is-function-expr (args1 fm) 'abs)
			       (is-variable-expr (args1 (args1 fm)) vars)
			       (not islb))
			  (let ((num (number-from-expr (args2 fm))))
			    (when num
			      (insert-interval (variable-id (args1 (args1 fm))) (- num) t isincl)
			      (insert-interval (variable-id (args1 (args1 fm))) num nil isincl))))
			 ((and (is-function-expr (args2 fm) 'abs)
			       (is-variable-expr (args1 (args2 fm)) vars)
			       islb)
			  (let ((num (number-from-expr (args1 fm))))
			    (when num
			      (insert-interval (variable-id (args1 (args2 fm))) (- num) t isincl)
			      (insert-interval (variable-id (args1 (args2 fm))) num nil isincl))))))))
  (or vars (get-hash-keys *varbpts*)))

(defun insert-interval (var val islb isincl)
  (let* ((var (format nil "~a" var))
	 (v   (gethash var *varbpts*))
	 (b   (gethash var *varipts*))
	 (lb  (car v))
	 (ub  (cdr v)))
    (if islb
	(let ((ilb (or (car b) isincl))
	      (iub (cdr b)))
	  (when (equal(max val (or lb val)) val)
	    (setf (gethash var *varbpts*) (cons val ub))
	    (setf (gethash var *varipts*) (cons ilb iub))))
      (let ((ilb (car b))
	    (iub (or (cdr b) isincl)))
	(when (equal (min val (or ub val)) val)
	  (setf (gethash var *varbpts*) (cons lb val))
	  (setf (gethash var *varipts*) (cons ilb iub)))))))

(defun find-unbound-vars (vars)
  (loop for v in vars
	when (let ((inter (gethash v *varbpts*)))
	       (and (null (car inter)) (null (cdr inter))))
	collect v))

(defun lambda-interval-lb (vars)
  (format nil "LAMBDA (i:nat): ~{IF i=~a THEN ~a ELS~}E 0 ENDIF"
	  (loop for i from 0 below (length vars)
		for v in vars
		append (list i (or (car (gethash v *varbpts*))
				   (- (cdr (gethash v *varbpts*)) 1))))))
(defun list-interval-lb (vars)
  (format nil "(:~{~a~^,~}:)"
	  (mapcar #'(lambda (v)
		      (or (car (gethash v *varbpts*))
			  (- (cdr (gethash v *varbpts*)) 1)))
		  vars)))

(defun lambda-interval-ub (vars)
  (format nil "LAMBDA (i:nat): ~{IF i=~a THEN ~a ELS~}E 0 ENDIF"
	  (loop for i from 0 below (length vars)
		for v in vars
		append (list i (or (cdr (gethash v *varbpts*))
				   (+ (car (gethash v *varbpts*)) 1))))))

(defun list-interval-ub (vars)
  (format nil "(:~{~a~^,~}:)"
	  (mapcar #'(lambda (v)
		      (or (cdr (gethash v *varbpts*))
			  (+ (car (gethash v *varbpts*)) 1)))
		  vars)))

(defun pvs-bool (l)
  (if l "true" "false"))

(defun lambda-interval-bpts (vars)
  (format nil "LAMBDA (i:nat): ~{IF i=~a THEN (~a,~a) ELS~}E (false,false) ENDIF"
	  (loop for i from 0 below (length vars)
		for v in vars
		append (list i (pvs-bool (car (gethash v *varbpts*)))
			     (pvs-bool (cdr (gethash v *varbpts*)))))))

(defun list-interval-bpts (vars)
  (format nil "(:~{(~a,~a)~^,~}:)"
	  (loop for v in vars
		append (list (pvs-bool (car (gethash v *varbpts*)))
			     (pvs-bool (cdr (gethash v *varbpts*)))))))

(defun lambda-interval-ipts (vars)
  (format nil "LAMBDA (i:nat): ~{IF i=~a THEN (~a) ELS~}E (false,false) ENDIF"
	  (loop for i from 0 below (length vars)
		for v in vars
		append (list i (cond ((and (car (gethash v *varbpts*)) (cdr (gethash v *varbpts*)))
				      (format nil "~a,~a"
					      (pvs-bool (car (gethash v *varipts*)))
					      (pvs-bool (cdr (gethash v *varipts*)))))
				     ((car (gethash v *varbpts*))
				      (format nil "~a,false" (pvs-bool (car (gethash v *varipts*)))))
				     ((cdr (gethash v *varbpts*))
				      (format nil "false,~a" (pvs-bool (cdr (gethash v *varipts*)))))
				     (t "false,false"))))))
(defun list-interval-ipts (vars)
  (format nil "(:~{(~a,~a)~^,~}:)"
	  (loop for v in vars
		append (list (cond ((and (car (gethash v *varbpts*)) (cdr (gethash v *varbpts*)))
				      (format nil "~a,~a"
					      (pvs-bool (car (gethash v *varipts*)))
					      (pvs-bool (cdr (gethash v *varipts*)))))
				     ((car (gethash v *varbpts*))
				      (format nil "~a,false" (pvs-bool (car (gethash v *varipts*)))))
				     ((cdr (gethash v *varbpts*))
				      (format nil "false,~a" (pvs-bool (cdr (gethash v *varipts*)))))
				     (t "false,false"))))))

(defun lambda-poly (list)
  (format nil "LAMBDA (i:nat)(j:nat)(k:nat): ~{IF i=~a AND j=~a AND k=~a THEN 1 ELS~}E 0 ENDIF" 
	  (loop for i from 0 below (length list)
		for l in list
		append (loop for j from 0 below (length l)
			     for v in l
			     append (list i j v)))))

(defun lambda-list (list)
  (let ((myl (loop for i from 0 below (length list)
		   for l in list
		   append (when (not (equal l 0)) (list i l)))))
    (format nil "LAMBDA(i:nat): ~a"
	    (if myl 
		(format nil "~{IF i=~a THEN ~a ELS~}E 0 ENDIF" myl)
	      0))))

;; Returns the conjuncts in expr in reverse order
(defun reverse-conjuncts (expr &optional conjs)
  (if (conjunction? expr)
      (reverse-conjuncts (args2 expr) (cons (args1 expr) conjs))
    (cons expr conjs)))

;; Returns variables in polynomial expression. Returns null if expression is not recognized
;; as a polynomial
(defun variables-in-poly (expr &optional vars)
  (cond ((is-variable-expr expr)
	 (let ((name (format nil "~a" (variable-id expr))))
	   (if (not (member name vars :test #'string=))
	       (cons name vars)
	     vars)))
	((number-from-expr expr) vars)
	((is-prefix-operator expr '-)
	 (variables-in-poly (args1 expr) vars))
	((and (or (is-infix-operator expr '^)
		  (is-infix-operator expr '/))
	      (number-from-expr (args2 expr)))
	 (variables-in-poly (args1 expr) vars))
	((and (infix-application? expr)
	      (name-expr? (operator expr))
	      (member (id (operator expr)) '(+ - *)))
	 (variables-in-poly (args2 expr) (variables-in-poly (args1 expr) vars)))))

;;;; STRATEGIES

(defstrat printf (msg &rest args)
  (let ((msg (format nil "~%~a" msg))
	(xxx (apply 'format (cons t (cons msg args)))))
    (skip))
  "[Extrategies] Prints the the Lisp formatted string MSG using the format arguments ARGS, but behaves
like skip. ARGS can only have constant values.")

(defstrat commentf (msg &rest args)
  (let ((msg (apply 'format (cons nil (cons msg args)))))
    (comment msg))
  "[Extrategies] Adds the formatted comment MSG to the sequent using the format arguments ARGS.
ARGS can only have constant values.")

(defstrat name-label (name expr &optional hide?)
  (let ((label (format nil "~a:" name))
	(expr  (get-string-expr expr)))
    (try-branch
     (name name expr)
     ((then
       (label label -1)
       (when hide? (hide label)))
      (skip))
     (skip)))
  "[Extrategies] Name a expression and put a label on it")

(defstrat inductionless__ (recvar &optional first)
  (let ((name (freshname "V"))
	(pre  (car (eval-ext-expr `(! * (-> ,recvar)))))
	(term (when pre (format nil "~a" (ee-pvs-obj pre)))))
    (if term
	(branch (name-replace name term :hide? t)
		((inductionless__ name)
		 (skip)))
      (when-not
       first
       (typepred recvar))))
  "[Extrategies] Internal strategy")

(defstrat inductionless (&optional (recvar "v"))
  (if (forall-expr? (extra-get-formula 1))
      (let ((recvar (format nil "~a!1" recvar)))
	(then (skosimp* :preds? t)
	      (repeat (inductionless__ recvar t))
	      (assert)))
    (then
     (repeat (inductionless__ recvar t))
     (assert)))
  "[Extrategies] Extracts inductionless principle from definition of recursive function. RECVAR is the
name of the quantified variable that encodes the recursive call.")

(defstrat multipoly__ (pvspoly rel name vars)
  (let ((poly (get-multivar-polynomial pvspoly vars))
	(msg  (when (not poly)
		(format
		 nil
		 "Expression doesn't seem to be a polynomial inequality on variable~:[~;s~] ~{~a~^,~}."
		 (cdr vars) vars))))
    (let (    (dummy (format t "~%~a~%~%" poly)))

    (if msg
	(printf msg)
      (let ((terms (length (cadr poly)))
	    (deg   (lambda-list (car poly)))
	    (coeff (lambda-list (mapcar #'car (cadr poly))))
	    (poly  (lambda-poly (mapcar #'cdr (cadr poly))))
	    (mpoly (format nil "mk_mpoly(~a,~a,~a,~a~@[,~a~])"
			   poly deg terms coeff rel)))
	(name-label name mpoly :hide? t))))
    )
  "[Bernstein] Internal strategy")

(defstep multipolynomial (poly &optional vars (bounds? t) (equiv? t) (name "P__"))
  (if (check-name name)
      (printf "Name ~a already defined, please provide a fresh name for representing the polynomial"
	      name)
    (let ((expr    (get-pvs-expr poly))
	  (rel     (is-neq-relation expr))
	  (pvspoly (cond (rel (let ((num (number-from-expr (args2 expr))))
				(if (and num (equal num 0)) (args1 expr)
				  (mk-application '- (args1 expr) (args2 expr)))))
			 ((is-number-expr expr) expr)))
	  (vars    (and pvspoly (or (enlistme vars) (variables-in-poly pvspoly))))
	  (msg     (when (null vars)
		     (format nil
			     "Expression doesn't seem to be a polynomial or a polynomial inequality."))))
      (if msg
	  (printf msg)
	(let ((lvarsname (format nil "vars_~a" name))
	      (nvars     (length vars))
	      (lvars     (lambda-list vars))
	      (label     (format nil "~a:" name))
	      (casestr   (format nil "~a = mpoly_eval(~a,~a)(~a)" pvspoly name nvars lvarsname)))
	  (then
	   (name-label lvarsname lvars :hide? t)
	   (try (multipoly__ pvspoly rel name vars)
		(let ((varsname  (format nil "vs~a" name)))
		  (try-branch (case casestr)
			      ((when bounds?
				 (multivariables vars :name varsname)
				 (rewrite lvarsname :dir rl))
			       (then (hide-all-but 1)
				     (when equiv? (multipoly-eq__ name)))
			       (skip))
			      (reveal label)))
		(skip)))))))
  "[Bernstein] Introduces a multivariate polynomial structure named NAME whose evaluation is
equivalent to the polynomial POLY on VARS. If NAME is not provided a new name is generated.
The variables of the polynomial are inferred when VARS is nil. If equiv? is nil, the strategy
does not try to prove the equivalence between the original polynomial and its Bernstein
representation"
  "[Bernstein] Introducing a multivariate polynomial structure")

(defstrat multivars__ (fms name vars)
  (let ((vars   (get-intervars fms vars))
	(unvars (find-unbound-vars vars))
	(msg    (when unvars
		  (format nil "Variable~:[~;s~] ~{~a~^,~} ~:[is~;are~] unbounded."
			  (cdr unvars) unvars (cdr unvars)))))
    (if msg
	(printf msg)
      (let ((lb      (lambda-interval-lb vars))
	    (ub      (lambda-interval-ub vars))
	    (iepts   (lambda-interval-ipts vars))
	    (bdpts   (lambda-interval-bpts vars))
	    (mvars   (format nil "mk_mvars(~a,~a,~a,~a,~a)" (length vars) lb ub iepts bdpts)))
	(name-label name mvars :hide? t))))
  "[Bernstein] Internal strategy")

(defstep multivariables (&optional vars (name "V__"))
  (if (check-name name)
      (printf "Name ~a already defined, please provide a fresh name for representing the variables"
	      name)
    (let ((vars     (enlistme vars))
	  (fms      (mapcar #'(lambda (fn) (extra-get-formula fn)) (extra-get-fnums '-))))
      (try (multivars__ fms name vars)
	   (let ((vars     (or vars (get-hash-keys *varbpts*)))
		 (lvars    (lambda-list vars))
		 (casestr  (format nil "mvars_between?(~a)(~a)" name lvars)))
	     (branch (case casestr)
		     ((skip)
		      (multivars-bet__ name)
		      (skip))))
	   (skip))))
  "[Bernstein] Introduces a multivariable structure named NAME"
  "[Bernstein] Introducing multivariable structure")

(defstrat multipoly-eq__ (name)
  (let ((varsname  (format nil "vs~a" name))
	(lvarsname (format nil "vars_~a" name))
	(npoly     (freshname "mp"))
	(ndeg      (freshname "md"))
	(ncoeff    (freshname "mc"))
	(poly      (format nil "~a`mpoly" name))
	(deg       (format nil "~a`mdeg" name))
	(coeff     (format nil "~a`mcoeff" name)))
    (then
     (name-replace npoly poly)
     (name-replace ndeg  deg)
     (name-replace ncoeff coeff)
     (expand* name varsname)
     (expand "multipoly_eval")
     (apply (repeat (expand "sigma")))
     (expand "polyproduct_eval")
     (apply (repeat (expand* "product" lvarsname)))
     (expand ncoeff :assert? none)
     (expand name :assert? nil)
     (expand ndeg :assert? none)
     (expand name :assert? nil)
     (expand "polynomial" :assert? none)
     (expand npoly :assert? none)
     (expand name :assert? nil)
     (apply (repeat (expand "sigma" :assert? nil)))
     (apply (repeat (rewrite "expt_x1")))
     (assert)
     (grind)))
  "[Bernstein] Internal strategy"
  )

(defstrat multivars-bet__ (name)
  (then
   (expand* "boxbetween?" "interval_between?")
   (skosimp* :preds? t)
   (expand name)
   (repeat (lift-if 1))
   (ground))
  "[Bernstein] Internal strategy")

(defstep minmax (poly &optional vars (precision "0.01") (depth 100)
		      vardir (equiv? t) (name "Pm__"))
  (if (check-name name)
      (printf "Name ~a already defined, please provide a fresh name for representing the polynomial"
	      name)
    (let ((vardir (or vardir "MaxVarMinDir"))
	  (expr (format nil "multipoly_minmax(~a,vs~a,~a,~a,~a)"
			name name depth vardir precision)))
      (try (multipolynomial poly vars :equiv? equiv? :name name)
	   (eval-expr expr)
	   (skip))))
  "[Bernstein] Find the minimum and maximum, within +-PRECISION, of a multivariate polynomial on
VARS. The option DEPTH specifies a maximum depth. The option VARDIR is an heuristic for
selecting variables and direction when subdividing the range of the variables, e.g., MaxVarMinDir,
MaxVarMaxDir,AltVarLeftRight, AltVarRightLeft (see theory Bernstein/vardirselector.pvs).
If VARDIR is nil, an appropriate method is automatically selected. If equiv? is nil, the strategy does
not try to prove the equivalence between the original polynomial and its Bernstein representation."
  "[Bernstein] Finding the minimum and maximum of a polynomial"
  )

(defstep bernstein (&optional (fnum 1) vars (depth 100) vardir (equiv? t) (name "Pb__"))
  (if (check-name name)
      (printf "Name ~a already defined, please provide a fresh name for representing the polynomial"
	      name)
    (then (beta)
	  (let ((fnum    (car (extra-get-fnums fnum)))
		(fm      (extra-get-formula fnum))
		(quant   (cond ((forall-expr? fm) 1)
			       ((exists-expr? fm) -1))) ;; forall == quant > 0, exists == quant < 0
		(proof   (or (not quant) (iffequiv (> fnum 0) (> quant 0)))) ;; proof=false : find counterexample
		(exprs   (cond ((exists-expr? fm) (reverse-conjuncts (expression fm)))
			       ((and (forall-expr? fm) (implication? (expression fm)))
				(cons (args2 (expression fm))
				      (reverse-conjuncts (args1 (expression fm)))))))
		(fms     (if quant (cdr exprs)
		   (mapcar #'(lambda (fn) (extra-get-formula fn)) (extra-get-fnums '-))))
		(expr    (if quant (car exprs) fm))
		(rel     (if (iffequiv proof (> fnum 0)) (is-neq-relation expr)
			   (neg-relation (is-neq-relation expr))))
		(vardir  (or vardir
			     (if (member rel '(> >=))
				 "a2l__MaxVarMinDir"
			       "a2l__MaxVarMaxDir")))
		(pvspoly (when rel
			   (let ((num (number-from-expr (args2 expr))))
			     (if (and num (equal num 0)) (args1 expr)
			       (mk-application '- (args1 expr) (args2 expr))))))
	    (dummy (format t "~a~%" pvspoly))
		(vars    (when rel
			   (or (enlistme vars)
			       (if quant (mapcar #'(lambda (x) (format nil "~a" (id x))) (bindings fm))
				 (variables-in-poly pvspoly)))))
		(msg     (when (not vars)
			   (format nil "Formula ~a doesn't seem to be a polynomial inequality." fnum))))
	    (when fm
	      (if msg
		  (printf msg)
		(then
		 (relabel "bp:" fnum)
		 (bernstein__ quant proof fms vars rel pvspoly depth vardir equiv? name)))))))
  "[Bernstein] Proves polynomial inequality FNUM using Bernstein's basis on VARS for DEPTH levels
of recursion. The option VARDIR is an heuristic for selecting variables and direction when
subdividing the range of the variables, e.g., a2l__MaxVarMinDir, a2l__MaxVarMaxDir,
a2l__AltVarLeftRight, a2l__AltVarRightLeft (see theory Bernstein/vardirselector.pvs). If VARDIR
is nil, an appropriate method is automatically selected. If equiv? is nil, the strategy does not
try to prove the equivalence between the original polynomial and its Bernstein representation."
  "[Bernstein] Proving polynomial inequality using Bernstein's basis...")

(defstrat bernstein__ (quant proof fms vars rel pvspoly depth vardir equiv? polyname)
  (let ((msgvars  (format nil "variables (: ~{~a~^, ~} :)" vars))
	(varsname (format nil "vs~a" polyname))
	(sko      (and quant proof))
	(inst     (and quant (not proof)))
	(bps      (format nil "a2l__multipoly_strategy(~a,~a,~a,~a,~:[false~;true~])"
			  polyname varsname depth vardir proof))
	(dummy (format t "~%about to eval ~a~%" bps)))
    (try
     (multivars__ fms varsname vars)
     (try (multipoly__ pvspoly rel polyname vars)
	  (then
	   (eval-expr bps)
	   (let ((result    (args2 (extra-get-formula -1)))
		 (isunknown (and (constructor-name-expr? result) (equal (id result) '|Unknown|)))
		 (istrue    (and (constructor-name-expr? result) (equal (id result) '|IsTrue|)))
		 (isfalse   (and (not isunknown) (not istrue))))
	     (if isunknown
		 (then
		  (delabel "bp:")
		  (printf "Inequality could not be proved or disproved. Try a depth higher than ~a."
			  depth))
	       (if (and istrue (not inst))
		   (let ((newvars   (if sko (mapcar #'(lambda (x) (format nil "~a__" x))
						    vars) vars))
			 (lvars     (lambda-list newvars))
			 (lvarsname (format nil "vars_~a" polyname)))
		     (then
		      (lemma "a2l__multipoly_strategy_true")
		      (inst? -1)
		      (assert)
		      (branch (split -1)
			      ((then
				(hide -2)
				(relabel "bp:" -1)
				(when sko (skolem "bp:" newvars) (flatten))
				(expand "forall_X_poly_interval")
				(name-label lvarsname lvars :hide? t)
				(inst -1 lvarsname)
				(branch (split -1)
					((then
					  (hide-all-but "bp:")
					  (when equiv? (multipoly-eq__ polyname)))
					 (then
					  (hide-all-but "bp:")
					  (expand lvarsname)
					  (multivars-bet__ varsname)))))
			       (eval-formula)))))
		 (if (and isfalse (not inst))
		     (then (delabel "bp:")
			   (commentf "Counterexample has been found with ~a." msgvars))
		   (if isfalse
		       (let ((cex    (format nil "cex_~a" polyname))
			     (lex    (format nil "list2array(0)(~a)" (get-pvs-expr '(! -1 r 1))))
			     (inst   (mapcar #'(lambda (x) (format nil "~a(~a)" cex x))
					     (fromto 0 (- (length vars) 1))))
			     (stinst (cons 'inst (cons "bp:" inst))))
			 (then
			  (name cex lex)
			  stinst
			  (eval-formula "bp:")))
		     (skip)))))))
	  (skip))
     (skip)))
  "[Bernstein] Internal strategy")


